<!DOCTYPE html>
<html>
  <head>
      <script>
  var _hmt = _hmt || []
  ;(function() {
    var hm = document.createElement('script')
    hm.src = 'https://hm.baidu.com/hm.js?5a0acc897fd96474a2c8f4deac84611a'
    var s = document.getElementsByTagName('script')[0]
    s.parentNode.insertBefore(hm, s)
  })()
</script> 
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="keywords" content="Mino,前端,后端,全栈,NodeJs,JavaScript" />
    <meta name="description" content="Mino&#39;s personal blog" />
    
    <title>
      proxy笔记 - Mino
    </title>
    <link rel="manifest" href="/manifest.json" />
    <link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon" />
    <link rel="stylesheet" href="/style/style.css">
  <link rel="alternate" href="/atom.xml" title="Mino" type="application/atom+xml">
</head>
  <body>
    
    <div id="post-toc" class="animated hiddenToc hide">
      <span class="title">Toc</span>
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#一、proxy概述"><span class="toc-text">一、proxy概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Proxy的兼容性"><span class="toc-text">Proxy的兼容性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Proxy-实例也可以作为其他对象的原型对象"><span class="toc-text">Proxy 实例也可以作为其他对象的原型对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Proxy的作用"><span class="toc-text">Proxy的作用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二、Proxy所能代理的范围–handler"><span class="toc-text">二、Proxy所能代理的范围–handler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三、Proxy场景"><span class="toc-text">三、Proxy场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-实现私有变量"><span class="toc-text">3.1 实现私有变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-抽离校验模块"><span class="toc-text">3.2 抽离校验模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-访问日志"><span class="toc-text">3.3 访问日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-预警和拦截"><span class="toc-text">3.4 预警和拦截</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-过滤操作"><span class="toc-text">3.5 过滤操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-中断代理"><span class="toc-text">3.6 中断代理</span></a></li></ol></li></ol>
    </div>
    
    <div id="fixed-menu-wrap">
      <span class="iconfont icon-sousuo search-box menu-reset"></span>
      <span class="icon-toc menu-reset">Toc</span>
      <span class="iconfont icon-arrowup menu-reset"></span>
    </div>
    <div id="fixed-menu">
      <span class="iconfont icon-menu-"></span>
    </div>
    <div id="progress">
      <div class="line"></div>
    </div>
    <div id="search-shade" class="animated hiddenSearch hide">
      <div class="input-wrap">
        <span class="iconfont icon-sousuo search-box"></span>
        <input type="text" placeholder="Search" />
        <span class="iconfont icon-close"></span>
      </div>
      <div class="search-result">
        <div class="meta">
          <span><b id="result-count">0</b> results found</span>
          <img src="/images/logo.jpg" />
        </div>
        <ul id="result-box"></ul>
      </div>
    </div>
    <div id="menu-mask" class="animated hideMenuMask hide">
      <span class="iconfont icon-close"></span>
      <div class="nav">
        
        <a href="/" class="">
          首页
        </a>
        
        <a href="/about" class="">
          关于
        </a>
        
        <a href="/tags" class="">
          标签
        </a>
        
        <a href="/categories" class="">
          分类
        </a>
        
        <a href="/archives" class="">
          归档
        </a>
        
      </div>
    </div>
    <div id="header">
      <div class="intro">
        <a href="/" class="logo" style="background-image: url('/images/logo.jpg')"></a>
        <div class="author">Mino</div>
      </div>
      <div class="nav">
        <span class="iconfont icon-menu menu-icon"></span>
        <a href="#" class="search-box">
          <span class="iconfont icon-sousuo"></span>
        </a>
      </div>
    </div>
    <div id="side" class="animated bounceInLeft">
      <div class="shrink">
        <a href="/" class="logo" style="background-image: url('/images/logo.jpg')"></a>
        <span class="iconfont icon-menu toggle-icon"></span>
        <a href="#" class="search-box">
          <span class="iconfont icon-sousuo"></span>
        </a>
      </div>
      <div class="magnify">
        <div class="about">
          <div class="author">Mino</div>
          <a href="/" class="logo" style="background-image: url('/images/logo.jpg')"></a>
        </div>

        <div class="nav">
          
          <a href="/" class="">
            首页
          </a>
          
          <a href="/about" class="">
            关于
          </a>
          
          <a href="/tags" class="">
            标签
          </a>
          
          <a href="/categories" class="">
            分类
          </a>
          
          <a href="/archives" class="">
            归档
          </a>
          
          <a href="#" class="search-box">
            <span class="iconfont icon-sousuo"></span>
          </a>
        </div>
        <div class="bottom">
          <div class="follow">
            
            <a href="https://github.com/codermino" target="_block">
              <span class="iconfont icon-github"></span>
            </a>
            
            <a href="1227657064@qq.com" target="_block">
              <span class="iconfont icon-QQ"></span>
            </a>
             
            <a href="/atom.xml" target="_block">
              <span class="iconfont icon-rss"></span>
            </a>
            
          </div>
        </div>
      </div>
    </div>
    <div id="container">
      <div class="main animated bounceInRight delay-0.7s">
        <article class="post-entry">
    <div class="header">
      
      <div class="title">proxy笔记</div>
      <div class="meta">
        <span class="item">
          <span class="iconfont icon-time-circle"></span>
          <span>2020/10/14</span>
        </span>

        

         
        <span class="item">
          <span class="iconfont icon-folder"></span>
          <span>
              
                
                  <a href="/categories/javascript">javascript</a>
                
              
          </span>
        </span>
        
        
         
          <span class="item">
            <span class="iconfont icon-tag1"></span>
            <span>
                
                  
                    <a href="/tags/proxy笔记">proxy笔记</a>
                  
                
            </span>
          </span>
         
      </div>
      <div>
      </div>
    </div>
    <p><a href="/images/javascript/javascript.png" data-caption data-fancybox="images"><img src="/images/javascript/javascript.png" alt></a></p>
<h3 id="一、proxy概述">一、proxy概述<a class="post-anchor" href="#一、proxy概述"></a></h3><h4 id="Proxy的兼容性">Proxy的兼容性<a class="post-anchor" href="#Proxy的兼容性"></a></h4><p><a href="/images/proxy/proxy1.png" data-caption data-fancybox="images"><img src="/images/proxy/proxy1.png" alt></a></p>
<pre><code class="hljs markdown">proxy在目标对象的外层搭建了一层拦截，外界对目标对象的某些操作，必须通过这层拦截</code></pre>
<p>var proxy = new Proxy(target, handler);</p>
<pre><code class="hljs markdown">new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，
handler参数也是一个对象，用来定制拦截行为</code></pre>
<pre><code class="hljs javascript"><span class="hljs-keyword">var</span> target = &#123;
   <span class="hljs-attr">name</span>: <span class="hljs-string">'poetries'</span>
 &#125;;
 <span class="hljs-keyword">var</span> logHandler = &#123;
   <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">target, key</span>) </span>&#123;
     <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span> 被读取`</span>);
     <span class="hljs-keyword">return</span> target[key];
   &#125;,
   <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">target, key, value</span>) </span>&#123;
     <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span> 被设置为 <span class="hljs-subst">$&#123;value&#125;</span>`</span>);
     target[key] = value;
   &#125;
 &#125;
 <span class="hljs-keyword">var</span> targetWithLog = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, logHandler);
 
 targetWithLog.name; <span class="hljs-comment">// 控制台输出：name 被读取</span>
 targetWithLog.name = <span class="hljs-string">'others'</span>; <span class="hljs-comment">// 控制台输出：name 被设置为 others</span>
 
 <span class="hljs-built_in">console</span>.log(target.name); <span class="hljs-comment">// 控制台输出: others</span></code></pre>
<ul>
<li>targetWithLog 读取属性的值时，实际上执行的是 logHandler.get ：在控制台输出信息，并且读取被代理对象 target 的属性。</li>
<li>在targetWithLog 设置属性值时，实际上执行的是 logHandler.set ：在控制台输出信息，并且设置被代理对象 target 的属性的值<pre><code class="hljs javascript"><span class="hljs-comment">// 由于拦截函数总是返回35，所以访问任何属性都得到35</span>
<span class="hljs-keyword">var</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(&#123;&#125;, &#123;
  <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">target, property</span>) </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-number">35</span>;
  &#125;
&#125;);

proxy.time <span class="hljs-comment">// 35</span>
proxy.name <span class="hljs-comment">// 35</span>
proxy.title <span class="hljs-comment">// 35</span></code></pre>
<h4 id="Proxy-实例也可以作为其他对象的原型对象">Proxy 实例也可以作为其他对象的原型对象<a class="post-anchor" href="#Proxy-实例也可以作为其他对象的原型对象"></a></h4><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(&#123;&#125;, &#123;
  <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">target, property</span>) </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-number">35</span>;
  &#125;
&#125;);

<span class="hljs-keyword">let</span> obj = <span class="hljs-built_in">Object</span>.create(proxy);
obj.time <span class="hljs-comment">// 35</span></code></pre>
<pre><code class="hljs markdown">proxy对象是obj对象的原型，obj对象本身并没有time属性，所以根据原型链，会在proxy对象上读取该属性，导致被拦截</code></pre>
<h4 id="Proxy的作用">Proxy的作用<a class="post-anchor" href="#Proxy的作用"></a></h4><pre><code class="hljs markdown">对于代理模式 Proxy 的作用主要体现在三个方面</code></pre></li>
<li>拦截和监视外部对对象的访问</li>
<li>降低函数或类的复杂度</li>
<li>在复杂操作前对操作进行校验或对所需资源进行管理<h3 id="二、Proxy所能代理的范围–handler">二、Proxy所能代理的范围–handler<a class="post-anchor" href="#二、Proxy所能代理的范围–handler"></a></h3><pre><code class="hljs markdown">实际上 handler 本身就是ES6所新设计的一个对象.
它的作用就是用来自定义代理对象的各种可代理操作 。
它本身一共有13中方法,每种方法都可以代理一种操作.其13种方法如下</code></pre>
<pre><code class="hljs javascript">
<span class="hljs-comment">// 在读取代理对象的原型时触发该操作，比如在执行 Object.getPrototypeOf(proxy) 时。</span>
handler.getPrototypeOf()

<span class="hljs-comment">// 在设置代理对象的原型时触发该操作，比如在执行 Object.setPrototypeOf(proxy, null) 时。</span>
handler.setPrototypeOf()

 
<span class="hljs-comment">// 在判断一个代理对象是否是可扩展时触发该操作，比如在执行 Object.isExtensible(proxy) 时。</span>
handler.isExtensible()

 
<span class="hljs-comment">// 在让一个代理对象不可扩展时触发该操作，比如在执行 Object.preventExtensions(proxy) 时。</span>
handler.preventExtensions()

<span class="hljs-comment">// 在获取代理对象某个属性的属性描述时触发该操作，比如在执行 Object.getOwnPropertyDescriptor(proxy, "foo") 时。</span>
handler.getOwnPropertyDescriptor()

 
<span class="hljs-comment">// 在定义代理对象某个属性时的属性描述时触发该操作，比如在执行 Object.defineProperty(proxy, "foo", &#123;&#125;) 时。</span>
andler.defineProperty()

 
<span class="hljs-comment">// 在判断代理对象是否拥有某个属性时触发该操作，比如在执行 "foo" in proxy 时。</span>
handler.has()

<span class="hljs-comment">// 在读取代理对象的某个属性时触发该操作，比如在执行 proxy.foo 时。</span>
handler.get()

 
<span class="hljs-comment">// 在给代理对象的某个属性赋值时触发该操作，比如在执行 proxy.foo = 1 时。</span>
handler.set()

<span class="hljs-comment">// 在删除代理对象的某个属性时触发该操作，比如在执行 delete proxy.foo 时。</span>
handler.deleteProperty()

<span class="hljs-comment">// 在获取代理对象的所有属性键时触发该操作，比如在执行 Object.getOwnPropertyNames(proxy) 时。</span>
handler.ownKeys()

<span class="hljs-comment">// 在调用一个目标对象为函数的代理对象时触发该操作，比如在执行 proxy() 时。</span>
handler.apply()

 
<span class="hljs-comment">// 在给一个目标对象为构造函数的代理对象构造实例时触发该操作，比如在执行new proxy() 时。</span>
handler.construct()</code></pre>
<h3 id="三、Proxy场景">三、Proxy场景<a class="post-anchor" href="#三、Proxy场景"></a></h3><h4 id="3-1-实现私有变量">3.1 实现私有变量<a class="post-anchor" href="#3-1-实现私有变量"></a></h4><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> target = &#123;
   <span class="hljs-attr">name</span>: <span class="hljs-string">'poetries'</span>,
   <span class="hljs-attr">_age</span>: <span class="hljs-number">22</span>
&#125;

<span class="hljs-keyword">var</span> logHandler = &#123;
  <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">target,key</span>)</span>&#123;
    <span class="hljs-keyword">if</span>(key.startsWith(<span class="hljs-string">'_'</span>))&#123;
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'私有变量age不能被访问'</span>)
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    &#125;
    <span class="hljs-keyword">return</span> target[key];
  &#125;,
  <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">target, key, value</span>) </span>&#123;
     <span class="hljs-keyword">if</span>(key.startsWith(<span class="hljs-string">'_'</span>))&#123;
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'私有变量age不能被修改'</span>)
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    &#125;
     target[key] = value;
   &#125;
&#125; 
<span class="hljs-keyword">var</span> targetWithLog = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, logHandler);
 
<span class="hljs-comment">// 私有变量age不能被访问</span>
targetWithLog.name; 
 
<span class="hljs-comment">// 私有变量age不能被修改</span>
targetWithLog.name = <span class="hljs-string">'others'</span>;</code></pre>
<pre><code class="hljs markdown">在下面的代码中，我们声明了一个私有的 apiKey，便于 api 这个对象内部的方法调用，但不希望从外部也能够访问 api._apiKey</code></pre>
<pre><code class="hljs javascript"><span class="hljs-keyword">var</span> api = &#123;  
    <span class="hljs-attr">_apiKey</span>: <span class="hljs-string">'123abc456def'</span>,
    <span class="hljs-comment">/* mock methods that use this._apiKey */</span>
    <span class="hljs-attr">getUsers</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;, 
    <span class="hljs-attr">getUser</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">userId</span>)</span>&#123;&#125;, 
    <span class="hljs-attr">setUser</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">userId, config</span>)</span>&#123;&#125;
&#125;;

<span class="hljs-comment">// logs '123abc456def';</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"An apiKey we want to keep private"</span>, api._apiKey);

<span class="hljs-comment">// get and mutate _apiKeys as desired</span>
<span class="hljs-keyword">var</span> apiKey = api._apiKey;  
api._apiKey = <span class="hljs-string">'987654321'</span>;</code></pre>
<pre><code class="hljs markdown">很显然，约定俗成是没有束缚力的。使用 ES6 Proxy 我们就可以实现真实的私有变量了，
下面针对不同的读取方式演示两个不同的私有化方法。
第一种方法是使用 set / get 拦截读写请求并返回 undefined:</code></pre>
<pre><code class="hljs javascript"><span class="hljs-keyword">let</span> api = &#123;  
    <span class="hljs-attr">_apiKey</span>: <span class="hljs-string">'123abc456def'</span>,
    <span class="hljs-attr">getUsers</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123; &#125;, 
    <span class="hljs-attr">getUser</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">userId</span>)</span>&#123; &#125;, 
    <span class="hljs-attr">setUser</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">userId, config</span>)</span>&#123; &#125;
&#125;;

<span class="hljs-keyword">const</span> RESTRICTED = [<span class="hljs-string">'_apiKey'</span>];
api = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(api, &#123;  
    <span class="hljs-keyword">get</span>(target, key, proxy) &#123;
        <span class="hljs-keyword">if</span>(RESTRICTED.indexOf(key) &gt; <span class="hljs-number">-1</span>) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span> is restricted. Please see api documentation for further info.`</span>);
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.get(target, key, proxy);
    &#125;,
    <span class="hljs-keyword">set</span>(target, key, value, proxy) &#123;
        <span class="hljs-keyword">if</span>(RESTRICTED.indexOf(key) &gt; <span class="hljs-number">-1</span>) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span> is restricted. Please see api documentation for further info.`</span>);
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.get(target, key, value, proxy);
    &#125;
&#125;);

<span class="hljs-comment">// 以下操作都会抛出错误</span>
<span class="hljs-built_in">console</span>.log(api._apiKey);
api._apiKey = <span class="hljs-string">'987654321'</span>;</code></pre>
<pre><code class="hljs markdown">第二种方法是使用 has 拦截 in 操作</code></pre>
<pre><code class="hljs javascript"><span class="hljs-keyword">var</span> api = &#123;  
    <span class="hljs-attr">_apiKey</span>: <span class="hljs-string">'123abc456def'</span>,
    <span class="hljs-attr">getUsers</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123; &#125;, 
    <span class="hljs-attr">getUser</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">userId</span>)</span>&#123; &#125;, 
    <span class="hljs-attr">setUser</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">userId, config</span>)</span>&#123; &#125;
&#125;;

<span class="hljs-keyword">const</span> RESTRICTED = [<span class="hljs-string">'_apiKey'</span>];
api = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(api, &#123;  
    has(target, key) &#123;
        <span class="hljs-keyword">return</span> (RESTRICTED.indexOf(key) &gt; <span class="hljs-number">-1</span>) ?
            <span class="hljs-literal">false</span> :
            <span class="hljs-built_in">Reflect</span>.has(target, key);
    &#125;
&#125;);

<span class="hljs-comment">// these log false, and `for in` iterators will ignore _apiKey</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"_apiKey"</span> <span class="hljs-keyword">in</span> api);

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> api) &#123;  
    <span class="hljs-keyword">if</span> (api.hasOwnProperty(key) &amp;&amp; key === <span class="hljs-string">"_apiKey"</span>) &#123;
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"This will never be logged because the proxy obscures _apiKey..."</span>)
    &#125;
&#125;</code></pre>
<h4 id="3-2-抽离校验模块">3.2 抽离校验模块<a class="post-anchor" href="#3-2-抽离校验模块"></a></h4><pre><code class="hljs markdown">让我们从一个简单的类型校验开始做起，
这个示例演示了如何使用 Proxy 保障数据类型的准确性</code></pre>
<pre><code class="hljs javascript"><span class="hljs-keyword">let</span> numericDataStore = &#123;  
    <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">amount</span>: <span class="hljs-number">1234</span>,
    <span class="hljs-attr">total</span>: <span class="hljs-number">14</span>
&#125;;

numericDataStore = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(numericDataStore, &#123;  
    <span class="hljs-keyword">set</span>(target, key, value, proxy) &#123;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value !== <span class="hljs-string">'number'</span>) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Properties in numericDataStore can only be numbers"</span>);
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.set(target, key, value, proxy);
    &#125;
&#125;);

<span class="hljs-comment">// 抛出错误，因为 "foo" 不是数值</span>
numericDataStore.count = <span class="hljs-string">"foo"</span>;

<span class="hljs-comment">// 赋值成功</span>
numericDataStore.count = <span class="hljs-number">333</span>;</code></pre>
<pre><code class="hljs markdown">如果要直接为对象的所有属性开发一个校验器可能很快就会让代码结构变得臃肿，
使用 Proxy 则可以将校验器从核心逻辑分离出来自成一体</code></pre>
<pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createValidator</span>(<span class="hljs-params">target, validator</span>) </span>&#123;  
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, &#123;
        <span class="hljs-attr">_validator</span>: validator,
        <span class="hljs-keyword">set</span>(target, key, value, proxy) &#123;
            <span class="hljs-keyword">if</span> (target.hasOwnProperty(key)) &#123;
                <span class="hljs-keyword">let</span> validator = <span class="hljs-keyword">this</span>._validator[key];
                <span class="hljs-keyword">if</span> (!!validator(value)) &#123;
                    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.set(target, key, value, proxy);
                &#125; <span class="hljs-keyword">else</span> &#123;
                    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Cannot set <span class="hljs-subst">$&#123;key&#125;</span> to <span class="hljs-subst">$&#123;value&#125;</span>. Invalid.`</span>);
                &#125;
            &#125; <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span> is not a valid property`</span>)
            &#125;
        &#125;
    &#125;);
&#125;

<span class="hljs-keyword">const</span> personValidators = &#123;  
    name(val) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> val === <span class="hljs-string">'string'</span>;
    &#125;,
    age(val) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> age === <span class="hljs-string">'number'</span> &amp;&amp; age &gt; <span class="hljs-number">18</span>;
    &#125;
&#125;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;  
    <span class="hljs-keyword">constructor</span>(name, age) &#123;
        <span class="hljs-keyword">this</span>.name = name;
        <span class="hljs-keyword">this</span>.age = age;
        <span class="hljs-keyword">return</span> createValidator(<span class="hljs-keyword">this</span>, personValidators);
    &#125;
&#125;

<span class="hljs-keyword">const</span> bill = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">'Bill'</span>, <span class="hljs-number">25</span>);

<span class="hljs-comment">// 以下操作都会报错</span>
bill.name = <span class="hljs-number">0</span>;  
bill.age = <span class="hljs-string">'Bill'</span>;  
bill.age = <span class="hljs-number">15</span>;</code></pre>
<pre><code class="hljs markdown">通过校验器和主逻辑的分离，你可以无限扩展 personValidators 校验器的内容，
而不会对相关的类或函数造成直接破坏。
更复杂一点，我们还可以使用 Proxy 模拟类型检查，
检查函数是否接收了类型和数量都正确的参数</code></pre>
<pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;  
    <span class="hljs-attr">pickyMethodOne</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">obj, str, num</span>) </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;,
    <span class="hljs-attr">pickyMethodTwo</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">num, obj</span>) </span>&#123; <span class="hljs-comment">/*... */</span> &#125;
&#125;;

<span class="hljs-keyword">const</span> argTypes = &#123;  
    <span class="hljs-attr">pickyMethodOne</span>: [<span class="hljs-string">"object"</span>, <span class="hljs-string">"string"</span>, <span class="hljs-string">"number"</span>],
    <span class="hljs-attr">pickyMethodTwo</span>: [<span class="hljs-string">"number"</span>, <span class="hljs-string">"object"</span>]
&#125;;

obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(obj, &#123;  
    <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">target, key, proxy</span>) </span>&#123;
        <span class="hljs-keyword">var</span> value = target[key];
        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) </span>&#123;
            <span class="hljs-keyword">var</span> checkArgs = argChecker(key, args, argTypes[key]);
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.apply(value, target, args);
        &#125;;
    &#125;
&#125;);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">argChecker</span>(<span class="hljs-params">name, args, checkers</span>) </span>&#123;  
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> idx = <span class="hljs-number">0</span>; idx &lt; args.length; idx++) &#123;
        <span class="hljs-keyword">var</span> arg = args[idx];
        <span class="hljs-keyword">var</span> type = checkers[idx];
        <span class="hljs-keyword">if</span> (!arg || <span class="hljs-keyword">typeof</span> arg !== type) &#123;
            <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">`You are incorrectly implementing the signature of <span class="hljs-subst">$&#123;name&#125;</span>. Check param <span class="hljs-subst">$&#123;idx + <span class="hljs-number">1</span>&#125;</span>`</span>);
        &#125;
    &#125;
&#125;

obj.pickyMethodOne();  
<span class="hljs-comment">// &gt; You are incorrectly implementing the signature of pickyMethodOne. Check param 1</span>
<span class="hljs-comment">// &gt; You are incorrectly implementing the signature of pickyMethodOne. Check param 2</span>
<span class="hljs-comment">// &gt; You are incorrectly implementing the signature of pickyMethodOne. Check param 3</span>

obj.pickyMethodTwo(<span class="hljs-string">"wopdopadoo"</span>, &#123;&#125;);  
<span class="hljs-comment">// &gt; You are incorrectly implementing the signature of pickyMethodTwo. Check param 1</span>

<span class="hljs-comment">// No warnings logged</span>
obj.pickyMethodOne(&#123;&#125;, <span class="hljs-string">"a little string"</span>, <span class="hljs-number">123</span>);  
obj.pickyMethodOne(<span class="hljs-number">123</span>, &#123;&#125;);</code></pre>
<h4 id="3-3-访问日志">3.3 访问日志<a class="post-anchor" href="#3-3-访问日志"></a></h4><pre><code class="hljs markdown">对于那些调用频繁、运行缓慢或占用执行环境资源较多的属性或接口，
开发者会希望记录它们的使用情况或性能表现，
这个时候就可以使用 Proxy 充当中间件的角色，轻而易举实现日志功能</code></pre>
<pre><code class="hljs javascript"><span class="hljs-keyword">let</span> api = &#123;  
    <span class="hljs-attr">_apiKey</span>: <span class="hljs-string">'123abc456def'</span>,
    <span class="hljs-attr">getUsers</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;,
    <span class="hljs-attr">getUser</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">userId</span>) </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;,
    <span class="hljs-attr">setUser</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">userId, config</span>) </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;
&#125;;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logMethodAsync</span>(<span class="hljs-params">timestamp, method</span>) </span>&#123;  
    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;timestamp&#125;</span> - Logging <span class="hljs-subst">$&#123;method&#125;</span> request asynchronously.`</span>);
    &#125;, <span class="hljs-number">0</span>)
&#125;

api = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(api, &#123;  
    <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">target, key, proxy</span>) </span>&#123;
        <span class="hljs-keyword">var</span> value = target[key];
        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...arguments</span>) </span>&#123;
            logMethodAsync(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(), key);
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.apply(value, target, <span class="hljs-built_in">arguments</span>);
        &#125;;
    &#125;
&#125;);

api.getUsers();</code></pre>
<h4 id="3-4-预警和拦截">3.4 预警和拦截<a class="post-anchor" href="#3-4-预警和拦截"></a></h4><pre><code class="hljs markdown">假设你不想让其他开发者删除 noDelete 属性，
还想让调用 oldMethod 的开发者了解到这个方法已经被废弃了，
或者告诉开发者不要修改 doNotChange 属性，那么就可以使用 Proxy 来实现</code></pre>
<pre><code class="hljs javascript"><span class="hljs-keyword">let</span> dataStore = &#123;  
    <span class="hljs-attr">noDelete</span>: <span class="hljs-number">1235</span>,
    <span class="hljs-attr">oldMethod</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-comment">/*...*/</span> &#125;,
    <span class="hljs-attr">doNotChange</span>: <span class="hljs-string">"tried and true"</span>
&#125;;

<span class="hljs-keyword">const</span> NODELETE = [<span class="hljs-string">'noDelete'</span>];  
<span class="hljs-keyword">const</span> NOCHANGE = [<span class="hljs-string">'doNotChange'</span>];
<span class="hljs-keyword">const</span> DEPRECATED = [<span class="hljs-string">'oldMethod'</span>];  

dataStore = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(dataStore, &#123;  
    <span class="hljs-keyword">set</span>(target, key, value, proxy) &#123;
        <span class="hljs-keyword">if</span> (NOCHANGE.includes(key)) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Error! <span class="hljs-subst">$&#123;key&#125;</span> is immutable.`</span>);
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.set(target, key, value, proxy);
    &#125;,
    deleteProperty(target, key) &#123;
        <span class="hljs-keyword">if</span> (NODELETE.includes(key)) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Error! <span class="hljs-subst">$&#123;key&#125;</span> cannot be deleted.`</span>);
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.deleteProperty(target, key);

    &#125;,
    <span class="hljs-keyword">get</span>(target, key, proxy) &#123;
        <span class="hljs-keyword">if</span> (DEPRECATED.includes(key)) &#123;
            <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">`Warning! <span class="hljs-subst">$&#123;key&#125;</span> is deprecated.`</span>);
        &#125;
        <span class="hljs-keyword">var</span> val = target[key];

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> val === <span class="hljs-string">'function'</span> ?
            <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) </span>&#123;
                <span class="hljs-built_in">Reflect</span>.apply(target[key], target, args);
            &#125; :
            val;
    &#125;
&#125;);

<span class="hljs-comment">// these will throw errors or log warnings, respectively</span>
dataStore.doNotChange = <span class="hljs-string">"foo"</span>;  
<span class="hljs-keyword">delete</span> dataStore.noDelete;  
dataStore.oldMethod();</code></pre>
<h4 id="3-5-过滤操作">3.5 过滤操作<a class="post-anchor" href="#3-5-过滤操作"></a></h4><pre><code class="hljs markdown">某些操作会非常占用资源，比如传输大文件，这个时候如果文件已经在分块发送了，
就不需要在对新的请求作出相应（非绝对），这个时候就可以使用 Proxy 对当请求进行特征检测，并根据特征过滤出哪些是不需要响应的，哪些是需要响应的。
下面的代码简单演示了过滤特征的方式，并不是完整代码，相信大家会理解其中的妙处</code></pre>
<pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;  
    <span class="hljs-attr">getGiantFile</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fileId</span>) </span>&#123;<span class="hljs-comment">/*...*/</span> &#125;
&#125;;

obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(obj, &#123;  
    <span class="hljs-keyword">get</span>(target, key, proxy) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) </span>&#123;
            <span class="hljs-keyword">const</span> id = args[<span class="hljs-number">0</span>];
            <span class="hljs-keyword">let</span> isEnroute = checkEnroute(id);
            <span class="hljs-keyword">let</span> isDownloading = checkStatus(id);      
            <span class="hljs-keyword">let</span> cached = getCached(id);

            <span class="hljs-keyword">if</span> (isEnroute || isDownloading) &#123;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            &#125;
            <span class="hljs-keyword">if</span> (cached) &#123;
                <span class="hljs-keyword">return</span> cached;
            &#125;
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.apply(target[key], target, args);
        &#125;
    &#125;
&#125;);</code></pre>
<h4 id="3-6-中断代理">3.6 中断代理<a class="post-anchor" href="#3-6-中断代理"></a></h4><pre><code class="hljs markdown">Proxy 支持随时取消对 target 的代理，这一操作常用于完全封闭对数据或接口的访问。
在下面的示例中，我们使用了 Proxy.revocable 方法创建了可撤销代理的代理对象：</code></pre>
<pre><code class="hljs javascript"><span class="hljs-keyword">let</span> sensitiveData = &#123; <span class="hljs-attr">username</span>: <span class="hljs-string">'devbryce'</span> &#125;;
<span class="hljs-keyword">const</span> &#123;sensitiveData, revokeAccess&#125; = <span class="hljs-built_in">Proxy</span>.revocable(sensitiveData, handler);
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleSuspectedHack</span>(<span class="hljs-params"></span>)</span>&#123;  
    revokeAccess();
&#125;

<span class="hljs-comment">// logs 'devbryce'</span>
<span class="hljs-built_in">console</span>.log(sensitiveData.username);
handleSuspectedHack();
<span class="hljs-comment">// TypeError: Revoked</span>
<span class="hljs-built_in">console</span>.log(sensitiveData.username);</code></pre>
</li>
</ul>


  
    <div class="post-reward">
    <div id="reward-button">打赏</div>
      <div id="qr">
        <div class="wrap">
            
            <div class="bg-wrap">
              <a href="/images/zhifubao.png" target="_block" class="bg" style="background-image:url('/images/zhifubao.png')"></a>
              支付宝
            </div>
            
            
            <div class="bg-wrap">
                <a href="/images/weixin.png" target="_block" class="bg" style="background-image:url('/images/weixin.png')"></a>
              微信
            </div>
            
        </div>
      </div>
    </div>
  
  <div class="post-guide">
    <div class="item left">
        
          <a href="/2020/10/15/vue%E7%9A%84is%E5%B1%9E%E6%80%A7/">vue的is属性</a>
        
    </div>
    <div class="item right">
        
          <a href="/2020/10/13/js%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/">js深拷贝和浅拷贝</a>
        
    </div>
  </div>

  

  <div class="post-copyright">
    <div class="auth">
      本文作者：<a href="https://codermino.github.io">Mino</a>
    </div>
    <div class="link">
      永久链接：<a href="https://codermino.github.io/2020/10/14/proxy笔记/">https://codermino.github.io/2020/10/14/proxy笔记/</a>
    </div>
    <div class="declare">
      版权声明：本文首发于<a href="https://codermino.github.io">Mino</a>的博客，转载请注明出处！
    </div>
  </div>

  <div id="comment"></div>

  
  
</article>
        <footer>
          <div class="copyright">
            ©2022
            <a href="https://codermino.github.io">Mino</a> Powered by <a href="https://hexo.io" target="_blank" rel="noopener">Mino</a> |
<!--            <a href="https://github.com/shixiaohu2206/hexo-theme-huhu" target="_blank" rel="noopener">hexo-theme-huhu</a>-->
          </div>
          
        </footer>
      </div>
    </div>
  </body>
  
</html>
<script type="text/javascript">
                  window.HUHU_CONFIG = JSON.parse("{\"share\":[\"weibo\",\"weixin\",\"qqkongjian\",\"QQ\",\"douban\",\"facebook\",\"twitter\",\"google\"],\"service_worker\":{\"open\":false}}")
                </script> <script type="text/javascript">window.addEventListener('load', function() {
    
    window.loadJs = function(d, m, a) {
      var c = document.getElementsByTagName('head')[0] || document.head || document.documentElement
      var b = document.createElement('script')
      b.defer = true
      b.setAttribute('type', 'text/javascript')
      b.setAttribute('charset', 'UTF-8')
      b.setAttribute('async', 'true')
      b.setAttribute('src', d)
      m && b.setAttribute('data-main', '/scripts/app-built')
      if (typeof a === 'function') {
        if (window.attachEvent) {
          b.onreadystatechange = function() {
            var e = b.readyState
            if (e === 'loaded' || e === 'complete') {
              b.onreadystatechange = null
              a()
            }
          }
        } else {
          b.onload = a
        }
      }
      c.appendChild(b)
    }
    window.loadJs && window.loadJs('https://cdn.bootcss.com/require.js/2.3.6/require.min.js', true, function() {require.config({"paths":{"util":"util","share":"share","search":"search","registerSW":"registerSW","valine":"cdn/Valine.min","av":["https://cdn.jsdelivr.net/npm/leancloud-storage/dist/av-min"],"pjax":["https://cdn.bootcss.com/jquery.pjax/2.0.1/jquery.pjax.min"],"jquery":["https://cdn.bootcss.com/jquery/3.4.1/jquery.min"],"confirm":["https://cdn.bootcss.com/jquery-confirm/3.3.4/jquery-confirm.min"],"fancybox":["https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min"],"chart":["https://cdn.bootcss.com/Chart.js/2.8.0-rc.1/Chart.bundle.min"]},"map":{"*":{"css":"https://cdn.bootcss.com/require-css/0.1.10/css.min.js"}},"shim":{"fancybox":{"deps":["css!https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min.css"]},"confirm":{"deps":["css!https://cdn.bootcss.com/jquery-confirm/3.3.4/jquery-confirm.min.css"]},"chart":{"deps":["css!https://cdn.bootcss.com/Chart.js/2.8.0-rc.1/Chart.min.css"]}},"waitSeconds":3})})
  })</script> <script type="text/javascript">
                  ;(function() {
                    var bp = document.createElement('script')
                    var curProtocol = window.location.protocol.split(':')[0]
                    if (curProtocol === 'https') {
                      bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'
                    } else {
                      bp.src = 'http://push.zhanzhang.baidu.com/push.js'
                    }
                    var s = document.getElementsByTagName('script')[0]
                    s.parentNode.insertBefore(bp, s)
                  })()
                </script> 
