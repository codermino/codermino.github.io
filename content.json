{"meta":{"title":"Mino","subtitle":"Mino's personal blog","description":"Mino's personal blog","author":"Mino","url":"https://codermino.github.io","root":"/"},"posts":[{"tags":[{"name":"vue单页面应用过渡动画","slug":"vue单页面应用过渡动画","permalink":"https://codermino.github.io/tags/vue%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB/"}],"title":"vue单页面应用过渡动画","date":"2020/12/15","text":"router配置&#123; path: &#39;&#x2F;&#39;, meta:&#123; title:&#39;vuex练习&#39; &#125;, component: () &#x3D;&gt; import(&#x2F;* webpackChunkName: &quot;about&quot; *&#x2F; &#39;..&#x2F;views&#x2F;layoutprac.vue&#39;), children:[ &#123; path: &#39;&#39;, name: &#39;About&#39;, meta:&#123; title:&#39;省市联动&#39;, index:0 &#125;, component: () &#x3D;&gt; import(&#x2F;* webpackChunkName: &quot;about&quot; *&#x2F; &#39;..&#x2F;views&#x2F;About.vue&#39;) &#125;, &#123; path: &#39;&#x2F;vueprc&#39;, name: &#39;vueprc&#39;, meta:&#123; title:&#39;vuex练习&#39;, index:1 &#125;, component: () &#x3D;&gt; import(&#x2F;* webpackChunkName: &quot;about&quot; *&#x2F; &#39;..&#x2F;views&#x2F;vuexprc.vue&#39;) &#125;, &#123; path: &#39;&#x2F;routerQuery&#39;, name: &#39;routerQuery&#39;, meta:&#123; title:&#39;路由传参&#39;, index:2 &#125;, component: () &#x3D;&gt; import(&#x2F;* webpackChunkName: &quot;about&quot; *&#x2F; &#39;..&#x2F;views&#x2F;routeQuery.vue&#39;) &#125;, &#123; path: &#39;&#x2F;table&#39;, name: &#39;tableprac&#39;, meta:&#123; title:&#39;表格&#39;, index:3 &#125;, component: () &#x3D;&gt; import(&#x2F;* webpackChunkName: &quot;about&quot; *&#x2F; &#39;..&#x2F;views&#x2F;tableprac.vue&#39;) &#125;, &#123; path: &#39;&#x2F;userInfo&#39;, name: &#39;userInfo&#39;, meta:&#123; title:&#39;个人信息&#39;, index:4 &#125;, component: () &#x3D;&gt; import(&#x2F;* webpackChunkName: &quot;about&quot; *&#x2F; &#39;..&#x2F;views&#x2F;userInfo.vue&#39;) &#125;, &#123; path: &#39;&#x2F;table2&#39;, name: &#39;table2&#39;, meta:&#123; title:&#39;表格2&#39;, index:5 &#125;, component: () &#x3D;&gt; import(&#x2F;* webpackChunkName: &quot;about&quot; *&#x2F; &#39;..&#x2F;views&#x2F;table.vue&#39;) &#125; ] &#125; Demo1(使用animate.css)引入 @import &#39;.&#x2F;css&#x2F;animate.css&#39;; 使用 &lt;transition name&#x3D;&quot;page&quot; mode&#x3D;&quot;out-in&quot; enter-active-class&#x3D;&quot;animated fadeIn&quot; leave-active-class&#x3D;&quot;animated fadeOut&quot; &gt; &lt;router-view&gt;&lt;&#x2F;router-view&gt; &lt;&#x2F;transition&gt; Demo2(使用原生js)html部分 &lt;transition name&#x3D;&quot;fade&quot;&gt; &lt;router-view&gt;&lt;&#x2F;router-view&gt; &lt;&#x2F;transition&gt; css部分 .fade-enter, .fade-leave-to&#123; visibility: hidden; opacity: 0; &#125; .fade-leave-to&#123; display: none; &#125; .fade-enter-active, .fade-leave-active&#123; transition: all .3s ease; &#125; .fade-enter-to, .fade-leave&#123; visibility: visible; opacity: 1; &#125; mode 的默认行为 - 进入和离开同时发生。同时生效的进入和离开的过渡不能满足所有要求，所以 Vue 提供了过渡模式 in-out：新元素先进行过渡，完成之后当前元素过渡离开。 out-in：当前元素先进行过渡，完成之后新元素过渡进入。","permalink":"https://codermino.github.io/2020/12/15/vue%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB/","photos":[]},{"tags":[{"name":"BFC","slug":"BFC","permalink":"https://codermino.github.io/tags/BFC/"}],"title":"BFC","date":"2020/12/14","text":"BFC定义BFC(Block formatting context)直译为\"块级格式化上下文\"。 它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。 Box:css布局的基本单位Box 是 CSS 布局的对象和基本单位，直观点来说，就是一个页面是由很多个 Box 组成的。元素的类型和 display 属性，决定了这个 Box 的类型。不同类型的 Box，会参与不同的 Formatting Context(一个决定如何渲染文档的容器)因此Box内的元素会以不同的方式渲染。让我们看看有哪些盒子： block-level box:display 属性为 block, list-item, table 的元素，会生成 block-level box。 并且参与 block fomatting context； inline-level box:display 属性为 inline, inline-block, inline-table 的元素， 会生成 inline-level box。并且参与 inline formatting context； run-in box: css3 中才有. Formatting ContextFormatting context 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。最常见的 Formatting context 有 Block fomatting context (简称BFC)和 Inline formatting context (简称IFC)。 BFC是一个独立的布局环境，其中的元素布局是不受外界的影响，并且在一个BFC中， 块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列。 BFC的布局规则 内部的Box会在垂直方向，一个接一个地放置。 Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠。 每个盒子（块盒与行盒）的margin box的左边，与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。 BFC的区域不会与float box重叠。 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 计算BFC的高度时，浮动元素也参与计算。 如何创建BFC float的值不是none。 position的值不是static或者relative。 display的值是inline-block、table-cell、flex、table-caption或者inline-flex overflow的值不是visible BFC的作用 利用BFC避免margin重叠。 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;防止margin重叠&lt;/title&gt; &lt;/head&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; p &#123; color: #f55; background: yellow; width: 200px; line-height: 100px; text-align:center; margin: 30px; &#125; &lt;/style&gt; &lt;body&gt; &lt;p&gt;看看我的 margin是多少&lt;/p&gt; &lt;p&gt;看看我的 margin是多少&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 根据第二条，属于同一个BFC的两个相邻的Box会发生margin重叠，所以我们可以设置，两个不同的BFC，也就是我们可以让把第二个p用div包起来，然后激活它使其成为一个BFC &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;防止margin重叠&lt;/title&gt; &lt;/head&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; p &#123; color: #f55; background: yellow; width: 200px; line-height: 100px; text-align:center; margin: 30px; &#125; div&#123; overflow: hidden; &#125; &lt;/style&gt; &lt;body&gt; &lt;p&gt;看看我的 margin是多少&lt;/p&gt; &lt;div&gt; &lt;p&gt;看看我的 margin是多少&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 自适应两栏布局每个盒子的margin box的左边，与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; body &#123; width: 100%; position: relative; &#125; .left &#123; width: 100px; height: 150px; float: left; background: rgb(139, 214, 78); text-align: center; line-height: 150px; font-size: 20px; &#125; .right &#123; height: 300px; background: rgb(170, 54, 236); text-align: center; line-height: 300px; font-size: 40px; &#125; &lt;/style&gt; &lt;body&gt; &lt;div class=\"left\"&gt;LEFT&lt;/div&gt; &lt;div class=\"right\"&gt;RIGHT&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; BFC的区域不会与float box重叠。所以我们让right单独成为一个BFC &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; body &#123; width: 100%; position: relative; &#125; .left &#123; width: 100px; height: 150px; float: left; background: rgb(139, 214, 78); text-align: center; line-height: 150px; font-size: 20px; &#125; .right &#123; overflow: hidden; height: 300px; background: rgb(170, 54, 236); text-align: center; line-height: 300px; font-size: 40px; &#125; &lt;/style&gt; &lt;body&gt; &lt;div class=\"left\"&gt;LEFT&lt;/div&gt; &lt;div class=\"right\"&gt;RIGHT&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; right会自动的适应宽度，这时候就形成了一个两栏自适应的布局。 清除浮动。当我们不给父节点设置高度，子节点设置浮动的时候，会发生高度塌陷，这个时候我们就要清楚浮动。 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;清除浮动&lt;/title&gt; &lt;/head&gt; &lt;style&gt; .par &#123; border: 5px solid rgb(91, 243, 30); width: 300px; &#125; .child &#123; border: 5px solid rgb(233, 250, 84); width:100px; height: 100px; float: left; &#125; &lt;/style&gt; &lt;body&gt; &lt;div class=\"par\"&gt; &lt;div class=\"child\"&gt;&lt;/div&gt; &lt;div class=\"child\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 给父节点激活BFC &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;清除浮动&lt;/title&gt; &lt;/head&gt; &lt;style&gt; .par &#123; border: 5px solid rgb(91, 243, 30); width: 300px; overflow: hidden; &#125; .child &#123; border: 5px solid rgb(233, 250, 84); width:100px; height: 100px; float: left; &#125; &lt;/style&gt; &lt;body&gt; &lt;div class=\"par\"&gt; &lt;div class=\"child\"&gt;&lt;/div&gt; &lt;div class=\"child\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 总结BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。因为BFC内部的元素和外部的元素绝对不会互相影响，因此， 当BFC外部存在浮动时，它不应该影响BFC内部Box的布局，BFC会通过变窄，而不与浮动有重叠。同样的，当BFC内部有浮动时，为了不影响外部元素的布局，BFC计算高度时会包括浮动的高度。避免margin重叠也是这样的一个道理。 反正就是一个div内部的东西不管怎么变化都不会影响外面的元素，反之也不会被外面影响，完全独立","permalink":"https://codermino.github.io/2020/12/14/BFC/","photos":[]},{"tags":[{"name":"==和===的使用场景","slug":"和-的使用场景","permalink":"https://codermino.github.io/tags/%E5%92%8C-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"}],"title":"==和===的使用场景","date":"2020/12/14","text":"首先, == 隐含意思是尽量让等号两边转换后相等, 也就是发生类型转换; 绝大多数场合应该使用===，只有检测null/undefined的时候可以使用x==null，因为一般我们不区分null和undefined，即将x=null作为x===null || x===undefined的缩写。 ==的比较看似比较方便，比如1==‘1’，但是会埋下隐患，引入隐蔽的错误，最常见的就是让字符串和数值相加会先将数值转化为字符串，然后进行字符串连接，例如 if(x==10)&#123; x+=5； ... &#125; 如果传入参数为‘10’的话，x的结果会变成‘105’，可能会引入隐蔽的错误。","permalink":"https://codermino.github.io/2020/12/14/%E5%92%8C-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/","photos":[]},{"tags":[{"name":"meta标签用法","slug":"meta标签用法","permalink":"https://codermino.github.io/tags/meta%E6%A0%87%E7%AD%BE%E7%94%A8%E6%B3%95/"}],"title":"meta标签用法","date":"2020/12/14","text":"定义和用法 标签始终位于 head 元素中。 元素可提供有关页面的元信息（meta-information）， 元数据不会显示在页面上，但是对于机器是可读的。比如针对搜索引擎和更新频度的描述和关键词。 元数据（metadata）是关于数据的信息。元数据总是以名称/值的形式被成对传递的。 典型的情况是，meta 元素被用于规定页面的描述、关键词、文档的作者、最后修改时间以及其他元数据。 元数据可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。 必需的属性 属性 值 描述 content some_text 定义与 http-equiv 或 name 属性相关的元信息/ 可选的属性 属性 值 描述 http-equiv content-type expires refresh set-cookie 把 content 属性关联到 HTTP 头部。/ name author description keywords generator revised others 把 content 属性关联到一个名称。/ scheme some_text 定义用于翻译 content 属性值的格式。/ 注意当有http-equiv或者name属性时，必须要有content属性，content 属性提供了名称/值对中的值，content属性定义与 http-equiv 或 name 属性相关的元信息。content始终要和 name 属性或 http-equiv 属性一起使用 http-equiv 属性 http-equiv 属性为名称/值对提供了名称。 并指示服务器在发送实际的文档之前先在要传送给浏览器的 MIME 文档头部包含名称/值对。 http-equiv属性是添加http头部内容，对一些自定义的，或者需要额外添加的http头部内容， 需要发送到浏览器中，我们就可以是使用这个属性。 使用带有 http-equiv 属性的 标签时，服务器将把名称/值对添加到发送给浏览器的内容头部。1、content-Type(显示字符集的设定)：设定页面使用的字符集。 用法：&lt;meta http-equiv=\"content-Type\" content=\"text/html;charset=utf-8\"&gt; 注意：charset是声明文档使用的字符编码，解决乱码问题主要用的就是它， charset一定要写第一行，不然就可能会产生乱码了。 &lt;meta charset=\"utf-8\"&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"&gt; 两个都是等效的。 使用带有 http-equiv 属性的 &lt;meta&gt; 标签时，服务器将把名称/值对添加到发送给浏览器的内容头部。例如，添加： &lt;meta http-equiv=\"charset\" content=\"iso-8859-1\"&gt; &lt;meta http-equiv=\"expires\" content=\"31 Dec 2008\"&gt; 这样发送到浏览器的头部就应该包含： content-type: text/html charset:iso-8859-1 expires:31 Dec 2008 2、Expires(期限)：可以用于设定网页的到期时间。一旦网页过期，必须到服务器上重新传输。 用法： &lt;meta http-equiv=\"expires\" content=\"Fri,12Jan200118:18:18GMT\"&gt; 注意：必须使用GMT的时间格式。 3、Refresh(刷新)：自动刷新并指向新页面。 用法： &lt;meta http-equiv=\"Refresh\" content=\"2; URL=http://www.baidu.com\"&gt; (注意后面的引号，分别在秒数的前面和网址的后面) 注意：其中的2是指停留2秒钟后自动刷新到URL网址。 4、Set-Cookie(cookie设定)：如果网页过期，那么存盘的cookie将被删除。 用法： &lt;meta http-equiv=\"Set-Cookie\" content=\"cookie value=xxx; expires=Friday,12-Jan-200118:18:18GMT；path=/\"&gt; 注意：必须使用GMT的时间格式。 name属性 name 属性提供了名称/值对中的名称。 通常情况下，您可以自由使用对自己和源文档的读者来说富有意义的名称。 如果没有提供 name 属性，那么名称/值对中的名称会采用 http-equiv 属性的值。分成两部分：一个是SEO部分（搜索引擎优化） 1、Keywords(关键字)：keywords用来告诉搜索引擎你网页的关键字是什么。 举例： &lt;meta name=\"keywords\" content=\"xxxx\"&gt; 2、description(网站内容描述)：description用来告诉搜索引擎你的网站主要内容。 举例： &lt;meta name=\"description\" content=\"xxx\"&gt; 3、author(作者)：标注网页的作者 举例： &lt;meta name=\"author\" content=\"github.com/lihuijuan\"&gt; 另一部分是viewport viewport：主要是影响移动端页面布局的 举例： &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; content 有参数： width viewport 宽度(数值/device-width)；height viewport 高度(数值/device-height)； initial-scale 初始缩放比例；maximum-scale 最大缩放比例； minimum-scale 最小缩放比例；user-scalable 是否允许用户缩放(yes/no) meta的charset各个字符编码含义： gb2312：代表国家标准第2312条，其中是不包含繁体的（虽然咱们不怎么使用繁体了，但是台湾还在使用繁体啊。那怎么办呢？）。 gbk：国家标准扩展版（增加了繁体，包含所有亚洲字符集）。 unicode：万国码（字面意思你也懂的）。 世界通用的语言编码 utf-8：unicode的升级版。charset=utf-8这个编码可以用到中文、韩文、日文等世界上所有语言编码上。","permalink":"https://codermino.github.io/2020/12/14/meta%E6%A0%87%E7%AD%BE%E7%94%A8%E6%B3%95/","photos":[]},{"tags":[{"name":"js将多维数组转为一维数组","slug":"js将多维数组转为一维数组","permalink":"https://codermino.github.io/tags/js%E5%B0%86%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E8%BD%AC%E4%B8%BA%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84/"}],"title":"js将多维数组转为一维数组","date":"2020/12/07","text":"将多维数组转为一维数组 常用的处理方式 let arr1 = [1,2,[3,[4]]]; let arr2 = arr1.toString().split(','); // [\"1\", \"2\", \"3\", \"4\"] let arr3 = arr1.join().split(','); // [\"1\", \"2\", \"3\", \"4\"] console.log(arr2,arr3) 上述代码缺点：数组每一项都成字符串了。 apply结合concat拉平数组 let arr=[[1,2,3],[4,5],[6]]; console.log([].concat.apply([],arr)); //输出 [1, 2, 3, 4, 5, 6] 数组map()方法 **对上述转为字符串数组进行再一次的处理 let arr2_dealWith = arr2.map(item =&gt; Number(item)) console.log(arr2_dealWith) // [1, 2, 3, 4] let arr3_detailWith = arr3.map(item =&gt; Number(item)) console.log(arr3_detailWith) // [1, 2, 3, 4] // 或者直接这样使用 ['1','2','3'].map(Number) arr2.map(Number) ES6提供了flat()方法 该方法返回一个新数组，不会更改原数组。 该方法默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将flat()方法的参数写成一个整数，表示想要拉平的层数，默认为1。let array_1 = [1, 2, 3, [4, 5], 6]; let array_1_result = array_1.flat(); console.log(array_1_result); // [1, 2, 3, 4, 5, 6] 如果嵌套20、30等层，用参数就比较麻烦（数起来，当然这么多嵌套实际项目中是没有的）所以，提供了用Infinity关键字作为参数.此时不管有多少层嵌套，都可以转成一维数组。let array_3 = [1, 2, 3, [[4, [10]], 5], 6]; let array_3_result = array_3.flat(Infinity); console.log(array_3_result); // [1, 2, 3, 4, 10, 5, 6] 如果有空位，flat()方法会跳过空位,这样可以延伸出，flat()不仅能拉平数组，还能去除数组的空位这一能力。let vacancyArray = [1, 2, 3, , 4, , 6]; let vacancyArray_result = vacancyArray.flat(); console.log(vacancyArray_result); //[1, 2, 3, 4, 6] flatMap()方法对原数组的每个成员执行一个函数（相当于执行Array.prototype.map()），然后对返回值组成的数组执行flat()方法。该方法返回一个新数组，不改变原数组。// only one level is flattenedlet a = [1,2,3]; let res = a.flatMap((x) =&gt; [x, x * 2]) // 相当于 [[1, 2], [2, 4], [3, 6]].flat() console.log(res); // [1, 2, 2, 4, 3, 6] flatMap函数DemoDemo1 const scattered = [ \"my favorite\", \"hamburger\", \"is a\", \"chicken sandwich\" ]; // map() 返回的是嵌套的数组results in nested arrays const result = scattered.map( item =&gt; item.split( \" \" ) ); console.log( result ); // [ [ \"my\", \"favorite\" ], [ \"hamburger\" ], [ \"is\", \"a\" ], [ \"chicken\", \"sandwich\" ] ] const result = scattered.flatMap( item =&gt; item.split( \" \" ) ); console.log( result ); // [ \"my\", \"favorite\", \"hamburger\", \"is\", \"a\", \"chicken\", \"sandwich\" ] Demo2flatMap(callback, thisArg): 很像map方法的一个方法，第一个参数为回调函数，第二个参数为希望传入回调函数的并作为回调函数内部this参数书写的参数。 let arr = [10, 20, 30, 50, 40] let a = arr.flatMap(x =&gt; &#123; return [[x]] &#125;) console.log(a); // [[10], [20], [30], [50], [40]] 它和map方法不同的就是它可以为参数嵌套数组层数（维度）,且输入数组和输出数组并不是一对一的关系了，输入数组有n个成员，输出数组可以有不同于n个数量的成员。 let arr = [10, 20, 30, 50, 40] let a = arr.flatMap(x =&gt; &#123; return [[x], 10] &#125;) console.log(a); // [[10], 10, [20], 10, [30], 10, [50], 10, [40], 10] 递归处理 let ary = [1, [2, [3, [4, 5]]], 6]; let result = []; let fn = function(ary) &#123; for(let i = 0; i &lt; ary.length; i++) &#123; let item = ary[i]; if (Array.isArray(ary[i]))&#123; fn(item); &#125; else &#123; result.push(item); &#125; &#125; &#125; fn(ary) console.log(result) 使用es6的拓展运算符 let ary = [1, [2, [3, [4, 5]]], 6]; while (ary.some(Array.isArray)) &#123; ary = [].concat(...ary); &#125; console.log(ary)","permalink":"https://codermino.github.io/2020/12/07/js%E5%B0%86%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E8%BD%AC%E4%B8%BA%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84/","photos":[]},{"tags":[{"name":"vue自定义图片上传并传递formdata","slug":"vue自定义图片上传并传递formdata","permalink":"https://codermino.github.io/tags/vue%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%B9%B6%E4%BC%A0%E9%80%92formdata/"}],"title":"vue自定义图片上传并传递formdata","date":"2020/12/07","text":"使用element-ui组件&lt;div&gt; &lt;el-upload ref&#x3D;&quot;upload&quot; :auto-upload&#x3D;&quot;false&quot; :disabled&#x3D;&quot;$store.getters.user.identity_class &gt; 2&quot; :before-remove&#x3D;&quot;(file, fileList)&#x3D;&gt;beforeRemove(file,fileList,props.row.id)&quot; :class&#x3D;&quot;&#123;hide:hideUpload || $store.getters.user.identity_class &gt; 2&#125;&quot; multiple :file-list&#x3D;&quot;fileList&quot; :before-upload&#x3D;&quot;uploadProductPicBefore&quot; :data&#x3D;&quot;&#123;id:props.row.id&#125;&quot; :http-request&#x3D;&quot;uploadProductPic&quot; accept&#x3D;&quot;image&#x2F;jpeg,image&#x2F;gif,image&#x2F;png,image&#x2F;bmp,image&#x2F;jpg&quot; list-type&#x3D;&quot;picture-card&quot; :on-preview&#x3D;&quot;handleContImgPreview&quot; :limit&#x3D;&quot;5&quot; :on-exceed&#x3D;&quot;exceedTips&quot; action&#x3D;&quot;&quot;&gt; &lt;i slot&#x3D;&quot;default&quot; class&#x3D;&quot;el-icon-plus&quot;&gt;&lt;&#x2F;i&gt; &lt;&#x2F;el-upload&gt; &lt;el-dialog :visible.sync&#x3D;&quot;dialogVisible&quot;&gt; &lt;img width&#x3D;&quot;100%&quot; :src&#x3D;&quot;dialogImageUrl&quot; alt&#x3D;&quot;&quot;&gt; &lt;&#x2F;el-dialog&gt; &lt;&#x2F;div&gt; 主要函数 删除图片beforeRemove(file, fileList,_id) &#123; &#x2F;&#x2F; 在fileList中查询是否包含选择要删除的图片 const result &#x3D; this.fileList.some(item&#x3D;&gt;&#123; if(item.url&#x3D;&#x3D;&#x3D;file.url)&#123; return true; &#125; &#125;); if (result)&#123; this.isDialog &#x3D; true; &#125; &#x2F;&#x2F; 显示删除对话框，确认是否删除对应的图片 if (this.isDialog)&#123; this.$confirm(&#39;此操作将删除当前图片, 是否继续?&#39;, &#39;提示&#39;, &#123; confirmButtonText: &#39;确定&#39;, cancelButtonText: &#39;取消&#39;, type: &#39;warning&#39; &#125;).then(() &#x3D;&gt; &#123; this.delPic(file,fileList,_id) &#x2F;&#x2F; 在这里真正的处理图片列表 &#125;).catch(() &#x3D;&gt; &#123; this.$message(&#123; type: &#39;info&#39;, message: &#39;已取消删除&#39; &#125;); &#125;); return false; &#x2F;&#x2F; 这是重点,不管上面的操作结果如何都返回false &#125; &#125;, async delPic(file, fileList, _id) &#123; const file_split &#x3D; file.url.split(&#39;&#x2F;&#39;); const name &#x3D; file_split[file_split.length - 1]; &#x2F;&#x2F; 传递给后端的数据，后端进行图片删除 const result &#x3D; await this.axios.post(&#39;http:&#x2F;&#x2F;localhost:3000&#x2F;data&#x2F;delete_pic_f&#39;, &#123;_id, name&#125;); if (result.data.code &#x3D;&#x3D;&#x3D; 200)&#123; &#x2F;&#x2F; 前端的fileList过滤掉删除的图片 this.fileList &#x3D; this.fileList.filter((item, i) &#x3D;&gt; &#123; return item.url !&#x3D;&#x3D; file.url; &#125;); &#x2F;&#x2F; 重新获取列表数据 this.getList(); this.$message.success(result.data.data.msg); &#125; else&#123; this.$message.error(result.data.msg); &#125; &#125;, 上传图片&#x2F;&#x2F;内容图上传前的大小 格式的校验 uploadProductPicBefore(file) &#123; const fileType &#x3D; file.type; const is3M &#x3D; file.size &#x2F; 1024 &#x2F; 1024 &lt; 3; &#x2F;&#x2F; 限制小于3M let isJpg &#x3D; false; if (fileType &#x3D;&#x3D;&#x3D; &#39;image&#x2F;jpeg&#39; || fileType &#x3D;&#x3D;&#x3D; &#39;image&#x2F;png&#39; || fileType &#x3D;&#x3D;&#x3D; &#39;image&#x2F;gif&#39; || fileType &#x3D;&#x3D;&#x3D; &#39;image&#x2F;bmp&#39;) &#123; isJpg &#x3D; true; &#125; if (!isJpg) &#123; this.$message(&#123; message: &#39;上传的图标只能是jpg、png、gif、bmp格式!&#39;, type: &#39;warning&#39; &#125;); &#125; if (!is3M) &#123; this.$message(&#123; message: &#39;上传大小不能超过3M!&#39;, type: &#39;warning&#39; &#125;); &#125; this.isDialog &#x3D; isJpg &amp;&amp; is3M; return is3M &amp;&amp; isJpg; &#125; &#x2F;&#x2F;上传内容图 uploadProductPic: async function (file) &#123; const that &#x3D; this; const reader &#x3D; new FileReader(); if (file) &#123; reader.readAsDataURL(file.file) &#125; const id &#x3D; file.data.id; reader.onload &#x3D; function (e) &#123; const base64Code&#x3D;this.result; &#x2F;&#x2F; 进行压缩，传递参数为base64文件和callback函数 compress(base64Code, async (file) &#x3D;&gt; &#123; &#x2F;&#x2F; 创建一个FormData const formData &#x3D; new FormData(); &#x2F;&#x2F; 添加file属性，后台使用file字段进行接收 formData.append(&quot;file&quot;, file); &#x2F;&#x2F; 添加data属性，后台使用data字段进行接收 formData.append(&#39;data&#39;, id); &#x2F;&#x2F; 向后盾发起请求，并且将headers改为form-data const result &#x3D; await that.axios.post(&quot;http:&#x2F;&#x2F;localhost:3000&#x2F;data&#x2F;upload2&quot;, formData, &#123; headers: &#123;&quot;content-type&quot;: &quot;multipart&#x2F;form-data&quot;&#125;, &#125;); if (result.data.code &#x3D;&#x3D;&#x3D; 200)&#123; &#x2F;&#x2F; 上传成功之后将上传的文件路径，放在fileList中，进行展示 that.fileList.push(&#123;&#39;url&#39;:&#39;http:&#x2F;&#x2F;localhost:3000&#x2F;pic&#x2F;&#39;+result.data.data.uploadpic&#125;); &#x2F;&#x2F; that.fileList.splice(that.fileList.length, 1, &#123;&#39;url&#39;:&#39;http:&#x2F;&#x2F;localhost:3000&#x2F;pic&#x2F;&#39;+result.data.data.uploadpic&#125;); &#x2F;&#x2F; that.$set(that.fileList,that.fileList.length,&#123;&#39;url&#39;:&#39;http:&#x2F;&#x2F;localhost:3000&#x2F;pic&#x2F;&#39;+result.data.data.uploadpic&#125;); &#x2F;&#x2F; that.fileList.concat([&#123;&#39;url&#39;:&#39;http:&#x2F;&#x2F;localhost:3000&#x2F;pic&#x2F;&#39;+result.data.data.uploadpic&#125;]); that.$message.success(result.data.data.msg); &#x2F;&#x2F; that.$nextTick(()&#x3D;&gt;&#123; &#x2F;&#x2F; 重新获取列表数据 that.getList(); &#x2F;&#x2F; &#125;) &#125; else&#123; that.$message.error(result.data.msg); &#125; &#125;) &#125;; &#125;, 图片压缩js接收一个base64 // 压缩图片 function compress(base64,callback) &#123; const img = new Image(); img.src = base64; img.onload = () =&gt; &#123; const w = img.width; const h = img.height; const quality = 0.5; // 默认图片质量为0.92 // 生成canvas const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d'); // 创建属性节点 const anw = document.createAttribute(\"width\"); anw.nodeValue = w; const anh = document.createAttribute(\"height\"); anh.nodeValue = h; canvas.setAttributeNode(anw); canvas.setAttributeNode(anh); // 铺底色 PNG转JPEG时透明区域会变黑色 ctx.fillStyle = \"#fff\"; ctx.fillRect(0, 0, w, h); ctx.drawImage(img, 0, 0, w, h); // quality值越小，所绘制出的图像越模糊 const new_base64 = canvas.toDataURL('image/jpeg', quality); // 图片格式jpeg或webp可以选0-1质量区间 callback(convertBase64UrlToBlob(new_base64)); // callback(new_base64); // 返回base64转blob的值 // console.log(`原图$&#123;(base64.length / 1024).toFixed(2)&#125;kb`, `新图$&#123;(new_base64.length / 1024).toFixed(2)&#125;kb`); &#125; &#125; // 将base64的图片转换为file文件 function convertBase64UrlToBlob(urlData) &#123; let bytes = window.atob(urlData.split(\",\")[1]); //去掉url的头，并转换为byte //处理异常,将ascii码小于0的转换为大于0 let ab = new ArrayBuffer(bytes.length); let ia = new Uint8Array(ab); let type = urlData.split(\",\")[0].match(/:(.*?);/)[1]; for (let i = 0; i &lt; bytes.length; i++) &#123; ia[i] = bytes.charCodeAt(i); &#125; return new Blob([ab], &#123; type: type &#125;); &#125; export &#123;compress&#125; 内容图预览事件 &#x2F;&#x2F;内容图片预览事件 handleContImgPreview(file) &#123; this.dialogImageUrl &#x3D; file.url; this.dialogVisible &#x3D; true; &#125;, 内容图超过5张限制提示 //内容图数量限制5张 exceedTips: function () &#123; this.$message.error('最多只能上传五张图片') &#125;, fromDataFormData的主要用途有两个：1、将form表单元素的name与value进行组合，实现表单数据的序列化，从而减少表单元素的拼接，提高工作效率。2、异步上传文件(创建一个空对象,可以通过append()方法来追加数据)","permalink":"https://codermino.github.io/2020/12/07/vue%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%B9%B6%E4%BC%A0%E9%80%92formdata/","photos":[]},{"tags":[{"name":"vue文件上传转base64","slug":"vue文件上传转base64","permalink":"https://codermino.github.io/tags/vue%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E8%BD%ACbase64/"}],"title":"vue文件上传转base64","date":"2020/12/07","text":"上传页面&lt;template&gt; &lt;div class&#x3D;&quot;imageUpload&quot;&gt; &lt;el-upload class&#x3D;&quot;avatar-uploader&quot; action&#x3D;&quot;&quot; :accept&#x3D;&quot;this.acceptFile(&#39;file&#39;)&quot; ref&#x3D;&quot;uploadAvatar&quot; :show-file-list&#x3D;&quot;false&quot; :auto-upload&#x3D;&quot;false&quot; :on-change&#x3D;&quot;changeFile&quot;&gt; &lt;i class&#x3D;&quot;el-icon-plus avatar-uploader-icon&quot;&gt;&lt;&#x2F;i&gt; &lt;&#x2F;el-upload&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; import acceptFileType from &#39;..&#x2F;util&#x2F;acceptFileType&#39; export default &#123; name: &quot;imageUpload&quot;, data() &#123; return &#123; acceptTypeList: [] &#125; &#125;, methods: &#123; acceptFile(type)&#123; this.acceptTypeList &#x3D; acceptFileType(type) return this.acceptTypeList &#125;, changeFile(file, fileList) &#123; console.log(file.raw) const fileName &#x3D; file.name; const m &#x3D; fileName.match(&#x2F;\\.(\\w+)(#|\\?|$)&#x2F;); const fileType &#x3D; (m &amp;&amp; m[1]).toString().toLowerCase(); if (!this.acceptTypeList.includes(fileType))&#123; this.$message.info(&#39;上传的文件格式不对!&#39;); return; &#125; const isLt5M &#x3D; file.size &#x2F; 1024 &#x2F; 1024 &lt; 5; if (!isLt5M) &#123; this.$message.info(&#39;上传头像图片大小不能超过 5MB!&#39;); return; &#125; let This &#x3D; this; let reader &#x3D; new FileReader(); reader.readAsDataURL(file.raw); &#x2F;&#x2F;开始转 reader.onload &#x3D; function(e)&#123; this.result; &#x2F;&#x2F;base64编码 console.log(this.result) console.log(e.target.result) &#125; &#x2F;&#x2F;转 失败 reader.onerror &#x3D; function (error) &#123; console.log(&#39;Error: &#39;, error) &#125; &#x2F;&#x2F;转 结束 咱就 resolve 出去 reader.onloadend &#x3D; function() &#123; console.log(&#39;转换结束&#39;) &#125;; &#125; &#125; &#125; &lt;&#x2F;script&gt; acceptFileType.js文件export default function acceptFile(e) &#123; const allowHook = &#123; video: '.mp4, .ogv, .ogg, .webm', audio: '.wav, .mp3, .ogg, .acc, .webm, .amr', file: 'doc,.docx,.xlsx,.xls,.pdf', excel: 'xlsx,.xls', img: '.jpg, .jpeg, .png, .gif' &#125; if (e) &#123; return allowHook[e]; &#125; let srt = null for (const k in allowHook) &#123; srt += allowHook[k] &#125; return srt &#125; 文件类型验证 Demo2/* * 校验上传文件 * */ export default function validUploadFile(type = 'img', file) &#123; if (!file) &#123; file = type; type = 'img' &#125; const fileName = file.name; const m = fileName.match(/\\.(\\w+)(#|\\?|$)/); const fileType = (m &amp;&amp; m[1]).toString().toLowerCase(); const allowHook = &#123; video: ['mp4', 'ogv', 'ogg', 'webm'], audio: ['wav', 'mp3', 'ogg', 'acc', 'webm', 'amr'], file: ['doc', 'docx', 'xlsx', 'xls', 'pdf'], excel: ['xlsx', 'xls'], img: ['jpg', 'jpeg', 'png', 'gif'] &#125; const validType = (allowHook[type] || []).includes(fileType); if (!validType) &#123; const supprtTypes = allowHook[type].join(','); return `只支持$&#123;supprtTypes&#125;类型文件上传`; &#125; if (fileName.indexOf('%') &gt; -1 || fileName.indexOf('&amp;') &gt; -1) &#123; return '上传文件名称不能带有字符\"%\",\"&amp;\"'; &#125; const isLt10M = file.size / 1024 / 1024 &lt; 10; if (type === file &amp;&amp; !isLt10M) &#123; this.$message.error('上传资料大小不能超过 10MB!'); return false; &#125; return true; &#125; 使用方式changeFile(file, fileList) &#123; console.log(file.raw) console.log(vavilidFileType('file', file.raw)) &#125; 使用原生js进行文件上传转base64&lt;template&gt; &lt;div class&#x3D;&quot;imageUpload&quot;&gt; &lt;input type&#x3D;&quot;file&quot; id&#x3D;&quot;file&quot; multiple&#x3D;&quot;multiple&quot; @change&#x3D;&quot;handleFile&quot; :accept&#x3D;&quot;acceptFile(&#39;file&#39;)&quot;&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; import acceptFileType from &#39;..&#x2F;util&#x2F;acceptFileType&#39; import vavilidFileType from &#39;..&#x2F;util&#x2F;vavilidFileType&#39; export default &#123; name: &quot;imageUpload&quot;, methods: &#123; acceptFile(type)&#123; this.acceptTypeList &#x3D; acceptFileType(type) return this.acceptTypeList &#125;, handleFile(e)&#123; const file &#x3D; e.target.files[0] console.log(file) const canAccept &#x3D; vavilidFileType(&#39;file&#39;, file) if (!canAccept)&#123; this.$message.info(&#39;上传的文件格式不对!&#39;); return; &#125; const isLt5M &#x3D; file.size &#x2F; 1024 &#x2F; 1024 &lt; 5; if (!isLt5M) &#123; this.$message.info(&#39;上传头像图片大小不能超过 5MB!&#39;); return; &#125; let This &#x3D; this; let reader &#x3D; new FileReader(); reader.readAsDataURL(file); &#x2F;&#x2F;开始转 reader.onload &#x3D; function(e)&#123; this.result; &#x2F;&#x2F;base64编码 &#x2F;&#x2F; console.log(this.result) console.log(e.target.result) &#125; &#x2F;&#x2F;转 失败 reader.onerror &#x3D; function (error) &#123; console.log(&#39;Error: &#39;, error) &#125; &#x2F;&#x2F;转 结束 咱就 resolve 出去 reader.onloadend &#x3D; function() &#123; console.log(&#39;转换结束&#39;) &#125;; &#125; &#125; &#125; &lt;&#x2F;script&gt;","permalink":"https://codermino.github.io/2020/12/07/vue%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E8%BD%ACbase64/","photos":[]},{"tags":[{"name":"vue图片转base64","slug":"vue图片转base64","permalink":"https://codermino.github.io/tags/vue%E5%9B%BE%E7%89%87%E8%BD%ACbase64/"}],"title":"vue图片转base64","date":"2020/12/07","text":"使用原生的input&lt;template&gt; &lt;div class&#x3D;&quot;imageUpload&quot;&gt; &lt;input id&#x3D;&quot;fileId1&quot; type&#x3D;&quot;file&quot; accept&#x3D;&quot;image&#x2F;png,image&#x2F;gif,&#39;image&#x2F;jpeg&#39;&quot; name&#x3D;&quot;file&quot; @change&#x3D;&quot;fileChange&quot;&#x2F;&gt; &lt;img v-if&#x3D;&quot;imageUrl&quot; :src&#x3D;&quot;imageUrl&quot; class&#x3D;&quot;uploadAvatar&quot;&#x2F;&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default &#123; name: &quot;imageUpload&quot;, data() &#123; return &#123; imageUrl: &#39;&#39;, imageBaseUrl: &#39;&#39;, &#125; &#125;, methods: &#123; fileChange (e)&#123; const file &#x3D; e.target.files[0] const isJPGORPNG &#x3D; file.type &#x3D;&#x3D;&#x3D; &#39;image&#x2F;jpeg&#39; || file.type &#x3D;&#x3D;&#x3D; &#39;image&#x2F;png&#39; const isLt1M &#x3D; file.size &#x2F; 1024 &#x2F; 1024 &lt; 1; if (!isJPGORPNG) &#123; this.$message.info(&#39;上传头像图片只能是 JPG 或 PNG 格式!&#39;); return; &#125; if (!isLt1M) &#123; this.$message.info(&#39;上传头像图片大小不能超过 1MB!&#39;); return; &#125; let This &#x3D; this; let reader &#x3D; new FileReader() reader.readAsDataURL(file); reader.onload &#x3D; function(e)&#123; this.result; &#x2F;&#x2F;base64编码 console.log(this.result) This.imageBaseUrl &#x3D; this.result; This.imageUrl &#x3D; this.result; &#125; reader.onerror &#x3D; function (error) &#123; console.log(&#39;Error: &#39;, error) &#125; &#125; &#125; &#125; &lt;&#x2F;script&gt; 使用el-upload&lt;template&gt; &lt;div class&#x3D;&quot;imageUpload&quot;&gt; &lt;el-upload class&#x3D;&quot;avatar-uploader&quot; action&#x3D;&quot;&quot; ref&#x3D;&quot;uploadAvatar&quot; :show-file-list&#x3D;&quot;false&quot; :auto-upload&#x3D;&quot;false&quot; :on-change&#x3D;&quot;changeFile&quot;&gt; &lt;img v-if&#x3D;&quot;imageUrl&quot; :src&#x3D;&quot;imageUrl&quot; class&#x3D;&quot;uploadAvatar&quot;&gt; &lt;i v-else class&#x3D;&quot;el-icon-plus avatar-uploader-icon&quot;&gt;&lt;&#x2F;i&gt; &lt;&#x2F;el-upload&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default &#123; name: &quot;imageUpload&quot;, data() &#123; return &#123; imageUrl: &#39;&#39;, imageBaseUrl: &#39;&#39;, &#125; &#125;, methods: &#123; &#x2F;** * 文件框改变事件 * @param file * @param fileList *&#x2F; changeFile(file, fileList) &#123; const isJPGORPNG &#x3D; (file.raw.type &#x3D;&#x3D;&#x3D; &#39;image&#x2F;jpeg&#39; || file.raw.type &#x3D;&#x3D;&#x3D; &#39;image&#x2F;png&#39;); const isLt1M &#x3D; file.size &#x2F; 1024 &#x2F; 1024 &lt; 1; if (!isJPGORPNG) &#123; this.$message.info(&#39;上传头像图片只能是 JPG 或 PNG 格式!&#39;); return; &#125; if (!isLt1M) &#123; this.$message.info(&#39;上传头像图片大小不能超过 1MB!&#39;); return; &#125; let This &#x3D; this; let reader &#x3D; new FileReader(); reader.readAsDataURL(file.raw); reader.onload &#x3D; function(e)&#123; this.result; &#x2F;&#x2F;base64编码 console.log(this.result) This.imageBaseUrl &#x3D; this.result; This.imageUrl &#x3D; this.result; &#125; reader.onerror &#x3D; function (error) &#123; console.log(&#39;Error: &#39;, error) &#125; &#125; &#125; &#125; &lt;&#x2F;script&gt; tip 在上传图片时, accept不要设置成 accept=\"image/png,image/jpg,image/jpeg\"! 后果: 浏览图片时不会自动进入相册,默认打开的是最近使用文档文件夹 但是最近的显示为空,而且图片会变灰选择不了. 直接设置成 accept=\"image/*\" ;","permalink":"https://codermino.github.io/2020/12/07/vue%E5%9B%BE%E7%89%87%E8%BD%ACbase64/","photos":[]},{"tags":[{"name":"前端HTTP协议知识","slug":"前端HTTP协议知识","permalink":"https://codermino.github.io/tags/%E5%89%8D%E7%AB%AFHTTP%E5%8D%8F%E8%AE%AE%E7%9F%A5%E8%AF%86/"}],"title":"前端HTTP协议知识","date":"2020/12/05","text":"HTTP协议HTTP&lt;超文本传输协议&gt;的缩写。是用于从WWW服务器传输超文本到本地浏览器的传输协议.HTTP是一个应用层协议，由请求和响应构成，是一个标准的个客户端和服务器模型。 特点 支持客户/服务器模式 c/s 简单快速 灵活 无连接： 无连接的含义是限制每次连接只处理一个请求。 服务器处理完客户的请求，并收到客户的应答后，即断开连接。 采用这种方式可以节省传输时间。 无状态 HTTP协议是无状态协议。 无状态是指协议对于事务处理没有记忆能力。 缺少状态意味着如果后续处理需要前面的信息，则它必须重传， 这样可能导致每次连接传送的数据量增大。 另一方面，在服务器不需要先前信息时它的应答就较快。 HTTP报文 请求报文：一个HTTP请求报文由四个部分组成：请求行、请求头、空行、请求体。 1 请求行：请求行由请求方法字段、URL字段和HTTP协议版本字段3个字段组成，它们用空格分隔。 比如 GET /data/info.html HTTP/1.1 2 请求头：key: value值，告诉服务器客户端需要哪些内容，什么类型。 3 空行：它的作用是通过一个空行，告诉服务器请求头部到此为止。 4 请求体：若方法字段是GET，则此项为空，没有数据。若方法字段是POST,则通常来说此处放置的就是要提交的数据 响应报文：HTTP响应报文也由四部分组成：状态行、响应头、空行、响应体。 1 响应行：响应行一般由协议版本、状态码及其描述组成 比如 HTTP/1.1 200 OK 2 响应头：响应头用于描述服务器的基本信息，以及数据的描述，服务器通过这些数据的描述信息， 可以通知客户端如何处理等一会儿它回送的数据。 3 空行：它的作用是通过一个空行，告诉服务器请求头部到此为止。 4 响应体：响应体就是响应的消息体，如果是纯数据就是返回纯数据，如果请求的是HTML页面， 那么返回的就是HTML代码，如果是JS就是JS代码，如此之类。 GET和POST的区别 GET在浏览器回退时是无害的，而POST会再次提交请求 GET产生的UR地址可以被收藏，而POST不可以 GET请求会被浏览器主动缓存，而POST不会，除非手动设置 GET请求只能进行ur|编码，而POST支持多种编码方式 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留 GET请求在URL中传送的参数是有长度限制的，而POST没有限制 对参数的数据类型，GET只接受ASCII字符，而POST没有限 GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息 GET参数通过URL传递，POST放在Request body中 状态码1：指示信息—表示请求已接受，继续处理2：成功—表示请求已被成功接受 200 OK：客户端请求成功 206 Partial Content：客户端发送了一个带有Range头的GET请求，服务器完成了它3：重定向—要完成请求必须进行更进一步的操作 301 Moved Permanently：所有请求的页面已转移至新的URL，永久重定向 302 Found：所请求的页面已经临时转至新的URL，临时重定向 303 See Other：临时重定向,应使用GET定向获取请求资源。 304 Not Modified：客户端有缓冲的文档并发出了一个条件性的请求，服务器告诉客户，原来缓冲的文档还可以继续使用4：客户端错误—请求有语法错误，或请求无法实现 400 Bad Request：客户端请求有语法错误，不能被服务器所理解 401 Unauthorized：请求未经授权，这个状态码必须和WWW-Authenticate报头域一起使用 403 Forbidden：对被请求的页面访问被禁止 404 Not Found：请求资源不存在5**：服务器错误—服务器未能实现合法的请求 500 Internal Sever Error：服务器发生不可预期的错误原来缓冲的文档还可以继续使用 503 Server Unavailable：请求未完成，服务器临时过载或当机，一段时间后可恢复正常 请求头常见请求头Referer：表示这个请求是从哪个URL跳转过来的（直接访问就不会有这个请求头）Accept：告诉服务端，请求所能支持的响应类型，如html、css、js（MIME类型）if-Modified-Sincce：预览器通知服务器，本地缓存的最后变更时间。Cookie：客户端的Cookie通过这个报文属性传给服务端。User-Agent：预览器通知服务器，客户端预览器与操作系统相关信息。Connection：表示客户端与服务连接类型；Keep-Alive表示持久连接，close表示已关闭Host：请求的服务器主机名。Content-Length：请求体的长度。Content-Type：请求的与实体对应的MIME信息。如果是Post请求，会有这个头。 请求方式get请求：将请求参数追加在url后面，不安全，url长度限制get请求方式数据大小， 没有请求体，一般的HTTP请求大多都是GETPOST请求：请求参数在请求体处，较安全，请求数据大小没有显示， 只有表单设置为method=“post”才是post请求，其他都是get请求， 常见get请求如地址栏直接访问等HEAD请求：HEAD和GET相似，不过服务端接受到HEAD请求时只返回响应头， 不发送响应内容，所以当只看页面状态时，用HEAD更有效， 因为省去传输页面内容的时间。DELETE请求：删除某一个资源OPTIONS请求：用于获取当前URL所支持的方法。若请求成功， 会在HTTP头中包含一个名为“Allow”的头，值是所支持的方法，如“GET、POST”PUT请求：把一个资源存放在指定的位置上，本质上讲，PUT和POST极为相似，都是向服务器发送数据， 但他们之间有一个重要的区别，PUT通常指定了资源的存放位置， 而POST没有，POST的数据存放位置由自己决定。TRACE请求：回显服务器的请求，用于测试或诊断。CONNECT请求：CONNECT方法是HTTP/1.1协议预留的，能够将连接改为管道方式的代{过}{滤}理服务器， 通常用于SSL加密翻译为一起的连接与非加密的HTTP代{过}{滤}理服务器的通信。 put和post区别PUT请求：如果两个请求相同，后一个请求会把第一个请求覆盖掉。（所以PUT用来改资源）Post请求：后一个请求不会把第一个请求覆盖掉。（所以Post用来增资源）","permalink":"https://codermino.github.io/2020/12/05/%E5%89%8D%E7%AB%AFHTTP%E5%8D%8F%E8%AE%AE%E7%9F%A5%E8%AF%86/","photos":[]},{"tags":[{"name":"前端开发中常用图片格式","slug":"前端开发中常用图片格式","permalink":"https://codermino.github.io/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E4%B8%AD%E5%B8%B8%E7%94%A8%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F/"}],"title":"前端开发中常用图片格式","date":"2020/12/05","text":"无压缩存储 BMP（BMP 取自位图 BitMaP 的缩写，也称为 DIB（与设备无关的位图）） 这里仅仅是跟后边压缩格式做对照说明，web 开发中不要使用 bmp 格式图片。 压缩存储无损压缩 GIF（Graphics Interchange Format 图像互换格式） PNG 全称便携式网络图形（外语全称：Portable Network Graphics） 有损压缩 代表格式 jpg 全称联合照片专家组（外语简称 JPEG 外语全称：Joint Photographic Expert Group） jpg===jpeg 矢量图片 svg（Scalable Vector Graphics）可缩放矢量图形（外语简称 SVG、外语全称：Scalable Vector Graphics）。 其他base64base64 本身不属于图片格式，是以字符串格式来保存图片数据的一种方式雪碧图（CSS Sprite）雪碧图也是为了减少网络请求，将小图标和背景图像合并到一张图片上，然后利用 css 的 background-positon 或者 img 的 clip 来显示需要显示的图片部分iconfontIconfont 是采用字体的方式来做图标。它的原理就是将很多 icon 做成字体库，通过样式或者字体对应的字符集来显示这个 icon。 额外一些图片相关知识保存为 web 格式webPWebP 格式，谷歌（google）开发的一种旨在加快图片加载速度的图片格式。gzip 压缩在真实环境中，为了减小网络请求，服务端一般会开启 gzip 压缩。因为图片相对尺寸较大，而且基本上常用的图片格式已经被做过压缩。前端服务器 gzip 压缩时候，不要对图片类型开启","permalink":"https://codermino.github.io/2020/12/05/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E4%B8%AD%E5%B8%B8%E7%94%A8%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F/","photos":[]},{"tags":[{"name":"css的position区别","slug":"css的position区别","permalink":"https://codermino.github.io/tags/css%E7%9A%84position%E5%8C%BA%E5%88%AB/"}],"title":"css的position区别","date":"2020/12/05","text":"各种定位 static：静态定位是position的默认值，元素框正常生成，也就是没有定位时的正常显示。 relative：相对定位用法一：元素相对自身的原位置偏移某个距离，但是原本的空间依旧保留，表现为空白。用法二：把一个元素设置为position: relative; 可以使该元素的子元素相对该元素绝对定位。 absolute：绝对定位元素从文档流删除，并相对于包含块定位。元素在原本的空间关闭。元素定位后生成一个块级框，不论它原来是行内元素还是块级元素。 包含块：最近的position值不是static的祖先元素(块级或行内)，一般会指定一个元素作为绝对定位元素的包含块，将其position设置为relative而且没有偏移。 fixed：固定定位元素从文档流删除，并相对于浏览器视窗定位，因此不随文档滚动而移动。元素在原本的空间关闭。元素定位后生成一个块级框，不论它原来是行内元素还是块级元素。与绝对定位的区别仅仅是包含块不同。包含块：浏览器视窗。 absolute/fixed和float对比类似：元素都会从文档流删除，但是依旧会影响布局;都会生成一个块级框，无论原来是不是块级元素。区别：float的包含块是最近的块级祖先元素。 偏移属性偏移属性：top/right/bottom/left，初始值是auto。采用position定位之后必须采用偏移属性定义偏移量，也就是相对包含块的偏移。注意应用于position值不是static的元素。有时也需要定义width和heigth，但是可能会和偏移属性的定义冲突，因为四个偏移属性实际上已经定义了元素的大小。此时，根据width和left属性定义左右，根据top和height属性定义上下。 overflow内容溢出overflow: visible/ hidden/ scroll /auto/ inherit，初始值是visible。一个元素的大小固定，但是其内容放不下，就会导致溢出。overflow控制溢出部分的可见(visible)、不可见(hidden)、滚动可见(scroll)。 元素可见性元素可见性visibility: visible/ hidden/ collapse/ inherit，初始值是visible。visibility:hidden和display:none的区别：visibility:hidden设置元素不可见，占据位置但是元素部分呈现为空白;display:none元素不显示并且从文档流中删除。","permalink":"https://codermino.github.io/2020/12/05/css%E7%9A%84position%E5%8C%BA%E5%88%AB/","photos":[]},{"tags":[{"name":"css垂直居中","slug":"css垂直居中","permalink":"https://codermino.github.io/tags/css%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/"}],"title":"css垂直居中","date":"2020/12/03","text":"垂直居中 单行文本垂直居中：如果一个容器中只有一行文字，对它实现居中相对比较简单，我们只需要设置它的实际高度height和所在行的高度line-height相等即可。div&#123; height:25px; line-height:25px; &#125; 多行文本固定高度的居中（模拟table方法）css中垂直居中样式vertical-align:middle属性,但是此属性只对标签、、，和内联元素display设置为inline/inline-block起作用，其他的则不起作用(1)InternetExplorer6及以下的版本中是无效的vertical-align:middle 对表格起作用(可以用下面第4种方法)，那么可以用div来模拟成为table， 让vertical-align:middle属性起作用。 注意，display:table和display:table-cell的使用方法，前者必须设置在父元素上，后者必须设置在子元素上， 因此我们要为需要定位的文本再增加一个&lt;div&gt;元素： 代码如下:div#wrap&#123; height:400px; display:table; &#125; div#content&#123; vertical-align:middle; display:table-cell; border:1px solid #FF0099; background-color:#FFCCFF; width:760px; &#125; &lt;body&gt; &lt;div id=\"wrap\"&gt; &lt;div id=\"content\"&gt; &lt;pre&gt;现在我们要使这段文字垂直居中显示&lt;/pre&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; 使用用定位的方式positiondiv#wrap&#123; position:relative; overflow:hidden; &#125; div#content&#123; position:absolute; top:50%; height:400px; margin-top: -200px; &#125; 使用transitiondiv#wrap&#123; position: relative; &#125; div#content&#123; position: absolute; top: 50%; transform: translateY(-50%); &#125; 使用flexdiv#wrap&#123; display: flex; align-items: center;//垂直居中 justify-content: center; //水平居中 &#125; 水平垂直居中 div绝对定位水平垂直居中兼容性：,IE7及之前版本不支持div&#123; width: 200px; height: 200px; background: green; position:absolute; left:0; top: 0; bottom: 0; right: 0; margin: auto; &#125; div绝对定位水平垂直居中div&#123; width:200px; height: 200px; background:green; position: absolute; left:50%; top:50%; margin-left:-100px; margin-top:-100px; &#125; div绝对定位水平垂直居中兼容性：IE8不支持div&#123; width: 200px; height: 200px; background: green; position:absolute; left:50%; /* 定位父级的50% */ top:50%; transform: translate(-50%,-50%); /*自己的50% */ &#125; 弹性盒模型-css不定宽高水平垂直居中.box&#123; height:600px;/去掉高度，只能垂直居中。 display:flex; justify-content:center; align-items:center; &#125; .box&gt;div&#123; background: green; width: 200px; height: 200px; &#125; 将父盒子设置为table-cell元素，可以使用text-align:center和vertical-align:middle实现水平、垂直居中。比较完美的解决方案是利用三层结构模拟父子结构&lt;!DOCTYPE html&gt; &lt;html lang=\"zh-CN\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div style=\"display: table-cell;vertical-align: middle; text-align: center; width: 300px;height: 300px;border: 1px solid #ccc;\"&gt; &lt;div style=\"display: inline-block;width: 200px;height: 200px;background-color: red;\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 对子盒子实现绝对定位，利用calc计算位置&lt;p class=\"outerBox calc\"&gt; &lt;/p&gt;&lt;p class=\"innerBox\"&gt;calc&lt;/p&gt; &lt;p&gt;&lt;/p&gt; /*绝对定位，clac计算位置*/ .calc&#123; position: relative; &#125; .calc .innerBox&#123; position: absolute; left:-webkit-calc((500px - 200px)/2); top:-webkit-calc((120px - 50px)/2); left:-moz-calc((500px - 200px)/2); top:-moz-calc((120px - 50px)/2); left:calc((500px - 200px)/2); top:calc((120px - 50px)/2); &#125; display:table&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .con&#123; background: red; display: table; /* 将父元素div模拟为块级表格 table*/ margin: 50px; /* 设置父元素 table 的margin*/ &#125; .container&#123; width: 200px; height:50px; border: 1px solid black; display: table-cell; vertical-align: middle; text-align: center; /*margin: 50px;*/ 去掉设置无效的 margin &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"con\"&gt; &lt;div class=\"container\"&gt; a &lt;/div&gt; &lt;div class=\"container\"&gt; b &lt;/div&gt; &lt;div class=\"container\"&gt; c &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;","permalink":"https://codermino.github.io/2020/12/03/css%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/","photos":[]},{"tags":[{"name":"vue配置浏览器兼容性","slug":"vue配置浏览器兼容性","permalink":"https://codermino.github.io/tags/vue%E9%85%8D%E7%BD%AE%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7/"}],"title":"vue配置浏览器兼容性","date":"2020/12/02","text":"官网解释当你把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项， Vue 将遍历此对象所有的 property， 并使用 Object.defineProperty 把这些 property 全部转为 getter/setter。 Object.defineProperty 是 ES5 中一个无法 shim 的特性， 这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。 shimShim 指的是在一个旧的环境中模拟出一个新 API ， 而且仅靠旧环境中已有的手段实现，以便所有的浏览器具有相同的行为。 你可以把shim理解成可以兼容之前版本，是一种优雅降级。 比如，在vue文档里面，尤大说Object.defineProperty 是 ES5 中一个无法 shim 的特性， 这也就是为什么 Vue 不支持 IE8 以及更低版本浏览器的原因。 这里的意思就是无法降级，不兼容es5之前版本。 es5-shim可以让一些低级的浏览器支持最新的ecmascript5的一些特性。 支持浏览器或node.js. 已经测试的功能见https://github.com/es-shims/es5-shim 出现的问题vue项目在ie11下一片空白并报Symbol 未定义的错 ie10浏览器解析不了es6的语法， 需要我们使用babel（Babel是一种工具链，主要用于将 ECMAScript 2015+代码转换为当前和旧版浏览器或环境中的向后兼容版本的JavaScript）。 但是Babel 默认只转换新的 JavaScript 句法（syntax），而不转换新的 API ， 比如 Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象， 以及一些定义在全局对象上的方法（比如 Object.assign）都不会转码。 兼容 ECMAScript 5 的浏览器 解释根据提供的 链接 我们可以看到，ie6 - ie8 是被标记成红色，即是不支持， 所以结果是 Vue 至少可以在 ie9 上运行，但根据最新公布的 Vue 3.0 开发路线及特性中有说明， Vue 3.0 将只有部分特性支持 ie11，其它的特性使用兼容的方式进行支持。 解决方法 npm install -D babel-polyfillpolyfill指的是“用于实现浏览器不支持原生功能的代码”， 比如，现代浏览器应该支持fetch函数，对于不支持的浏览器， 网页中引入对应fetch的polyfill后，polyfill就给全局的window对象上增加一个fetch函数， 让这个网页中的JavaScript可以直接使用fetch函数了，就好像浏览器本来就支持fetch一样。 在main.js中引入： import ‘babel-polyfill’ //要放在第一行，放在下面可能会失效 （要在引入vue，vuex，elementui 之前引入）3. 修改package.josn文件 \"browserslist\": [ \"&gt; 1%\", \"last 2 versions\", \"not dead\", \"not IE &lt;= 10\" ]","permalink":"https://codermino.github.io/2020/12/02/vue%E9%85%8D%E7%BD%AE%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7/","photos":[]},{"tags":[{"name":"axios取消上一个页面的请求","slug":"axios取消上一个页面的请求","permalink":"https://codermino.github.io/tags/axios%E5%8F%96%E6%B6%88%E4%B8%8A%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%AF%B7%E6%B1%82/"}],"title":"axios取消上一个页面的请求","date":"2020/12/01","text":"第一步&#x2F;&#x2F; 在发送请求设置cancel token &#x2F;&#x2F; 这里配置了cancelToken属性，覆盖了原请求中的cancelToken config.cancelToken &#x3D; new axios.CancelToken(cancel &#x3D;&gt; &#123; vm.$store.commit(&#39;app&#x2F;pushToken&#39;, &#123; cancelToken: cancel &#125;) &#125;) 请求拦截中使用&#x2F;&#x2F; http请求拦截 util.http.interceptors.request.use(function (config) &#123; config.headers.Authorization &#x3D; localStorage.token &#x2F;&#x2F; 在发送请求设置cancel token config.cancelToken &#x3D; new axios.CancelToken(cancel &#x3D;&gt; &#123; &#x2F;&#x2F;cancel 强行中断请求要用到的，记录请求信息 &#x2F;&#x2F; 这里需要用一个数组进行存储,然后路由跳转的时候遍历数组进行取消请求 vm.$store.commit(&#39;app&#x2F;pushToken&#39;, &#123; cancelToken: cancel &#125;) &#125;) return config &#125;, function (error) &#123; &#x2F;&#x2F; 请求失败的处理 return Promise.reject(error) &#125;) 响应拦截&#x2F;&#x2F; http响应拦截 util.http.interceptors.response.use(function (res) &#123; return res &#125;, function (error) &#123; if (axios.isCancel(error)) &#123; &#x2F;&#x2F; 判断错误是否是取消请求导致的,取消请求的情况下，终端Promise调用链 return new Promise(() &#x3D;&gt; &#123;&#125;) &#125; &#125;) vuexstate: &#123; cancelTokenArr: [] &#125;, mutations: &#123; pushToken (state, payload) &#123; state.cancelTokenArr.push(payload.cancelToken) &#125;, clearToken (&#123; cancelTokenArr &#125;) &#123; cancelTokenArr.forEach(item &#x3D;&gt; &#123; item(&#39;路由跳转取消请求&#39;) &#x2F;&#x2F; 给个标志，中断请求 &#125;) cancelTokenArr &#x3D; [] &#125; &#125; router路由守卫路由跳转前，清除所有请求import store from ‘../store/store’ router.beforeEach((to, from, next) &#x3D;&gt; &#123; &#x2F;&#x2F; 2. 准备执行新的请求前，先将前一个请求取消 &#x2F;&#x2F; 如果前一个请求执行完了，执行取消请求不会有其他操作 store.commit(&#39;app&#x2F;clearToken&#39;) &#x2F;&#x2F; 取消请求 next() &#125;) Demo axios.interceptors.response.use(res&#x3D;&gt;&#123; return res &#125;,err&#x3D;&gt;&#123; if(axios.isCancel(err))&#123; &#x2F;&#x2F; 中断promise链接 return new Promise(()&#x3D;&gt;&#123;&#125;) &#125;else&#123; &#x2F;&#x2F; 把错误继续向下传递 return Promise.reject(err) &#125; &#125;) 完整的一个Democonst CANCEL_TOKEN &#x3D; axios.CancelToken; &#x2F;** * vue添加原型属性，记录请求信息 *&#x2F; Vue.prototype.$httpRequestList &#x3D; []; axios(&#123; url: url, methods: &#39;POST&#39;, data: options, cancelToken: new CANCEL_TOKEN(c &#x3D;&gt; &#123; &#x2F;&#x2F;强行中断请求要用到的，记录请求信息 Vue.prototype.$httpRequestList.push(c); &#125;) &#125;).then(res &#x3D;&gt; &#123;&#125;).catch(err &#x3D;&gt; &#123; if (err.message &#x3D;&#x3D; &quot;interrupt&quot;) &#123; console.log(&#39;已中断请求&#39;); return; &#125; &#125;) &#x2F;** * 在路由切换之前检测来中断上个页面的请求 *&#x2F; router.beforeEach((to, from, next) &#x3D;&gt; &#123; &#x2F;&#x2F;路由切换检测是否强行中断， if(Vue.$httpRequestList.length&gt;0)&#123; &#x2F;&#x2F;强行中断时才向下执行 Vue.$httpRequestList.forEach(item&#x3D;&gt;&#123; item(&#39;interrupt&#39;);&#x2F;&#x2F;给个标志，中断请求 &#125;) &#125; next(); &#125;);","permalink":"https://codermino.github.io/2020/12/01/axios%E5%8F%96%E6%B6%88%E4%B8%8A%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%AF%B7%E6%B1%82/","photos":[]},{"tags":[{"name":"vue的路由重定向","slug":"vue的路由重定向","permalink":"https://codermino.github.io/tags/vue%E7%9A%84%E8%B7%AF%E7%94%B1%E9%87%8D%E5%AE%9A%E5%90%91/"}],"title":"vue的路由重定向","date":"2020/11/30","text":"&#123; path:&#39;&#x2F;&#39;, redirect:&#39;&#x2F;home&#39;, meta:&#123; title:&#39;首页&#39; &#125;, component:()&#x3D;&gt;import(&#39;@&#x2F;views&#x2F;layout&#39;), children:[ &#123; path:&#39;&#x2F;home&#39;, meta:&#123; title:&#39;首页&#39; &#125;, component:()&#x3D;&gt;import(&#39;@&#x2F;views.Home&#39;) &#125; ] &#125;","permalink":"https://codermino.github.io/2020/11/30/vue%E7%9A%84%E8%B7%AF%E7%94%B1%E9%87%8D%E5%AE%9A%E5%90%91/","photos":[]},{"tags":[{"name":"iview使用render集成switch开关","slug":"iview使用render集成switch开关","permalink":"https://codermino.github.io/tags/iview%E4%BD%BF%E7%94%A8render%E9%9B%86%E6%88%90switch%E5%BC%80%E5%85%B3/"}],"title":"iview使用render集成switch开关","date":"2020/11/17","text":"table&lt;Table highlight-row border :columns&#x3D;&quot;columns1&quot; :data&#x3D;&quot;data1&quot; ref&#x3D;&quot;table&quot; :height&#x3D;&quot;tableHeight&quot;&gt;&lt;&#x2F;Table&gt; columnscolumns1: [&#123; fixed: &#39;right&#39;, title: &#39;Action&#39;, key: &#39;action&#39;, width: 250, align: &#39;center&#39;, render:(h, params) &#x3D;&gt; &#123; return h(&#39;div&#39;, [ h(&#39;Button&#39;, &#123; props: &#123; type: &#39;primary&#39;, size: &#39;small&#39; &#125;, style: &#123; marginRight: &#39;20px&#39; &#125;, on: &#123; click: () &#x3D;&gt; &#123; this.show(params.index) &#125; &#125; &#125;, &#39;阅览&#39;), h(&#39;strong&#39;, &#123; style: &#123; marginRight: &#39;5px&#39; &#125;, &#125;, &#39;处理&#39;), h(&#39;i-switch&#39;, &#123; &#x2F;&#x2F;数据库1是已处理，0是未处理 props: &#123; type: &#39;primary&#39;, value: params.row.treatment &#x3D;&#x3D;&#x3D; 1 &#x2F;&#x2F;控制开关的打开或关闭状态，官网文档属性是value &#125;, style: &#123; marginRight: &#39;5px&#39; &#125;, on: &#123; &#39;on-change&#39;: (value) &#x3D;&gt; &#123;&#x2F;&#x2F;触发事件是on-change,用双引号括起来， &#x2F;&#x2F;参数value是回调值，并没有使用到 this.switch(params.index) &#x2F;&#x2F;params.index是拿到table的行序列，可以取到对应的表格值 &#125; &#125; &#125;, ) ]); &#125; &#125;]","permalink":"https://codermino.github.io/2020/11/17/iview%E4%BD%BF%E7%94%A8render%E9%9B%86%E6%88%90switch%E5%BC%80%E5%85%B3/","photos":[]},{"tags":[{"name":"前端性能优化","slug":"前端性能优化","permalink":"https://codermino.github.io/tags/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"title":"前端性能优化","date":"2020/11/12","text":"原则 多使用内存，缓存或者其他方法 减少CPU计算，减少网络请求 减少IO操作（硬盘读写） 加载资源优化 静态资源的合并和压缩。 静态资源缓存（浏览器缓存策略）。 使用CDN让静态资源加载更快。 渲染优化 CSS放head中，JS放body后 图片懒加载减少DOM操作，对DOM操作做缓存 减少DOM操作，多个操作尽量合并在一起执行 事件节流 尽早执行操作 DOMContentLoaded 示例 资源合并a.js b.js c.js --- abc.js 缓存通过连接名称控制缓存&lt;script src=\"abc_1.js\" &gt;&lt;/script&gt; 只有改变内容的时候，链接名称才会改变。 懒加载&lt;img src=\"preview.png\" realsrc=\"abc.png\" id=\"img1\" /&gt; &lt;script&gt; var i = document.getElementById('img1'); i.src = i.getAttribute('realsrc'); &lt;/script&gt; 缓存dom查询//没有缓存dom for (let i = 0; i &lt; document.getElementsByTagName('p').length; i++) &#123; &#125; //缓存dom var p = document.getElementsByTagName('p'); for (let i = 0; i &lt; p.length; i++) &#123; &#125; 合并dom插入var listNode = document.getElementById('list'); var flag = document.createDocumentFragment(); var li; for (let i = 0; i &lt; 10; i++) &#123; li = document.createElement('li'); li.innerHTML = i; flag.appendChild(li); &#125; listNode.appendChild(flag); 10次dom插入 —&gt; 1次dom插入 事件节流监听文字改变事件，无操作100毫秒后执行操作，不用每次触发。var textarea = document.getElementById('ta'); var timeoutId; textarea.addEventListener('keyup',function()&#123; if(i)&#123; clearTimeout(i); &#125; timeoutId = setTimeout(() =&gt; &#123; //操作 &#125;, 100); &#125;); 事件节流主要用于触发频率较高的事件，设定一个缓冲触发事件。 异步加载1.动态脚本加载用js创建2.defer3.async &lt;script src=\"script.js\"&gt;&lt;/script&gt; 没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。 &lt;script async src=\"script.js\"&gt;&lt;/script&gt; 有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。 &lt;script defer src=\"myscript.js\"&gt;&lt;/script&gt; 有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。 关于 defer，我们还要记住的是它是按照加载顺序执行脚本的标记为async的脚本并不保证按照指定它们的先后顺序执行。对它来说脚本的加载和执行是紧紧挨着的，所以不管你声明的顺序如何，只要它加载完了就会立刻执行。 浏览器缓存缓存就是html文件在本地存在的副本强缓存发现有缓存直接用 Expires: 绝对时间，判断客户端日期是否超过这个时间 Cache-Control：相对时间，判断访问间隔是否大于3600秒 //在设定时间之前不会和服务端进行通信了 //如果两个都下发以后者为准 协商缓存询问服务器缓存是否可以用，在进行判断是否用。Last-Modified/If-Modified-Since 第一次请求，respone的header加上Last-Modified（最后修改时间） 再次请求，在request的header上加上If-Modified-Since 和服务端的最后修改时间对比，如果没有变化则返回304 Not Modified， 但是不会返回资源内容；如果有变化，就正常返回资源内容。 浏览器收到304的响应后，就会从缓存中加载资源 如果协商缓存没有命中，浏览器直接从服务器加载资源时， Last-Modified的Header在重新加载的时候会被更新 Etag/If-None-Match这两个值是由服务器生成的每个资源的唯一标识字符串，只要资源有变化就这个值就会改变；其判断过程与Last-Modified/If-Modified-Since类似，他可以精确到秒的更高级别。DNS预解析 &lt;meta http-equiv=\"x-dns-prefetch-control\" content=\"on\"&gt; &lt;link rel=\"dns-prefetch\" href=\"//www.zhix.net\"&gt; 在一些浏览器的a标签是默认打开dns预解析的，在https协议下dns预解析是关闭的，加入mate后会打开。","permalink":"https://codermino.github.io/2020/11/12/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","photos":[]},{"tags":[{"name":"vue的$set使用总结","slug":"vue的-set使用总结","permalink":"https://codermino.github.io/tags/vue%E7%9A%84-set%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"}],"title":"vue的$set使用总结","date":"2020/11/11","text":"vue的$set使用总结&lt;template&gt; &lt;div class&#x3D;&quot;setprac&quot;&gt; &lt;div v-for&#x3D;&quot;(item,index) in userdata&quot; :key&#x3D;&quot;index&quot;&gt; &lt;span&gt;name:&#123;&#123;item.name&#125;&#125;&lt;&#x2F;span&gt; &lt;span&gt; age:&#123;&#123;item.age&#125;&#125;&lt;&#x2F;span&gt; &lt;span v-if&#x3D;&quot;item.sex&quot;&gt; sex:&#123;&#123;item.sex&#125;&#125;&lt;&#x2F;span&gt; &lt;AButton @click&#x3D;&quot;changeDataName(item.name,index)&quot;&gt;更改姓名&lt;&#x2F;AButton&gt; &lt;AButton @click&#x3D;&quot;changeDataSex(item,index)&quot;&gt;添加性别&lt;&#x2F;AButton&gt; &lt;AButton @click&#x3D;&quot;changeDataItem(item,index)&quot;&gt;更改该条数据&lt;&#x2F;AButton&gt; &lt;&#x2F;div&gt; &lt;hr&gt; &lt;div&gt;&#123;&#123;user.name&#125;&#125;---&#123;&#123;user.age&#125;&#125;&lt;&#x2F;div&gt; &lt;a-button @click&#x3D;&quot;addSex&quot;&gt;添加sex&lt;&#x2F;a-button&gt; &#123;&#123;user&#125;&#125; &lt;hr&gt; &lt;span v-for&#x3D;&quot;(item,index) in numList&quot; :key&#x3D;&quot;&#39;num&#39;+index&quot;&gt; &#123;&#123;item&#125;&#125; &lt;&#x2F;span&gt; &lt;a-button @click&#x3D;&quot;changeNumList&quot;&gt;改变数字数组的值&lt;&#x2F;a-button&gt; &lt;a-button @click&#x3D;&quot;changeNumListSingle&quot;&gt;改变单个数字数组的值&lt;&#x2F;a-button&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default &#123; name: &quot;setprac&quot;, data() &#123; return &#123; userdata: [ &#123;name:&#39;zs&#39;,age:11&#125;, &#123;name:&#39;ls&#39;,age:12&#125;, &#123;name:&#39;ww&#39;,age:13&#125; ], user:&#123;name:&#39;sunhe&#39;,age:18&#125;, numList:[1,2,3,4,5] &#125; &#125;, methods: &#123; changeDataName(name,index) &#123; &#x2F;&#x2F; 修改本来存在的字段不需要使用$set也可以触发更新 this.userdata[index].name &#x3D; &#39;update&#39; &#125;, changeDataSex(item,index)&#123; &#x2F;&#x2F; this.userdata[index].sex &#x3D; &#39;男&#39; this.$set(this.userdata[index],&#39;sex&#39;,&#39;男&#39;) &#125;, addSex()&#123; &#x2F;&#x2F; this.user.sex &#x3D; &#39;男&#39; this.$set(this.user,&#39;sex&#39;,&#39;男&#39;) &#125;, changeNumList()&#123; this.numList &#x3D; [6,7,8,9,10] &#125;, changeNumListSingle()&#123; &#x2F;&#x2F; this.numList[0] &#x3D; 10 this.$set(this.numList,0,10) &#125;, changeDataItem(item,index)&#123; &#x2F;&#x2F; this.userdata[index] &#x3D; &#123;name:&#39;zl&#39;,age:100&#125; this.$set(this.userdata,index,&#123;name:&#39;zl&#39;,age:100&#125;) &#125; &#125;, &#125; &lt;&#x2F;script&gt;","permalink":"https://codermino.github.io/2020/11/11/vue%E7%9A%84-set%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/","photos":[]},{"tags":[{"name":"vue中$forceUpdate的使用","slug":"vue中-forceUpdate的使用","permalink":"https://codermino.github.io/tags/vue%E4%B8%AD-forceUpdate%E7%9A%84%E4%BD%BF%E7%94%A8/"}],"title":"vue中$forceUpdate的使用","date":"2020/11/11","text":"介绍vue中的$forceUpdate是强制更新的意思 案例demo就是一个对象数组，我们尝试直接给某个item增加一个属性，发现页面上没有效果；直接将length变成0来清空数组，也没有效果 change: function(index) &#123;&#x2F;&#x2F;增加性别属性 this.list[index].sex &#x3D; &#39;男&#39;; &#125;, clear: function() &#123;&#x2F;&#x2F;清空数组 this.list.length &#x3D; 0; &#125; 解决上面的写法没有效果，是因为没有按照vue的规范去写，因为vue文档里面写了，对于深层的，最好用$set方法，这样vue就可以知道发生了变化，同时vue也不建议直接修改length，可以给一个空数组来置空。 change: function(index) &#123;&#x2F;&#x2F;增加性别属性 this.$set(this.list[index],&#39;sex&#39;,&#39;男&#39;) &#125;, clear: function() &#123;&#x2F;&#x2F;清空数组 this.list&#x3D;[]; &#125; 使用$forceUpdatechange: function(index) &#123; this.list[index].sex &#x3D; &#39;男&#39;; this.$forceUpdate(); &#125;, clear: function() &#123; this.list.length &#x3D; 0; this.$forceUpdate(); &#125; 可以看到，当我们用$forceUpdate之后，就会得到正确的结果。当然，一般我们也不会这么去使用","permalink":"https://codermino.github.io/2020/11/11/vue%E4%B8%AD-forceUpdate%E7%9A%84%E4%BD%BF%E7%94%A8/","photos":[]},{"tags":[{"name":"iview中render函数与renderHeader函数","slug":"iview中render函数与renderHeader函数","permalink":"https://codermino.github.io/tags/iview%E4%B8%ADrender%E5%87%BD%E6%95%B0%E4%B8%8ErenderHeader%E5%87%BD%E6%95%B0/"}],"title":"iview中render函数与renderHeader函数","date":"2020/11/11","text":"Demo&#123; &#x2F;&#x2F; 采用 renderHeader 函数时，title就不需要了 &#x2F;&#x2F; title: this.$route.query.type &#x3D;&#x3D;&#x3D; &#39;1&#39; ? &#39;退款编号&#39; : &#39; &#39;, key: &#39;refundCode&#39;, align: &#39;center&#39;, &#x2F;&#x2F; renderHeader 函数： 自定义表头 renderHeader: (h, params) &#x3D;&gt; &#123; return h(&#39;span&#39;,this.$route.query.type &#x3D;&#x3D;&#x3D; &#39;1&#39; ? &#39;退款编号&#39; : &#39; &#39;,) &#125;, &#x2F;&#x2F; render 函数 ：定义列表内容 render: (h, params) &#x3D;&gt; &#123; return h(&#39;span&#39;, params.row.refundCode &#x3D;&#x3D;&#x3D; null ? &#39; &#39; : params.row.refundCode ) &#125; &#125;","permalink":"https://codermino.github.io/2020/11/11/iview%E4%B8%ADrender%E5%87%BD%E6%95%B0%E4%B8%8ErenderHeader%E5%87%BD%E6%95%B0/","photos":[]},{"tags":[{"name":"Promise.all代替axios.all","slug":"Promise-all代替axios-all","permalink":"https://codermino.github.io/tags/Promise-all%E4%BB%A3%E6%9B%BFaxios-all/"}],"title":"Promise.all代替axios.all","date":"2020/11/10","text":"介绍前端调用十几个接口，十几个接口完成后，再刷新页面，然后看了一下axios的官网（https://github.com/axios/axios）才发现axios.all已经被标记为Deprecated，并且建议用Promise.all。 Demolet requests = []; this.pageResult.data.forEach((item) =&gt; &#123; requests.push( getServiceVersion(item) .then((response) =&gt; &#123; const currentVersion = response.data.version; if (item.version != currentVersion) &#123; this.$Message.info( \"服务：\" + item.name + \" 数据库版本：\" + item.version + \" 当前版本：\" + currentVersion ); return updateService( Object.assign(item, &#123; version: currentVersion &#125;) ) .then((res) =&gt; &#123; return res; &#125;) .catch((error) =&gt; &#123; return error; &#125;); &#125; &#125;) .catch((error) =&gt; &#123; return error; &#125;) ); &#125;); Promise.all(requests).then((responses) =&gt; &#123; this.search(); &#125;); &#125;","permalink":"https://codermino.github.io/2020/11/10/Promise-all%E4%BB%A3%E6%9B%BFaxios-all/","photos":[]},{"tags":[{"name":"js将Set集合转换为Array数组","slug":"js将Set集合转换为Array数组","permalink":"https://codermino.github.io/tags/js%E5%B0%86Set%E9%9B%86%E5%90%88%E8%BD%AC%E6%8D%A2%E4%B8%BAArray%E6%95%B0%E7%BB%84/"}],"title":"js将Set集合转换为Array数组","date":"2020/11/10","text":"在JavaScript中，想要将Set（集合）转换为Array数组，可以通过以下方式实现。方法1：使用Array.from()方法Array.from()方法从对象或可迭代对象（如Map，Set等）返回一个新数组。语法： Array.from(arrayLike object); Demo &lt;script&gt; const set = new Set(['welcome', 'you','!']); console.log(set); console.log(Array.from(set)) &lt;/script&gt; 方法二：使用扩展运算符(三点运算符)“…”使用扩展运算符“…”也可以帮助我们将Set转换为数组。语法： var variablename = [...value]; Demo &lt;script&gt; const set = new Set(['HELLO', 'JS']); console.log(set); const array = [...set]; console.log(array); &lt;/script&gt; 方法三：使用forEachDemo &lt;script&gt; var Set = new Set(); var Array = []; Set.add(\"Hello\"); Set.add(\"World\"); Set.add(\"!\"); console.log(Set); var someFunction = function( val1, val2, setItself) &#123; Array.push(val1); &#125;; Set.forEach(someFunction); console.log(\"Array: \" + Array); &lt;/script&gt;","permalink":"https://codermino.github.io/2020/11/10/js%E5%B0%86Set%E9%9B%86%E5%90%88%E8%BD%AC%E6%8D%A2%E4%B8%BAArray%E6%95%B0%E7%BB%84/","photos":[]},{"tags":[{"name":"合并多个iconfont字体图标","slug":"合并多个iconfont字体图标","permalink":"https://codermino.github.io/tags/%E5%90%88%E5%B9%B6%E5%A4%9A%E4%B8%AAiconfont%E5%AD%97%E4%BD%93%E5%9B%BE%E6%A0%87/"}],"title":"合并多个iconfont字体图标","date":"2020/11/10","text":"合并字体图标网站–iconmoon: https://icomoon.io/app/#/select合并流程：进上面的网站–点击import导入（分别选中你的.svg文件）—选中你要的图标 —generate一下font —然后就可点击download下载了 生成的文件夹fonts有 .eot .svg .ttf .woff .woff2 （unicode方式使用的字体图标） 修改 (font-class方式使用字体图标。)// font-class方式依赖这些文件（.eot .svg .ttf .woff .woff2 ），不能删除将style.css 改为iconfont.css// 如果style.css 和.eot .svg .ttf .woff .woff2 的文件夹路径不一样得修改，如下 合并并不是很好的方法，将你加入iconfont图标项目，进行添加才是最好的","permalink":"https://codermino.github.io/2020/11/10/%E5%90%88%E5%B9%B6%E5%A4%9A%E4%B8%AAiconfont%E5%AD%97%E4%BD%93%E5%9B%BE%E6%A0%87/","photos":[]},{"tags":[{"name":"vue动态绑定style","slug":"vue动态绑定style","permalink":"https://codermino.github.io/tags/vue%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9Astyle/"}],"title":"vue动态绑定style","date":"2020/11/10","text":"对象语法&lt;h2 :style&#x3D;&quot;&#123;fontSize: finalSize + &#39;px&#39;, backgroundColor: finalColor&#125;&quot;&gt;&#123;&#123;message&#125;&#125;&lt;&#x2F;h2&gt; 如果键值对比较长，也可以把键值对写到方法里面。 &lt;h2 :style&#x3D;&quot;getStyles()&quot;&gt;&#123;&#123;message&#125;&#125;&lt;&#x2F;h2&gt; const app &#x3D; new Vue(&#123; el: &#39;#app&#39;, data: &#123; message: &#39;你好啊&#39;, finalSize: 100, finalColor: &#39;red&#39;, &#125;, methods: &#123; getStyles: function () &#123; return &#123;fontSize: this.finalSize + &#39;px&#39;, backgroundColor: this.finalColor&#125; &#125; &#125; &#125;) 数组语法&lt;h2 :style&#x3D;&quot;[baseStyle, baseStyle1]&quot;&gt;&#123;&#123;message&#125;&#125;&lt;&#x2F;h2&gt; const app &#x3D; new Vue(&#123; el: &#39;#app&#39;, data: &#123; message: &#39;你好啊&#39;, baseStyle: &#123;backgroundColor: &#39;red&#39;&#125;, baseStyle1: &#123;fontSize: &#39;100px&#39;&#125;, &#125; &#125;) 对象语法例子&#x2F;&#x2F;html &lt;div class&#x3D;&quot;service&quot;&gt; &lt;a :href&#x3D;&quot;&#39;tel:&#39; + storetel&quot; :style&#x3D;&quot;serverimg&quot;&gt;&lt;&#x2F;a&gt; &lt;img src&#x3D;&quot;..&#x2F;assets&#x2F;service.png&quot; alt&#x3D;&quot;暂无图片&quot; class&#x3D;&quot;service-img&quot;&gt; &lt;&#x2F;div&gt; &#x2F;&#x2F;js storetel:&#39;&#39;, serverimg: &#123; display: &#39;block&#39;, backgroundImage: &quot;url(&quot; + require(&#39;..&#x2F;assets&#x2F;service.png&#39;) + &quot;)&quot;, backgroundRepeat: &quot;no-repeat&quot;, backgroundSize: &quot;content&quot;, marginTop: &quot;5px&quot;, width: &quot;88px&quot;, height: &quot;73px&quot;, marginLeft: &quot;40px&quot; &#125;, 数组语法例子&lt;div class&#x3D;&quot;right userPicture&quot; :style&#x3D;&quot;[&#123;&#39;background&#39;:&#96;url($&#123;userImg&#125;) no-repeat center&#96;&#125;,&#123;&#39;background-size&#39;: &#39;cover&#39;&#125;]&quot;&gt;&lt;&#x2F;div&gt; &#96;&#96;&#96; ### Demo &#96;&#96;&#96;vue v-bind:style&#x3D;&quot;&#123;background: &#39;url(&#39; + list.Cover + &#39;)&#39;&#125;&quot; background: &#39;linear-gradient(#8DA7C5,&#39;+backgroundColor+&#39;)&#39; &lt;div class&#x3D;&quot;cover-bg&quot; :style&#x3D;&quot;&#123;backgroundImage: &#39;url(&#39; + playlist.coverImgUrl + &#39;)&#39;&#125;&quot;&gt;","permalink":"https://codermino.github.io/2020/11/10/vue%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9Astyle/","photos":[]},{"tags":[{"name":"vue动态绑定class","slug":"vue动态绑定class","permalink":"https://codermino.github.io/tags/vue%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9Aclass/"}],"title":"vue动态绑定class","date":"2020/11/10","text":"对象方法 最简单的绑定（这里的active加不加单引号都可以，以下也一样都能渲染）:class&#x3D;&quot;&#123; &#39;active&#39;: isActive &#125;&quot; 判断是否绑定一个active:class&#x3D;&quot;&#123;&#39;active&#39;:isActive&#x3D;&#x3D;-1&#125;&quot; 或者 :class&#x3D;&quot;&#123;&#39;active&#39;:isActive&#x3D;&#x3D;index&#125;&quot; 绑定并判断多个第一种（用逗号隔开） :class&#x3D;&quot;&#123; &#39;active&#39;: isActive, &#39;sort&#39;: isSort &#125;&quot; 第二种（放在data里面） &#x2F;&#x2F;也可以把后面绑定的对象写在一个变量放在data里面，可以变成下面这样 :class&#x3D;&quot;classObject&quot; data() &#123; return &#123; classObject:&#123; active: true, sort:false &#125; &#125; &#125; 第三种（使用computed属性） :class&#x3D;&quot;classObject&quot; data() &#123; return &#123; isActive: true, isSort: false &#125; &#125;, computed: &#123; classObject: function () &#123; return &#123; active: this.isActive, sort:this.isSort &#125; &#125; &#125; 数组方法 单纯数组:class&#x3D;&quot;[isActive,isSort]&quot; data() &#123; return&#123; isActive:&#39;active&#39;, isSort:&#39;sort&#39; &#125; &#125; 数组与三元运算符结合判断选择需要的class（注意：三元运算符后面的“：”两边的class需要加上单引号，否则不能正确渲染）:class&#x3D;&quot;[isActive?&#39;active&#39;:&#39;&#39;]&quot; 或者 :class&#x3D;&quot;[isActive&#x3D;&#x3D;1?&#39;active&#39;:&#39;&#39;]&quot; 或者 :class&#x3D;&quot;[isActive&#x3D;&#x3D;index?&#39;active&#39;:&#39;&#39;]&quot; 或者 :class&#x3D;&quot;[isActive&#x3D;&#x3D;index?&#39;active&#39;:&#39;otherActiveClass&#39;]&quot; 数组对象结合动态判断&#x2F;&#x2F;前面这个active在对象里面可以不加单引号，后面这个sort要加单引号 :class&#x3D;&quot;[&#123; active: isActive &#125;, &#39;sort&#39;]&quot; 或者 :class&#x3D;&quot;[&#123; active: isActive&#x3D;&#x3D;1 &#125;, &#39;sort&#39;]&quot; 或者 :class&#x3D;&quot;[&#123; active: isActive&#x3D;&#x3D;index &#125;, &#39;sort&#39;]&quot;","permalink":"https://codermino.github.io/2020/11/10/vue%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9Aclass/","photos":[]},{"tags":[{"name":"vue记住密码功能","slug":"vue记住密码功能","permalink":"https://codermino.github.io/tags/vue%E8%AE%B0%E4%BD%8F%E5%AF%86%E7%A0%81%E5%8A%9F%E8%83%BD/"}],"title":"vue记住密码功能","date":"2020/11/10","text":"安装依赖依赖组件：base64 // 安装 npm install --save js-base64 // 引入 const Base64 = require('js-base64').Base64 实现功能&lt;template&gt; &lt;form class&#x3D;&quot;main&quot;&gt; &lt;!-- 账号 --&gt; &lt;div class&#x3D;&quot;item&quot;&gt; &lt;label for&#x3D;&quot;account&quot;&gt;账号&lt;&#x2F;label&gt; &lt;input type&#x3D;&quot;text&quot; style&#x3D;&quot;display:none&quot; &#x2F;&gt; &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;loginForm.account&quot; id&#x3D;&quot;account&quot; &#x2F;&gt; &lt;&#x2F;div&gt; &lt;!--密码--&gt; &lt;div class&#x3D;&quot;item&quot;&gt; &lt;label for&#x3D;&quot;password&quot;&gt;密码&lt;&#x2F;label&gt; &lt;input type&#x3D;&quot;password&quot; style&#x3D;&quot;display:none&quot; &#x2F;&gt; &lt;input type&#x3D;&quot;password&quot; v-model&#x3D;&quot;loginForm.password&quot; id&#x3D;&quot;password&quot; &#x2F;&gt; &lt;&#x2F;div&gt; &lt;!-- 记住密码 --&gt; &lt;div class&#x3D;&quot;item&quot;&gt; &lt;label&gt;记住密码&lt;&#x2F;label&gt; &lt;input type&#x3D;&quot;checkbox&quot; v-model&#x3D;&quot;loginForm.remember&quot; &#x2F;&gt; &lt;&#x2F;div&gt; &lt;!--登录按钮--&gt; &lt;button @click&#x3D;&quot;submit&quot;&gt;登录&lt;&#x2F;button&gt; &lt;&#x2F;form&gt; &lt;&#x2F;template&gt; &lt;script&gt; &#x2F;&#x2F; 引入base64 const Base64 &#x3D; require(&quot;js-base64&quot;).Base64; export default &#123; data() &#123; return &#123; &#x2F;&#x2F; 登陆表单 loginForm: &#123; account: &quot;&quot;, password: &quot;&quot;, remember: &quot;&quot;, &#125;, &#125;; &#125;, created() &#123; &#x2F;&#x2F; 在页面加载时从cookie获取登录信息 let account &#x3D; this.getCookie(&quot;account&quot;); let password &#x3D; Base64.decode(this.getCookie(&quot;password&quot;)); console.log(password); &#x2F;&#x2F; 如果存在赋值给表单，并且将记住密码勾选 if (account) &#123; this.loginForm.account &#x3D; account; this.loginForm.password &#x3D; password; this.loginForm.remember &#x3D; true; &#125; &#125;, methods: &#123; &#x2F;&#x2F; 登录 submit: function () &#123; &#x2F;&#x2F; &#x2F;&#x2F; 点击登陆向后台提交登陆信息 &#x2F;&#x2F; axios.post(&quot;url&quot;, this.loginForm).then((res) &#x3D;&gt; &#123; &#x2F;&#x2F; &#x2F;&#x2F; 储存token（需要封装拦截器，将token放入请求头中） &#x2F;&#x2F; this.setCookie(&quot;token&quot;, res.token); &#x2F;&#x2F; &#x2F;&#x2F; 跳转到首页 &#x2F;&#x2F; this.$router.push(&quot;&#x2F;Index&quot;); &#x2F;&#x2F; &#x2F;&#x2F; 储存登录信息 &#x2F;&#x2F; this.setUserInfo(); &#x2F;&#x2F; &#125;); &#x2F;&#x2F; 储存token（需要封装拦截器，将token放入请求头中） this.setCookie(&quot;token&quot;, &quot;1234567890&quot;); &#x2F;&#x2F; 跳转到首页 this.$router.push(&quot;&#x2F;&quot;); &#x2F;&#x2F; 储存登录信息 this.setUserInfo(); &#125;, &#x2F;&#x2F; 储存表单信息 setUserInfo: function () &#123; &#x2F;&#x2F; 判断用户是否勾选记住密码，如果勾选，向cookie中储存登录信息， &#x2F;&#x2F; 如果没有勾选，储存的信息为空 if (this.loginForm.remember) &#123; this.setCookie(&quot;account&quot;, this.loginForm.account, 7); &#x2F;&#x2F; base64加密密码 let passWord &#x3D; Base64.encode(this.loginForm.password); this.setCookie(&quot;password&quot;, passWord, 7); this.setCookie(&quot;remember&quot;, this.loginForm.remember, 7); &#125; else &#123; this.setCookie(&quot;account&quot;, &quot;&quot;); this.setCookie(&quot;password&quot;, &quot;&quot;); &#125; &#125;, &#x2F;&#x2F; 获取cookie getCookie: function (key) &#123; if (document.cookie.length &gt; 0) &#123; var start &#x3D; document.cookie.indexOf(key + &quot;&#x3D;&quot;); if (start !&#x3D;&#x3D; -1) &#123; start &#x3D; start + key.length + 1; var end &#x3D; document.cookie.indexOf(&quot;;&quot;, start); if (end &#x3D;&#x3D;&#x3D; -1) end &#x3D; document.cookie.length; return unescape(document.cookie.substring(start, end)); &#125; &#125; return &quot;&quot;; &#125;, &#x2F;&#x2F; 保存cookie setCookie: function (cName, value, expiredays) &#123; var exdate &#x3D; new Date(); exdate.setDate(exdate.getDate() + expiredays); document.cookie &#x3D; cName + &quot;&#x3D;&quot; + decodeURIComponent(value) + (expiredays &#x3D;&#x3D; null ? &quot;&quot; : &quot;;expires&#x3D;&quot; + exdate.toGMTString()); &#125;, &#x2F;&#x2F;清除cookie clearCookie: function () &#123; this.setCookie(&quot;username&quot;, &quot;&quot;, -1); &#125;, &#125;, &#125;; &lt;&#x2F;script&gt; &lt;style&gt; .main &#123; width: 300px; &#125; .main .item &#123; display: flex; align-items: center; line-height: 30px; &#125; .main .item label &#123; width: 100px; &#125; &lt;&#x2F;style&gt;","permalink":"https://codermino.github.io/2020/11/10/vue%E8%AE%B0%E4%BD%8F%E5%AF%86%E7%A0%81%E5%8A%9F%E8%83%BD/","photos":[]},{"tags":[{"name":"iview的table组件自定义样式","slug":"iview的table组件自定义样式","permalink":"https://codermino.github.io/tags/iview%E7%9A%84table%E7%BB%84%E4%BB%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%B7%E5%BC%8F/"}],"title":"iview的table组件自定义样式","date":"2020/11/10","text":"将iview的table改为透明的第一步：改背景色table的head和body均要修改修改滚动条样式","permalink":"https://codermino.github.io/2020/11/10/iview%E7%9A%84table%E7%BB%84%E4%BB%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%B7%E5%BC%8F/","photos":[]},{"tags":[{"name":"vue中侦听器watch时调用this时出现undefined问题","slug":"vue中侦听器watch时调用this时出现undefined问题","permalink":"https://codermino.github.io/tags/vue%E4%B8%AD%E4%BE%A6%E5%90%AC%E5%99%A8watch%E6%97%B6%E8%B0%83%E7%94%A8this%E6%97%B6%E5%87%BA%E7%8E%B0undefined%E9%97%AE%E9%A2%98/"}],"title":"vue中侦听器watch时调用this时出现undefined问题","date":"2020/11/10","text":"错误用法&lt;template&gt; &lt;div class&#x3D;&quot;watch&quot;&gt; &#123;&#123;current&#125;&#125; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default &#123; name: &quot;watch&quot;, watch: &#123; current:&#123; &#x2F;&#x2F; 这里不能使用箭头函数 handler: (newName,oldName)&#x3D;&gt;&#123; this.current &#x3D; 10 &#125;, immediate:true &#x2F;&#x2F;true就表示会立即执行 &#125; &#125;, data() &#123; return &#123; current: 0 &#125; &#125;, &#125; &lt;&#x2F;script&gt; 正确用法&lt;template&gt; &lt;div class&#x3D;&quot;watch&quot;&gt; &#123;&#123;current&#125;&#125; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default &#123; name: &quot;watch&quot;, watch: &#123; current:&#123; &#x2F;&#x2F; handler:function(newName,oldName)&#123; &#x2F;&#x2F; 或者 handler(newName,oldName)&#123; this.current &#x3D; 10 &#125;, immediate:true &#x2F;&#x2F;true就表示会立即执行 &#125; &#125;, data() &#123; return &#123; current: 0 &#125; &#125;, &#125; &lt;&#x2F;script&gt; 官网解释注意，不应该使用箭头函数来定义 watcher 函数 (例如 searchQuery: newValue =&gt; this.updateAutocomplete(newValue))。 理由是箭头函数绑定了父级作用域的上下文， 所以 this 将不会按照期望指向 Vue 实例， this.updateAutocomplete 将是 undefined。","permalink":"https://codermino.github.io/2020/11/10/vue%E4%B8%AD%E4%BE%A6%E5%90%AC%E5%99%A8watch%E6%97%B6%E8%B0%83%E7%94%A8this%E6%97%B6%E5%87%BA%E7%8E%B0undefined%E9%97%AE%E9%A2%98/","photos":[]},{"tags":[{"name":"vue里dom节点和window对象","slug":"vue里dom节点和window对象","permalink":"https://codermino.github.io/tags/vue%E9%87%8Cdom%E8%8A%82%E7%82%B9%E5%92%8Cwindow%E5%AF%B9%E8%B1%A1/"}],"title":"vue里dom节点和window对象","date":"2020/11/10","text":"一、window对象 首先window对象是浏览器下的默认对象，也就是全局对象，在没有明确指向的时候this指向window。 即使切换路由，window对象里面的属性和方法依旧会保留。 因此可以在控制栏直接输入this、window、self都可以直接打印window对象。 window对象很很多默认的方法和属性。 一切全局变量和方法都是window的属性和方法，也就是只要没有指定作用域就会赋值给window。&lt;script type=\"text/javascript\"&gt; var name = \"chunlynn\"; this.sex = \"man\"; // 这里的this就是隐式的window对象，相当于 sex = \"man\"; age = 27; &lt;/script&gt; 像这种name、this、age都挂载到了window对象上，成为了window对象的属性。 即使用了框架，比如vue，jQuery，也只是在window下挂载一个对象， 比如引入jQuery之后就会在全局挂载一个$的对象。 还是可以直接通过window调用全局属性和方法。 在vue中，因为用webpack打包，每个vue都是单独的模块， 所以需要window._this=1 这样才能够引入window对象。 而且需要定义在相应的script中。 这样就可以在控制台直接用_this得到这个变量。 二、dom元素* vue中最好不要直接操作dom元素的。因为vue是用虚拟dom树就行插入的。首先数据发生改变，就会经过 Data 处理，然后Dep会发出通知(notify)， 告诉 Watcher 有数据发生了变化，接着 Watcher 会传达给渲染函数跟他说有数据变化了， 可以渲染视图了(数据驱动视图)，进而渲染函数执行render 方法去更新 VNODE， 也就是我们说的虚拟DOM，最后虚拟DOM根据最优算法，去局部更新需要渲染的视图。 vue中对dom节点的操作一般是用ref来完成的。 ref 加在普通的元素上，用this.$refs.name 获取到的是dom元素， 和原生的document.get(ID)获得的dom元素一样， 拥有这个dom元素的默认属性，像innertext这种，而ref 加在组件上， 用this.$refs.name 获取到的是vue组件实例， 可以使用组件的所有属性和方法。此时的结果是一个字典序列， 可以直接this.$refs.name[用到的属性]来获取并且更改。 但是ref的对象是一个for循环的数组，里面每一个元素就是vue对象，也是字典序列。 这里因为ref的对象是一个li，所以每一个元素都是li对象。 ref 需要在dom渲染完成后才会有，在使用的时候确保dom已经渲染完成。 比如在生命周期 mounted(){} 钩子中调用，或者在 this.$nextTick(()=&gt;{}) 中调用。 如果是自定义的组件，甚至可以通过ref调用emit(A)来实现@ A=”实现A”的方法。 其实子组件包括第三方组件的api，也就是组件真正实现的地方定义的方法和属性， 都可以在用ref获得这个组件的方法后，自己模拟实现。","permalink":"https://codermino.github.io/2020/11/10/vue%E9%87%8Cdom%E8%8A%82%E7%82%B9%E5%92%8Cwindow%E5%AF%B9%E8%B1%A1/","photos":[]},{"tags":[{"name":"js向对象中无添加属性有则替换","slug":"js向对象中无添加属性有则替换","permalink":"https://codermino.github.io/tags/js%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%AD%E6%97%A0%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7%E6%9C%89%E5%88%99%E6%9B%BF%E6%8D%A2/"}],"title":"js向对象中无添加属性有则替换","date":"2020/11/10","text":"js文件/** * 判断数组对象中是否有某个对象，有则替换无则添加 * @param &#123;*&#125; initialArr 源数组 * @param &#123;*&#125; obj 判定的对象 * @param &#123;*&#125; pro 对象中的某个属性名（唯一，通常为id） */ export default (initialArr, obj, pro) =&gt; &#123; // 判定数据是否为数组 if (!(initialArr instanceof Array)) &#123; return '请传入正确格式的数组' &#125; // 判定数据是否为对象 if (!(obj instanceof Object)) &#123; return '请传入正确格式的对象' &#125; if (!pro) &#123; return '请传入正确格式的属性名' &#125; let index = initialArr.findIndex((val) =&gt; val[pro] === obj[pro]) // 如果有就替换 没有就添加 if (initialArr.findIndex((val) =&gt; val[pro] === obj[pro]) !== -1) &#123; initialArr.splice(index, 1, obj) &#125; else &#123; initialArr.push(obj) &#125; return initialArr &#125; // 使用：this.tableArr = formateArrObjData(this.tableArr, tempObj, tempId) // 这里的源数组如果是一维的，可以用扩展运算符、Object.assign()拷贝 引入import addOrReplaceData from '../module-components/tool/replaceOrAddData' 使用changeSearchList () &#123; const tempData = &#123; name: 'searchDepName', label: '机构名称', showValue: this.searchDepName, value: this.searchDepName &#125; this.searchList = addOrReplaceData(this.searchList, tempData, 'name') &#125;","permalink":"https://codermino.github.io/2020/11/10/js%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%AD%E6%97%A0%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7%E6%9C%89%E5%88%99%E6%9B%BF%E6%8D%A2/","photos":[]},{"tags":[{"name":"vue的props","slug":"vue的props","permalink":"https://codermino.github.io/tags/vue%E7%9A%84props/"}],"title":"vue的props","date":"2020/11/08","text":"props基本用法props:[&#39;hello&#39;] props 验证props: &#123; &#x2F;&#x2F; 基础类型检测, null意味着任何类型都行 propA: Number, &#x2F;&#x2F; 多种类型 propB: [String, Number], &#x2F;&#x2F; 必传且是String propC: &#123; type: String, required: true &#125;, &#x2F;&#x2F; 数字有默认值 propD: &#123; type: Number, default: 101 &#125;, &#x2F;&#x2F; 数组、默认值是一个工厂函数返回对象 propE: &#123; type: Object, default: function() &#123; console.log(&quot;propE default invoked.&quot;); return &#123; message: &quot;I am from propE.&quot; &#125;; &#125; &#125;, &#x2F;&#x2F; 自定义验证函数 propF: &#123; isValid: function(value) &#123; return value &gt; 100; &#125; &#125;, user: &#123; required: true, type: Array, default: () &#x3D;&gt; [] &#125;, seller: &#123; type: Object, default: function () &#123; return &#123;&#125; &#125; &#125;, sellerer: &#123; type: Object, default() &#123; return &#123;&#125; &#125; &#125;, userObject: &#123; required: true, type: Object, default: () &#x3D;&gt; &#123;&#125; &#125;, getNodeFun: &#123; &#x2F;&#x2F; 重要！！！ 在父组件中实现访问数据接口，返回根节点。 required: true, type: Function &#125;, treeProps: &#123; type: Object, default: () &#x3D;&gt; &#123; return &#123; nodeKey: &#39;id&#39;, parentCode: &#39;ctou&#39;, label: &#39;tName&#39;, isLeaf: &#39;isLeaf&#39;, disabled: &#39;disabled&#39;, children: &#39;children&#39;, &#125; &#125; &#125;, &#125; 还可以在 props 定义的数据中加入自定义验证函数，当函数返回 false 时，输出警告。比如我们把上述例子中的 childNode 的for-child-msg修改成一个对象，并包含一个名叫validator的函数，该命名是规定叫validator的，自定义函数名不会生效。 let childNode &#x3D; &#123; template: &quot;&lt;div&gt;&#123;&#123;forChildMsg&#125;&#125;&lt;&#x2F;div&gt;&quot;, props: &#123; &quot;for-child-msg&quot;: &#123; validator: function(value) &#123; return value &gt; 100; &#125; &#125; &#125; &#125; 在这里我们给for-child-msg变量设置了validator函数，并且要求传入的值必须大于 100，否则报出警告。 单向数据绑定的时候，子组件随父组件数据更新父组件 &lt;template&gt; &lt;div class&#x3D;&quot;father&quot;&gt; &lt;a-input v-model&#x3D;&quot;msg2&quot;&gt;&lt;&#x2F;a-input&gt; &lt;son2 :msg&#x3D;&quot;msg2&quot;&gt;&lt;&#x2F;son2&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; import Son2 from &#39;.&#x2F;son2&#39; export default &#123; name: &quot;father&quot;, components:&#123; Son2 &#125;, data() &#123; return &#123; msg2: &#39;父组件传递过来的data&#39; &#125; &#125; &#125; &lt;&#x2F;script&gt; 子组件 &lt;template&gt; &lt;div class&#x3D;&quot;son2&quot;&gt; &#123;&#123;msg&#125;&#125; &lt;!-- 由于定义的 sonMsg 只能接受 msg 的初始值，当父组件要传递的值变化发生时，sonMsg 无法收到更新。--&gt; &#123;&#123;sonMsg&#125;&#125; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default &#123; name: &quot;son2&quot;, props: &#123; msg: &#123; type: String, default: &#39;&#39; &#125;, &#125;, watch: &#123; msg() &#123; this.sonMsg &#x3D; this.msg; &#125; &#125;, &#x2F;&#x2F; 更加妥帖的方式是使用变量存储 prop 的初始值，并用 watch 来观察 prop 值得变化。发生变化时，更新变量的值。 &#x2F;&#x2F; computed: &#123; &#x2F;&#x2F; sonMsg() &#123; &#x2F;&#x2F; return this.msg + &quot;---sonMsg&quot;; &#x2F;&#x2F; &#125; &#x2F;&#x2F; &#125; data() &#123; return &#123; sonMsg: this.msg &#125; &#125; &#125; &lt;&#x2F;script&gt;","permalink":"https://codermino.github.io/2020/11/08/vue%E7%9A%84props/","photos":[]},{"tags":[{"name":"less语法","slug":"less语法","permalink":"https://codermino.github.io/tags/less%E8%AF%AD%E6%B3%95/"}],"title":"less语法","date":"2020/11/08","text":"可变插值上面的示例着重于使用变量来控制CSS规则中的值，但是它们也可以在其他地方使用，例如选择器名称，属性名称，URL和@import语句。 // Variables @my-selector: banner; // Usage .@&#123;my-selector&#125; &#123; font-weight: bold; line-height: 40px; margin: 0 auto; &#125; 编译为 .banner &#123; font-weight: bold; line-height: 40px; margin: 0 auto; &#125; Demo@deep: ~'&gt;&gt;&gt;'; @&#123;deep&#125; .ivu-input &#123; border: 1px solid #dcdee2; &#125;","permalink":"https://codermino.github.io/2020/11/08/less%E8%AF%AD%E6%B3%95/","photos":[]},{"tags":[{"name":"vue的sync父子组件双向绑定","slug":"vue的sync父子组件双向绑定","permalink":"https://codermino.github.io/tags/vue%E7%9A%84sync%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/"}],"title":"vue的sync父子组件双向绑定","date":"2020/11/08","text":"官方推荐使用一种update:my-prop-name的模式来替代事件触发,目的是为了优雅而不粗鲁的实现父子组件间的双向绑定！ Demo父组件 &lt;template&gt; &lt;div&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;我是父组件中的按钮&quot; @click&#x3D;&quot;show&quot;&gt; &lt;child v-show&#x3D;&quot;isShow&quot;&#x2F;&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; import child from &quot;@&#x2F;components&#x2F;child&quot; export default &#123; data() &#123; return &#123; isShow:false &#125; &#125;, components:&#123; child &#125;, methods:&#123; show()&#123; this.isShow&#x3D;true; &#125; &#125; &#125; &lt;&#x2F;script&gt; 子组件 &lt;template&gt; &lt;div&gt; 我是一个子组件，我在红色的海洋里！ &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; 接下来加个需求，在子组当中增加一个按钮，通过该按钮来将自已隐藏起来！需要借助父子之间的传值了！ 父组件&lt;template&gt; &lt;div&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;我是父组件中的按钮&quot; @click&#x3D;&quot;show&quot;&gt; &lt;child @upIsShow&#x3D;&quot;changeIsShow&quot; v-show&#x3D;&quot;isShow&quot;&#x2F;&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; import child from &quot;@&#x2F;components&#x2F;child&quot; export default &#123; data() &#123; return &#123; isShow:false &#125; &#125;, components:&#123; child &#125;, methods:&#123; show()&#123; this.isShow&#x3D;true; &#125;, changeIsShow(bol)&#123; this.isShow&#x3D;bol; &#125; &#125; &#125; &lt;&#x2F;script&gt; 子组件 &lt;template&gt; &lt;div&gt; 我是一个子组件，我在红色的海洋里！ &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;点我隐身&quot; @click&#x3D;&quot;upIsShow&quot;&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default &#123; methods:&#123; upIsShow()&#123; this.$emit(&quot;upIsShow&quot;,false); &#125; &#125; &#125; &lt;&#x2F;script&gt; 如果我要将父组件中的事@upIsShow修改为@update:isShow： &lt;child @update:isShow&#x3D;&quot;changeIsShow&quot; v-show&#x3D;&quot;isShow&quot;&#x2F;&gt; 子组件调整 upIsShow()&#123; this.$emit(&quot;update:isShow&quot;,false); &#125; 那么如果现在我将父组件的changeIsShow直接写成匿名函数 &lt;child @update:isShow&#x3D;&quot;function(bol)&#123;isShow&#x3D;bol&#125;&quot; v-show&#x3D;&quot;isShow&quot;&#x2F;&gt; 现在我将那匿名函数改成箭头函数 &lt;child @update:isShow&#x3D;&quot;bol&#x3D;&gt;isShow&#x3D;bol&quot; v-show&#x3D;&quot;isShow&quot;&#x2F;&gt; 最后我将上面那行代码做最后一次修改 &lt;child :isShow.sync&#x3D;&quot;isShow&quot; v-show&#x3D;&quot;isShow&quot;&#x2F;&gt; 至此终于涉及到了sync了。以上代码 :isShow.sync=”isShow”其实是@update:isShow=”bol=&gt;isShow=bol”语法糖。是其一种简写形式。 完整代码父组件 &lt;template&gt; &lt;div&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;我是父组件中的按钮&quot; @click&#x3D;&quot;show&quot;&gt; &lt;child :isShow.sync&#x3D;&quot;isShow&quot; v-show&#x3D;&quot;isShow&quot;&#x2F;&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; import child from &quot;@&#x2F;components&#x2F;child&quot; export default &#123; data() &#123; return &#123; isShow:false &#125; &#125;, components:&#123; child &#125;, methods:&#123; show()&#123; this.isShow&#x3D;true; &#125; &#125; &#125; &lt;&#x2F;script&gt; 子组件 &lt;template&gt; &lt;div&gt; 我是一个子组件，我在红色的海洋里！ &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;点我隐身&quot; @click&#x3D;&quot;upIsShow&quot;&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default &#123; methods:&#123; upIsShow()&#123; this.$emit(&quot;update:isShow&quot;,false); &#125; &#125; &#125; &lt;&#x2F;script&gt; Demo2父组件 &lt;template&gt; &lt;div class&#x3D;&quot;father&quot;&gt; &lt;son :msg.sync&#x3D;&quot;msg2&quot;&gt;&lt;&#x2F;son&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; import Son from &#39;.&#x2F;son&#39; export default &#123; name: &quot;father&quot;, components:&#123; Son &#125;, data() &#123; return &#123; msg2: &#39;父组件传递过来的data&#39; &#125; &#125; &#125; &lt;&#x2F;script&gt; 子组件 &lt;template&gt; &lt;div class&#x3D;&quot;son&quot;&gt; &#123;&#123;msg&#125;&#125; &lt;a-button @click&#x3D;&quot;changeMsgFather&quot;&gt;改变父组件的值&lt;&#x2F;a-button&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default &#123; name: &quot;son&quot;, props: &#123; msg: &#123; type: String, default: &#39;&#39; &#125;, &#125;, methods: &#123; changeMsgFather() &#123; this.$emit(&#39;update:msg&#39;, &#39;123&#39;) &#125; &#125;, &#125; &lt;&#x2F;script&gt; sync只是给大家伙提供了一种与父组件沟通的思路而已！所以在后面日子里，你如果只是单纯的在子组件当中修改父组件的某个数据时，建议使用sync，简单，快捷，有档次！","permalink":"https://codermino.github.io/2020/11/08/vue%E7%9A%84sync%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/","photos":[]},{"tags":[{"name":"js的switch优化","slug":"js的switch优化","permalink":"https://codermino.github.io/tags/js%E7%9A%84switch%E4%BC%98%E5%8C%96/"}],"title":"js的switch优化","date":"2020/11/07","text":"原来的switch…case语法switch(column.property) &#123; case \"money\": sums[index] = (this.sumFooter.moneySum / 100).toFixed(2)； break; case \"profit\": sums[index] = this.sumFooter.profitSum / 100; break; default: break; &#125; 优化后的switch…case语法let mapSum = &#123; 'money': function(f) &#123; return sums[index] = (f.moneySum / 100).toFixed(2) &#125;, 'profit': function(f) &#123; return sums[index] = f.profitSum / 100 &#125; &#125; let action = mapSum[column.property] if(!action) return action(somedata) Demo&lt;!DOCTYPE html&gt; &lt;html lang=\"zh-CN\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; const switchTest = (param) =&gt; &#123; let mapSum = &#123; 'money': (param) =&gt; &#123; return 'money' + param &#125;, 'profit': (param) =&gt; &#123; return 'profit' + param &#125; &#125; const temp = mapSum[param] if(temp)&#123; return temp(param) &#125;else&#123; return '无效参数' &#125; &#125; console.log(switchTest('money')) console.log(switchTest('profit')) console.log(switchTest('123')) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; Demo2 function getDrink(type) &#123; var drinks = &#123; 'coke': function() &#123; return 'Coke'; &#125;, 'pepsi': function() &#123; return 'Pepsi'; &#125;, 'lemonade': function() &#123; return 'Lemonade'; &#125;, 'default': function() &#123; return 'Default item'; &#125; &#125;; return (drinks[type] || drinks['default'])(); &#125; // called with \"dr pepper\" var drink = getDrink('dr pepper'); console.log(drink); // 'Default item'","permalink":"https://codermino.github.io/2020/11/07/js%E7%9A%84switch%E4%BC%98%E5%8C%96/","photos":[]},{"tags":[{"name":"前端自定义滚动条","slug":"前端自定义滚动条","permalink":"https://codermino.github.io/tags/%E5%89%8D%E7%AB%AF%E8%87%AA%E5%AE%9A%E4%B9%89%E6%BB%9A%E5%8A%A8%E6%9D%A1/"}],"title":"前端自定义滚动条","date":"2020/11/07","text":"自定义滚动条css样式// 滚动条样式 .menu-scrollbar::-webkit-scrollbar, .common-scrollbar::-webkit-scrollbar &#123; /*滚动条整体样式*/ width: 6px; /*高宽分别对应横竖滚动条的尺寸*/ height: 1px; &#125; // 滚动条样式1 .menu-scrollbar::-webkit-scrollbar-thumb &#123; /*滚动条里面小方块*/ border-radius: 2px; box-shadow: inset 0 0 3px rgba(0, 0, 0, 0.2); background: #808695; &#125; // 滚动条样式2 .common-scrollbar::-webkit-scrollbar-thumb &#123; /*滚动条里面小方块*/ border-radius: 2px; box-shadow: inset 0 0 3px rgba(0, 0, 0, 0.2); background: #dcdee2; &#125; 在vue中使用修改事件日期选择器的滚动条样式/deep/ .ivu-time-picker-cells-list&#123; &amp;::-webkit-scrollbar &#123; /*滚动条整体样式*/ width: 3px; /*高宽分别对应横竖滚动条的尺寸*/ height: 3px; &#125; &amp;::-webkit-scrollbar-thumb &#123; /*滚动条里面小方块*/ border-radius: 2px; box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.2); background: #808695; &#125; &#125; 修改下拉选择的滚动条样式/deep/ .ivu-select-dropdown&#123; &amp;::-webkit-scrollbar &#123; /*滚动条整体样式*/ width: 3px; /*高宽分别对应横竖滚动条的尺寸*/ height: 3px; &#125; &amp;::-webkit-scrollbar-thumb &#123; /*滚动条里面小方块*/ border-radius: 2px; box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.2); background: #808695; &#125; &#125; 修改iview的table横向滚动条样式/deep/ .ivu-table-overflowX&#123; &amp;::-webkit-scrollbar &#123; /*滚动条整体样式*/ width: 3px; /*高宽分别对应横竖滚动条的尺寸*/ height: 7px; &#125; &amp;::-webkit-scrollbar-thumb &#123; /*滚动条里面小方块*/ box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.2); background: #808695; &#125; &#125;","permalink":"https://codermino.github.io/2020/11/07/%E5%89%8D%E7%AB%AF%E8%87%AA%E5%AE%9A%E4%B9%89%E6%BB%9A%E5%8A%A8%E6%9D%A1/","photos":[]},{"tags":[{"name":"vue生成树结构","slug":"vue生成树结构","permalink":"https://codermino.github.io/tags/vue%E7%94%9F%E6%88%90%E6%A0%91%E7%BB%93%E6%9E%84/"}],"title":"vue生成树结构","date":"2020/11/07","text":"Demo1&lt;template&gt; &lt;el-tree :data&#x3D;&quot;treeData&quot; :props&#x3D;&quot;defaultProps&quot; accordion @node-click&#x3D;&quot;handleNodeClick&quot;&gt; &lt;&#x2F;el-tree&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default &#123; name: &quot;Test&quot;, data()&#123; return &#123; &#x2F;&#x2F; data : [ &#x2F;&#x2F; &#123;id:1,parentId:0,name:&quot;一级菜单A&quot;,rank:1&#125;, &#x2F;&#x2F; &#123;id:2,parentId:0,name:&quot;一级菜单B&quot;,rank:1&#125;, &#x2F;&#x2F; &#123;id:3,parentId:0,name:&quot;一级菜单C&quot;,rank:1&#125;, &#x2F;&#x2F; &#123;id:4,parentId:1,name:&quot;二级菜单A-A&quot;,rank:2&#125;, &#x2F;&#x2F; &#123;id:5,parentId:1,name:&quot;二级菜单A-B&quot;,rank:2&#125;, &#x2F;&#x2F; &#123;id:6,parentId:2,name:&quot;二级菜单B-A&quot;,rank:2&#125;, &#x2F;&#x2F; &#123;id:7,parentId:4,name:&quot;三级菜单A-A-A&quot;,rank:3&#125;, &#x2F;&#x2F; &#123;id:8,parentId:7,name:&quot;四级菜单A-A-A-A&quot;,rank:4&#125;, &#x2F;&#x2F; &#123;id:9,parentId:8,name:&quot;五级菜单A-A-A-A-A&quot;,rank:5&#125;, &#x2F;&#x2F; &#123;id:10,parentId:9,name:&quot;六级菜单A-A-A-A-A-A&quot;,rank:6&#125;, &#x2F;&#x2F; &#123;id:11,parentId:10,name:&quot;七级菜单A-A-A-A-A-A-A&quot;,rank:7&#125;, &#x2F;&#x2F; &#123;id:12,parentId:11,name:&quot;八级菜单A-A-A-A-A-A-A-A&quot;,rank:8&#125;, &#x2F;&#x2F; &#123;id:13,parentId:12,name:&quot;九级菜单A-A-A-A-A-A-A-A-A&quot;,rank:9&#125;, &#x2F;&#x2F; &#123;id:14,parentId:13,name:&quot;十级菜单A-A-A-A-A-A-A-A-A-A&quot;,rank:10&#125;, &#x2F;&#x2F; ], data1: [ &#123; &quot;id&quot;: &quot;1&quot;, &quot;ctou&quot;: &quot;JN0089&quot;, &quot;deptName&quot;: &quot;山东&quot;, &quot;ctDeptEname&quot;: &quot;人事部&quot;, &quot;ctOrgType&quot;: &quot;001&quot;, &quot;parentCode&quot;: &quot;&quot;, &quot;showNum&quot;: 1, &quot;deptStatus&quot;: &quot;1&quot;, &quot;ctOrgManager&quot;: &quot;沈腾&quot;, &quot;ctViceManager&quot;: &quot;沈腾&quot;, &quot;ctDeptLevel&quot;: &quot;1&quot;, &quot;isAsync&quot;: &quot;1&quot;, &quot;cityCode&quot;: &quot;255&quot;, &quot;provinceCode&quot;: &quot;300&quot;, &quot;parkId&quot;: &quot;济南&quot;, &quot;createDate&quot;: &quot;2020-10-23&quot;, &quot;lastChangeDate&quot;: null, &quot;deptType&quot;: &quot;001&quot;, &quot;unitAffiliaated&quot;: &quot;李鹏&quot;, &quot;chargeLeader&quot;: &quot;李鹏&quot;, &quot;deptTypeName&quot;: &quot;进入&quot;, &quot;ctOrgTypeName&quot;: null &#125;, &#123; &quot;id&quot;: &quot;2&quot;, &quot;ctou&quot;: &quot;JN0039&quot;, &quot;deptName&quot;: &quot;济南&quot;, &quot;ctDeptEname&quot;: &quot;人事部&quot;, &quot;ctOrgType&quot;: &quot;001&quot;, &quot;parentCode&quot;: &quot;JN0089&quot;, &quot;showNum&quot;: 1, &quot;deptStatus&quot;: &quot;1&quot;, &quot;ctOrgManager&quot;: &quot;沈腾&quot;, &quot;ctViceManager&quot;: &quot;沈腾&quot;, &quot;ctDeptLevel&quot;: &quot;1&quot;, &quot;isAsync&quot;: &quot;1&quot;, &quot;cityCode&quot;: &quot;255&quot;, &quot;provinceCode&quot;: &quot;300&quot;, &quot;parkId&quot;: &quot;济南&quot;, &quot;createDate&quot;: &quot;2020-10-23&quot;, &quot;lastChangeDate&quot;: null, &quot;deptType&quot;: &quot;001&quot;, &quot;unitAffiliaated&quot;: &quot;李鹏&quot;, &quot;chargeLeader&quot;: &quot;李鹏&quot;, &quot;deptTypeName&quot;: &quot;进入&quot;, &quot;ctOrgTypeName&quot;: null &#125;, &#123; &quot;id&quot;: &quot;3&quot;, &quot;ctou&quot;: &quot;JN0029&quot;, &quot;deptName&quot;: &quot;历下&quot;, &quot;ctDeptEname&quot;: &quot;人事部&quot;, &quot;ctOrgType&quot;: &quot;002&quot;, &quot;parentCode&quot;: &quot;JN0039&quot;, &quot;showNum&quot;: 1, &quot;deptStatus&quot;: &quot;1&quot;, &quot;ctOrgManager&quot;: &quot;沈腾&quot;, &quot;ctViceManager&quot;: &quot;沈腾&quot;, &quot;ctDeptLevel&quot;: &quot;1&quot;, &quot;isAsync&quot;: &quot;1&quot;, &quot;cityCode&quot;: &quot;255&quot;, &quot;provinceCode&quot;: &quot;300&quot;, &quot;parkId&quot;: &quot;济南&quot;, &quot;createDate&quot;: &quot;2020-10-23&quot;, &quot;lastChangeDate&quot;: null, &quot;deptType&quot;: &quot;002&quot;, &quot;unitAffiliaated&quot;: &quot;李鹏&quot;, &quot;chargeLeader&quot;: &quot;李鹏&quot;, &quot;deptTypeName&quot;: &quot;离开&quot;, &quot;ctOrgTypeName&quot;: null &#125;, &#123; &quot;id&quot;: &quot;4&quot;, &quot;ctou&quot;: &quot;JN0040&quot;, &quot;deptName&quot;: &quot;青岛&quot;, &quot;ctDeptEname&quot;: &quot;人事部&quot;, &quot;ctOrgType&quot;: &quot;001&quot;, &quot;parentCode&quot;: &quot;JN0089&quot;, &quot;showNum&quot;: 1, &quot;deptStatus&quot;: &quot;1&quot;, &quot;ctOrgManager&quot;: &quot;沈腾&quot;, &quot;ctViceManager&quot;: &quot;沈腾&quot;, &quot;ctDeptLevel&quot;: &quot;1&quot;, &quot;isAsync&quot;: &quot;1&quot;, &quot;cityCode&quot;: &quot;255&quot;, &quot;provinceCode&quot;: &quot;300&quot;, &quot;parkId&quot;: &quot;青岛&quot;, &quot;createDate&quot;: &quot;2020-10-23&quot;, &quot;lastChangeDate&quot;: null, &quot;deptType&quot;: &quot;001&quot;, &quot;unitAffiliaated&quot;: &quot;李鹏&quot;, &quot;chargeLeader&quot;: &quot;李鹏&quot;, &quot;deptTypeName&quot;: &quot;进入&quot;, &quot;ctOrgTypeName&quot;: null &#125;, &#123; &quot;id&quot;: &quot;5&quot;, &quot;ctou&quot;: &quot;JN0030&quot;, &quot;deptName&quot;: &quot;黄岛&quot;, &quot;ctDeptEname&quot;: &quot;人事部&quot;, &quot;ctOrgType&quot;: &quot;001&quot;, &quot;parentCode&quot;: &quot;JN0089&quot;, &quot;showNum&quot;: 1, &quot;deptStatus&quot;: &quot;1&quot;, &quot;ctOrgManager&quot;: &quot;沈腾&quot;, &quot;ctViceManager&quot;: &quot;沈腾&quot;, &quot;ctDeptLevel&quot;: &quot;1&quot;, &quot;isAsync&quot;: &quot;1&quot;, &quot;cityCode&quot;: &quot;255&quot;, &quot;provinceCode&quot;: &quot;300&quot;, &quot;parkId&quot;: &quot;济南&quot;, &quot;createDate&quot;: &quot;2020-10-23&quot;, &quot;lastChangeDate&quot;: null, &quot;deptType&quot;: &quot;001&quot;, &quot;unitAffiliaated&quot;: &quot;李鹏&quot;, &quot;chargeLeader&quot;: &quot;李鹏&quot;, &quot;deptTypeName&quot;: &quot;进入&quot;, &quot;ctOrgTypeName&quot;: null &#125; ], defaultProps: &#123; children: &#39;children&#39;, label: &#39;deptName&#39; &#125; &#x2F;&#x2F; defaultProps: &#123; &#x2F;&#x2F; children: &#39;children&#39;, &#x2F;&#x2F; label: &#39;name&#39; &#x2F;&#x2F; &#125;, &#125; &#125;, computed:&#123; treeData()&#123; &#x2F;&#x2F; let cloneData &#x3D; JSON.parse(JSON.stringify(this.data)) &#x2F;&#x2F; 对源数据深度克隆 let cloneData &#x3D; Object.assign([],this.data1) &#x2F;&#x2F; 对源数据深度克隆 return cloneData.filter(father&#x3D;&gt;&#123; &#x2F;&#x2F; let branchArr &#x3D; cloneData.filter(child&#x3D;&gt;father.id &#x3D;&#x3D;&#x3D; child.parentId) &#x2F;&#x2F;返回每一项的子级数组 let branchArr &#x3D; cloneData.filter(child&#x3D;&gt;father.ctou &#x3D;&#x3D;&#x3D; child.parentCode) &#x2F;&#x2F;返回每一项的子级数组 branchArr.length&gt;0 ? father.children &#x3D; branchArr : &#39;&#39; &#x2F;&#x2F;如果存在子级，则给父级添加一个children属性，并赋值 &#x2F;&#x2F; return father.parentId &#x3D;&#x3D;&#x3D; 0; &#x2F;&#x2F;返回第一层 return father.parentCode &#x3D;&#x3D;&#x3D; &#39;&#39;; &#x2F;&#x2F;返回第一层 &#125;); &#125; &#125;, methods:&#123; handleNodeClick(data)&#123; console.log(this.treeData) &#125; &#125; &#125; &lt;&#x2F;script&gt; &lt;!--将树形结构转为扁平结构--&gt; &lt;!--let res &#x3D; [] &#x2F;&#x2F; 用于存储递归结果（扁平数据）--&gt; &lt;!--&#x2F;&#x2F; 递归函数--&gt; &lt;!--const fn &#x3D; (source)&#x3D;&gt;&#123;--&gt; &lt;!--source.forEach(el&#x3D;&gt;&#123;--&gt; &lt;!--res.push(el)--&gt; &lt;!--el.children &amp;&amp; el.children.length&gt;0 ? fn(el.children) : &quot;&quot; &#x2F;&#x2F; 子级递归--&gt; &lt;!--&#125;)--&gt; &lt;!--&#125;--&gt; &lt;!--&#x2F;&#x2F; 树形数据--&gt; &lt;!--const arr &#x3D; [--&gt; &lt;!--&#123; id: &quot;1&quot;, rank: 1 &#125;,--&gt; &lt;!--&#123; id: &quot;2&quot;, rank: 1,--&gt; &lt;!--children:[--&gt; &lt;!--&#123; id: &quot;2.1&quot;, rank: 2 &#125;,--&gt; &lt;!--&#123; id: &quot;2.2&quot;, rank: 2 &#125;--&gt; &lt;!--]--&gt; &lt;!--&#125;,--&gt; &lt;!--&#123; id: &quot;3&quot;, rank:1,--&gt; &lt;!--children:[--&gt; &lt;!--&#123; id: &quot;3.1&quot;, rank:2,--&gt; &lt;!--children: [--&gt; &lt;!--&#123; id:&#39;3.1.1&#39;, rank:3,--&gt; &lt;!--children:[--&gt; &lt;!--&#123; id: &quot;3.1.1.1&quot;, rank: 4,--&gt; &lt;!--children:[--&gt; &lt;!--&#123; id: &quot;3.1.1.1.1&quot;, rank: 5 &#125;--&gt; &lt;!--]--&gt; &lt;!--&#125;--&gt; &lt;!--]--&gt; &lt;!--&#125;--&gt; &lt;!--]--&gt; &lt;!--&#125;--&gt; &lt;!--]--&gt; &lt;!--&#125;--&gt; &lt;!--]--&gt; &lt;!--fn(arr) &#x2F;&#x2F; 执行递归函数--&gt; &lt;!--console.log(res) &#x2F;&#x2F; 查看结果--&gt; Demo2&lt;template&gt; &lt;div class&#x3D;&quot;test2&quot;&gt; &lt;el-button @click&#x3D;&quot;getData&quot;&gt; 获取数据 &lt;&#x2F;el-button&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; import toTree from &#39;..&#x2F;util&#x2F;toTree&#39; export default &#123; name: &quot;tree2&quot;, data() &#123; return &#123; data: [ &#123; &quot;id&quot;: &quot;1&quot;, &quot;ctou&quot;: &quot;JN0089&quot;, &quot;deptName&quot;: &quot;山东&quot;, &quot;ctDeptEname&quot;: &quot;人事部&quot;, &quot;ctOrgType&quot;: &quot;001&quot;, &quot;parentCode&quot;: &quot;&quot;, &quot;showNum&quot;: 1, &quot;deptStatus&quot;: &quot;1&quot;, &quot;ctOrgManager&quot;: &quot;沈腾&quot;, &quot;ctViceManager&quot;: &quot;沈腾&quot;, &quot;ctDeptLevel&quot;: &quot;1&quot;, &quot;isAsync&quot;: &quot;1&quot;, &quot;cityCode&quot;: &quot;255&quot;, &quot;provinceCode&quot;: &quot;300&quot;, &quot;parkId&quot;: &quot;济南&quot;, &quot;createDate&quot;: &quot;2020-10-23&quot;, &quot;lastChangeDate&quot;: null, &quot;deptType&quot;: &quot;001&quot;, &quot;unitAffiliaated&quot;: &quot;李鹏&quot;, &quot;chargeLeader&quot;: &quot;李鹏&quot;, &quot;deptTypeName&quot;: &quot;进入&quot;, &quot;ctOrgTypeName&quot;: null &#125;, &#123; &quot;id&quot;: &quot;2&quot;, &quot;ctou&quot;: &quot;JN0039&quot;, &quot;deptName&quot;: &quot;济南&quot;, &quot;ctDeptEname&quot;: &quot;人事部&quot;, &quot;ctOrgType&quot;: &quot;001&quot;, &quot;parentCode&quot;: &quot;JN0089&quot;, &quot;showNum&quot;: 1, &quot;deptStatus&quot;: &quot;1&quot;, &quot;ctOrgManager&quot;: &quot;沈腾&quot;, &quot;ctViceManager&quot;: &quot;沈腾&quot;, &quot;ctDeptLevel&quot;: &quot;1&quot;, &quot;isAsync&quot;: &quot;1&quot;, &quot;cityCode&quot;: &quot;255&quot;, &quot;provinceCode&quot;: &quot;300&quot;, &quot;parkId&quot;: &quot;济南&quot;, &quot;createDate&quot;: &quot;2020-10-23&quot;, &quot;lastChangeDate&quot;: null, &quot;deptType&quot;: &quot;001&quot;, &quot;unitAffiliaated&quot;: &quot;李鹏&quot;, &quot;chargeLeader&quot;: &quot;李鹏&quot;, &quot;deptTypeName&quot;: &quot;进入&quot;, &quot;ctOrgTypeName&quot;: null &#125;, &#123; &quot;id&quot;: &quot;3&quot;, &quot;ctou&quot;: &quot;JN0029&quot;, &quot;deptName&quot;: &quot;历下&quot;, &quot;ctDeptEname&quot;: &quot;人事部&quot;, &quot;ctOrgType&quot;: &quot;002&quot;, &quot;parentCode&quot;: &quot;JN0039&quot;, &quot;showNum&quot;: 1, &quot;deptStatus&quot;: &quot;1&quot;, &quot;ctOrgManager&quot;: &quot;沈腾&quot;, &quot;ctViceManager&quot;: &quot;沈腾&quot;, &quot;ctDeptLevel&quot;: &quot;1&quot;, &quot;isAsync&quot;: &quot;1&quot;, &quot;cityCode&quot;: &quot;255&quot;, &quot;provinceCode&quot;: &quot;300&quot;, &quot;parkId&quot;: &quot;济南&quot;, &quot;createDate&quot;: &quot;2020-10-23&quot;, &quot;lastChangeDate&quot;: null, &quot;deptType&quot;: &quot;002&quot;, &quot;unitAffiliaated&quot;: &quot;李鹏&quot;, &quot;chargeLeader&quot;: &quot;李鹏&quot;, &quot;deptTypeName&quot;: &quot;离开&quot;, &quot;ctOrgTypeName&quot;: null &#125;, &#123; &quot;id&quot;: &quot;4&quot;, &quot;ctou&quot;: &quot;JN0040&quot;, &quot;deptName&quot;: &quot;青岛&quot;, &quot;ctDeptEname&quot;: &quot;人事部&quot;, &quot;ctOrgType&quot;: &quot;001&quot;, &quot;parentCode&quot;: &quot;JN0089&quot;, &quot;showNum&quot;: 1, &quot;deptStatus&quot;: &quot;1&quot;, &quot;ctOrgManager&quot;: &quot;沈腾&quot;, &quot;ctViceManager&quot;: &quot;沈腾&quot;, &quot;ctDeptLevel&quot;: &quot;1&quot;, &quot;isAsync&quot;: &quot;1&quot;, &quot;cityCode&quot;: &quot;255&quot;, &quot;provinceCode&quot;: &quot;300&quot;, &quot;parkId&quot;: &quot;青岛&quot;, &quot;createDate&quot;: &quot;2020-10-23&quot;, &quot;lastChangeDate&quot;: null, &quot;deptType&quot;: &quot;001&quot;, &quot;unitAffiliaated&quot;: &quot;李鹏&quot;, &quot;chargeLeader&quot;: &quot;李鹏&quot;, &quot;deptTypeName&quot;: &quot;进入&quot;, &quot;ctOrgTypeName&quot;: null &#125;, &#123; &quot;id&quot;: &quot;5&quot;, &quot;ctou&quot;: &quot;JN0030&quot;, &quot;deptName&quot;: &quot;黄岛&quot;, &quot;ctDeptEname&quot;: &quot;人事部&quot;, &quot;ctOrgType&quot;: &quot;001&quot;, &quot;parentCode&quot;: &quot;JN0089&quot;, &quot;showNum&quot;: 1, &quot;deptStatus&quot;: &quot;1&quot;, &quot;ctOrgManager&quot;: &quot;沈腾&quot;, &quot;ctViceManager&quot;: &quot;沈腾&quot;, &quot;ctDeptLevel&quot;: &quot;1&quot;, &quot;isAsync&quot;: &quot;1&quot;, &quot;cityCode&quot;: &quot;255&quot;, &quot;provinceCode&quot;: &quot;300&quot;, &quot;parkId&quot;: &quot;济南&quot;, &quot;createDate&quot;: &quot;2020-10-23&quot;, &quot;lastChangeDate&quot;: null, &quot;deptType&quot;: &quot;001&quot;, &quot;unitAffiliaated&quot;: &quot;李鹏&quot;, &quot;chargeLeader&quot;: &quot;李鹏&quot;, &quot;deptTypeName&quot;: &quot;进入&quot;, &quot;ctOrgTypeName&quot;: null &#125;, &#123; &quot;id&quot;: &quot;6&quot;, &quot;ctou&quot;: &quot;JN0001&quot;, &quot;deptName&quot;: &quot;北京&quot;, &quot;ctDeptEname&quot;: &quot;人事部&quot;, &quot;ctOrgType&quot;: &quot;001&quot;, &quot;parentCode&quot;: &quot;&quot;, &quot;showNum&quot;: 1, &quot;deptStatus&quot;: &quot;1&quot;, &quot;ctOrgManager&quot;: &quot;沈腾&quot;, &quot;ctViceManager&quot;: &quot;沈腾&quot;, &quot;ctDeptLevel&quot;: &quot;1&quot;, &quot;isAsync&quot;: &quot;1&quot;, &quot;cityCode&quot;: &quot;255&quot;, &quot;provinceCode&quot;: &quot;300&quot;, &quot;parkId&quot;: &quot;济南&quot;, &quot;createDate&quot;: &quot;2020-10-23&quot;, &quot;lastChangeDate&quot;: null, &quot;deptType&quot;: &quot;001&quot;, &quot;unitAffiliaated&quot;: &quot;李鹏&quot;, &quot;chargeLeader&quot;: &quot;李鹏&quot;, &quot;deptTypeName&quot;: &quot;进入&quot;, &quot;ctOrgTypeName&quot;: null &#125;, &#123; &quot;id&quot;: &quot;7&quot;, &quot;ctou&quot;: &quot;JN0002&quot;, &quot;deptName&quot;: &quot;济大&quot;, &quot;ctDeptEname&quot;: &quot;人事部&quot;, &quot;ctOrgType&quot;: &quot;001&quot;, &quot;parentCode&quot;: &quot;JN0029&quot;, &quot;showNum&quot;: 1, &quot;deptStatus&quot;: &quot;1&quot;, &quot;ctOrgManager&quot;: &quot;沈腾&quot;, &quot;ctViceManager&quot;: &quot;沈腾&quot;, &quot;ctDeptLevel&quot;: &quot;1&quot;, &quot;isAsync&quot;: &quot;1&quot;, &quot;cityCode&quot;: &quot;255&quot;, &quot;provinceCode&quot;: &quot;300&quot;, &quot;parkId&quot;: &quot;济南&quot;, &quot;createDate&quot;: &quot;2020-10-23&quot;, &quot;lastChangeDate&quot;: null, &quot;deptType&quot;: &quot;001&quot;, &quot;unitAffiliaated&quot;: &quot;李鹏&quot;, &quot;chargeLeader&quot;: &quot;李鹏&quot;, &quot;deptTypeName&quot;: &quot;进入&quot;, &quot;ctOrgTypeName&quot;: null &#125; ], treeData: [] &#125; &#125;, methods: &#123; getData() &#123; this.treeData &#x3D; toTree(this.data) console.log(this.treeData); &#125; &#125;, &#125; &lt;&#x2F;script&gt; js部分 export default function toTree(data) &#123; // 删除 所有 children,以防止多次调用 data.forEach((item) =&gt; &#123; delete item.children; &#125;); // 将数据存储为 以 id 为 KEY 的 map 索引数据列 let map = &#123;&#125;; data.forEach((item) =&gt; &#123; // map[item.id] = item; map[item.ctou] = item; &#125;); // console.log(map); let val = []; data.forEach(function (item) &#123; // 以当前遍历项，的pid,去map对象中找到索引的id // let parent = map[item.pid]; let parent = map[item.parentCode]; // 如果找到索引，那么说明此项不在顶级当中,那么需要把此项添加到，他对应的父级中 if (parent) &#123; (parent.children || (parent.children = [])).push(item); &#125; else &#123; //如果没有在map中找到对应的索引ID,那么直接把 当前的item添加到 val结果集中，作为顶级 val.push(item); &#125; &#125;); return val; &#125; Demo3&lt;template&gt; &lt;div class&#x3D;&quot;test3&quot;&gt; &lt;el-button @click&#x3D;&quot;getData&quot;&gt; 获取数据 &lt;&#x2F;el-button&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; import toTree from &#39;..&#x2F;util&#x2F;toTree2&#39; export default &#123; name: &quot;tree3&quot;, data() &#123; return &#123; data: [ &#123; id: 1, name: &quot;办公管理&quot;, pid: 0 &#125;, &#123; id: 2, name: &quot;请假申请&quot;, pid: 1 &#125;, &#123; id: 3, name: &quot;出差申请&quot;, pid: 1 &#125;, &#123; id: 4, name: &quot;请假记录&quot;, pid: 2 &#125;, &#123; id: 5, name: &quot;系统设置&quot;, pid: 0 &#125;, &#123; id: 6, name: &quot;权限管理&quot;, pid: 5 &#125;, &#123; id: 7, name: &quot;用户角色&quot;, pid: 6 &#125;, &#123; id: 8, name: &quot;菜单设置&quot;, pid: 6 &#125;, ], treeData: [] &#125; &#125;, methods: &#123; getData() &#123; this.treeData &#x3D; toTree(this.data, 0) console.log(this.treeData) &#125; &#125;, &#125; &lt;&#x2F;script&gt; js部分 export default function parentDeal(data, pid) &#123; //声明返回数组 let returnArr = []; data.forEach((item) =&gt; &#123; if (item.pid === pid) &#123; //除去最高层级的数据（id === 0） returnArr.push(item) //进入递归中处理 childrenDeal(data, item, item.id) &#125; &#125;) return returnArr; &#125; function childrenDeal(arr, itemData, itemId) &#123; //首先判断是否有子类 没有默认为空 itemData.children = itemData.children ? itemData.children : []; arr.forEach((item) =&gt; &#123; //递归条件 if (item.pid === itemId) &#123; //找到则追加至上层数据children中 itemData.children.push(item) //不断递归查找子类直到找不到子类本次递归结束才进入parentDeal函数进行下一最高层级操作 childrenDeal(arr, item, item.id) &#125; &#125;) &#125;","permalink":"https://codermino.github.io/2020/11/07/vue%E7%94%9F%E6%88%90%E6%A0%91%E7%BB%93%E6%9E%84/","photos":[]},{"tags":[{"name":"前端清除浮动","slug":"前端清除浮动","permalink":"https://codermino.github.io/tags/%E5%89%8D%E7%AB%AF%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/"}],"title":"前端清除浮动","date":"2020/11/04","text":"额外标签清除法 优点:简单易懂 缺点:添加了很多额外没用的标签破坏结构 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;额外标签 清除浮动&lt;/title&gt; &lt;style&gt; .father &#123; &#125; .big &#123; width: 200px; height: 200px; background-color: blue; float: left; &#125; .small &#123; width: 100px; height: 100px; background-color: yellow; float: left; &#125; .footer &#123; width: 400px; height: 100px; background-color: pink; &#125; /* 清除浮动 */ /* .clear &#123; clear: both; 如果清除了浮动, 父亲去自动检测孩子的高度 以最高的为准 &#125; */ &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"father\"&gt; &lt;div class=\"big\"&gt;&lt;/div&gt; &lt;div class=\"small\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- 额外标签清除浮动 --&gt; &lt;!-- &lt;div class=\"clear\"&gt;&lt;/div&gt; --&gt; &lt;div style=\"clear: both;\"&gt;&lt;/div&gt; &lt;!-- 优点:简单易懂 缺点:添加了很多额外没用的标签破坏结构 --&gt; &lt;!-- 额外标签清除浮动 --&gt; &lt;div class=\"footer\"&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; overflow清除法在父盒子里面加 overflow: hidden;优点:代码简洁;缺点:内容增多时候容易造成不会自动换行导致内容被隐藏掉 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;overflow 清除浮动&lt;/title&gt; &lt;style&gt; .father &#123; /* 在父元素这里加上 overflow :hidden; 就可以清除浮动 不是所有的浮动都要清除 谁影响就清除谁 优点:代码简洁; 缺点:内容增多时候容易造成不会自动换行导致内容被隐藏掉 无法显示需要溢出的元素; */ overflow: hidden; &#125; .big &#123; width: 200px; height: 200px; background-color: blue; float: left; &#125; .small &#123; width: 100px; height: 100px; background-color: yellow; float: left; &#125; .footer &#123; width: 400px; height: 100px; background-color: pink; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"father\"&gt; &lt;div class=\"big\"&gt;&lt;/div&gt; &lt;div class=\"small\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"footer\"&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; after伪元素清除法.clearfix:after{ /* 正常浏览器 清除浮动 / content: “”; display: block; height: 0; clear: both; visibility: hidden;}.clearfix{ *zoom: 1; / zoom 1 就是ie6 清除浮动的方法 * 是ie7以下的版本所识别 */} &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;overflow 清除浮动&lt;/title&gt; &lt;style&gt; .clearfix:after&#123; /* 正常浏览器 清除浮动 */ content: \"\"; display: block; height: 0; clear: both; visibility: hidden; &#125; .clearfix&#123; *zoom: 1; /* zoom 1 就是ie6 清除浮动的方法 * 是ie7以下的版本所识别 */ &#125; .father &#123; &#125; .big &#123; width: 200px; height: 200px; background-color: blue; float: left; &#125; .small &#123; width: 100px; height: 100px; background-color: yellow; float: left; &#125; .footer &#123; width: 400px; height: 100px; background-color: pink; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"father clearfix\"&gt; &lt;div class=\"big\"&gt;&lt;/div&gt; &lt;div class=\"small\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"footer\"&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 双伪元素标记法.clearfix:before, .clearfix:after { content: “”; display: table;}.clearfix:after { clear: both;}.clearfix { *zoom: 1;} &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;overflow 清除浮动&lt;/title&gt; &lt;style&gt; .clearfix:before, .clearfix:after &#123; content: \"\"; display: table; &#125; .clearfix:after &#123; clear: both; &#125; .clearfix &#123; *zoom: 1; &#125; .father &#123; &#125; .big &#123; width: 200px; height: 200px; background-color: blue; float: left; &#125; .small &#123; width: 100px; height: 100px; background-color: yellow; float: left; &#125; .footer &#123; width: 400px; height: 100px; background-color: pink; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"father clearfix\"&gt; &lt;div class=\"big\"&gt;&lt;/div&gt; &lt;div class=\"small\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"footer\"&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt;","permalink":"https://codermino.github.io/2020/11/04/%E5%89%8D%E7%AB%AF%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/","photos":[]},{"tags":[{"name":"前端盒子模型","slug":"前端盒子模型","permalink":"https://codermino.github.io/tags/%E5%89%8D%E7%AB%AF%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/"}],"title":"前端盒子模型","date":"2020/11/04","text":"css3盒子模型整个html页面就是由无数个盒子通过特定的布局结合在一起的，每个盒子包括内容（content）、内边距（padding）、边框（border）、外边距（margin） 关于盒子的宽高的问题标准盒子模型，也就是咋们的大哥W3C规定的盒子模型，这种情况下：css中定义的宽高 = 盒子实际内容（content）的宽高，盒子的总宽高 = css定义的宽高 + padding + border + margin 如下定义了一个盒子，css代码和html代码如下： #box&#123; width: 200px; height: 200px; margin: 10px; padding: 10px; border: solid red;/* border默认宽度是3px 所以没写直接3px了*/ &#125; &lt;div id=\"box\"&gt; 我是一个盒子 &lt;/div&gt; 在浏览器开发工具下的截图如下：]从图中可以看出:蓝色部分（200*200 )是盒子的content，绿色的是padding，黄色的是border, 深黄色是margin 但在IE浏览器中盒子的宽高计算方式会不一样：IE盒子模型也叫怪异盒模型 在该模式下，浏览器的 width 属性不是内容的宽度，而是内容、内边距和边框的宽度的总和；即在怪异模式下的盒模型，盒子的（content）宽度+内边距padding+边框border宽度=我们设置的width(height也是如此)，盒子总宽度/高度=width/height + margin = 内容区宽度/高度 + padding + border + margin。","permalink":"https://codermino.github.io/2020/11/04/%E5%89%8D%E7%AB%AF%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/","photos":[]},{"tags":[{"name":"Node.js如何设置允许跨域","slug":"Node-js如何设置允许跨域","permalink":"https://codermino.github.io/tags/Node-js%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E5%85%81%E8%AE%B8%E8%B7%A8%E5%9F%9F/"}],"title":"Node.js如何设置允许跨域","date":"2020/11/04","text":"设置允许所有域名跨域：app.all(\"*\",function(req,res,next)&#123; //设置允许跨域的域名，*代表允许任意域名跨域 res.header(\"Access-Control-Allow-Origin\",\"*\"); //允许的header类型 res.header(\"Access-Control-Allow-Headers\",\"content-type\"); //跨域允许的请求方式 res.header(\"Access-Control-Allow-Methods\",\"DELETE,PUT,POST,GET,OPTIONS\"); if (req.method.toLowerCase() == 'options') res.send(200); //让options尝试请求快速结束 else next(); &#125; 设置允许指定域名“http://www.xxx.com”跨域：app.all(\"*\",function(req,res,next)&#123; //设置允许跨域的域名，*代表允许任意域名跨域 res.header(\"Access-Control-Allow-Origin\",\"http://www.xxx.com\"); //允许的header类型 res.header(\"Access-Control-Allow-Headers\",\"content-type\"); //跨域允许的请求方式 res.header(\"Access-Control-Allow-Methods\",\"DELETE,PUT,POST,GET,OPTIONS\"); if (req.method.toLowerCase() == 'options') res.send(200); //让options尝试请求快速结束 else next(); &#125; 设置允许多个域名跨域：app.all(\"*\",function(req,res,next)&#123; if( req.headers.origin.toLowerCase() == \"http://www.xxx.com\" || req.headers.origin.toLowerCase() ==\"http://127.0.0.1\" ) &#123; //设置允许跨域的域名，*代表允许任意域名跨域 res.header(\"Access-Control-Allow-Origin\", req.headers.origin); &#125; //允许的header类型 res.header(\"Access-Control-Allow-Headers\", \"content-type\"); //跨域允许的请求方式 res.header(\"Access-Control-Allow-Methods\", \"DELETE,PUT,POST,GET,OPTIONS\"); if (req.method.toLowerCase() == 'options') res.send(200); //让options尝试请求快速结束 else next(); &#125; 如果允许的域名较多，可以将允许跨域的域名放到数组当中：app.all(\"*\",function(req,res,next)&#123; var orginList=[ \"http://www.xxx.com\", \"http://www.aaa.com\", \"http://www.bbb.com\", \"http://www.baidu.com\" ] if(orginList.includes(req.headers.origin.toLowerCase()))&#123; //设置允许跨域的域名，*代表允许任意域名跨域 res.header(\"Access-Control-Allow-Origin\",req.headers.origin); &#125; //允许的header类型 res.header(\"Access-Control-Allow-Headers\", \"content-type\"); //跨域允许的请求方式 res.header(\"Access-Control-Allow-Methods\", \"DELETE,PUT,POST,GET,OPTIONS\"); if (req.method.toLowerCase() == 'options') res.send(200); //让options尝试请求快速结束 else next(); &#125; Demo–&gt;多个域名跨域app.all('*',function (req,res,next) &#123; const allowDomains = ['http://localhost:8080','http://localhost:8804']; // console.log(req.headers); let origin ; if (typeof req.headers.referer == \"undefined\") &#123; origin = req.headers.origin; &#125;else &#123; const p = URL.parse(req.headers.referer,true); origin = p.protocol + '//' + p.host; &#125; if (allowDomains.includes(origin))&#123; //设置允许跨域的域名，*代表允许任意域名跨域 res.header(\"Access-Control-Allow-Origin\",origin); //设置允许跨域的域名，*代表允许任意域名跨域 // res.header(\"Access-Control-Allow-Origin\",originHeads); //允许的header类型 res.header('Access-Control-Allow-Headers', 'Content-Type, Content-Length, Authorization, Accept, X-Requested-With'); //跨域允许的请求方式 res.header(\"Access-Control-Allow-Methods\",\"DELETE,PUT,POST,GET,OPTIONS\"); res.header('Access-Control-Allow-Credentials', true); if (req.method.toLowerCase() === 'options') res.sendStatus(200); //让options尝试请求快速结束 else next(); &#125; &#125;);","permalink":"https://codermino.github.io/2020/11/04/Node-js%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E5%85%81%E8%AE%B8%E8%B7%A8%E5%9F%9F/","photos":[]},{"tags":[{"name":"vue基于view-design封装的删除对话框","slug":"vue基于view-design封装的删除对话框","permalink":"https://codermino.github.io/tags/vue%E5%9F%BA%E4%BA%8Eview-design%E5%B0%81%E8%A3%85%E7%9A%84%E5%88%A0%E9%99%A4%E5%AF%B9%E8%AF%9D%E6%A1%86/"}],"title":"vue基于view-design封装的删除对话框","date":"2020/11/03","text":"&lt;template&gt; &lt;Modal :value&#x3D;&quot;deleteModal&quot; width&#x3D;&quot;360&quot; :mask-closable&#x3D;&quot;false&quot;&gt; &lt;p slot&#x3D;&quot;header&quot; style&#x3D;&quot;color:#f60;text-align:left&quot;&gt; &lt;Icon type&#x3D;&quot;ios-information-circle&quot;&gt;&lt;&#x2F;Icon&gt; &lt;span&gt;删除信息&lt;&#x2F;span&gt; &lt;&#x2F;p&gt; &lt;div style&#x3D;&quot;text-align:center&quot;&gt; &lt;p&gt;确认删除所选择的信息吗？&lt;&#x2F;p&gt; &lt;&#x2F;div&gt; &lt;div slot&#x3D;&quot;footer&quot;&gt; &lt;Button type&#x3D;&quot;error&quot; @click&#x3D;&quot;confirmDel&quot;&gt;&#123;&#123;footerConfirmText&#125;&#125;&lt;&#x2F;Button&gt; &lt;Button @click&#x3D;&quot;cancelDel&quot;&gt;&#123;&#123;footerCancelText&#125;&#125;&lt;&#x2F;Button&gt; &lt;&#x2F;div&gt; &lt;&#x2F;Modal&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default &#123; name: &#39;DeleteModal&#39;, props: &#123; deleteModal: &#123; type: Boolean, default: false &#125;, footerConfirmText: &#123; type: String, default: &#39;确定&#39; &#125;, footerCancelText: &#123; type: String, default: &#39;取消&#39; &#125; &#125;, methods: &#123; confirmDel () &#123; this.$emit(&#39;confirmDel&#39;) &#125;, cancelDel () &#123; this.$emit(&#39;cancelDel&#39;) &#125; &#125; &#125; &lt;&#x2F;script&gt;","permalink":"https://codermino.github.io/2020/11/03/vue%E5%9F%BA%E4%BA%8Eview-design%E5%B0%81%E8%A3%85%E7%9A%84%E5%88%A0%E9%99%A4%E5%AF%B9%E8%AF%9D%E6%A1%86/","photos":[]},{"tags":[{"name":"vue步骤条封装","slug":"vue步骤条封装","permalink":"https://codermino.github.io/tags/vue%E6%AD%A5%E9%AA%A4%E6%9D%A1%E5%B0%81%E8%A3%85/"}],"title":"vue步骤条封装","date":"2020/11/03","text":"Steps&lt;template&gt; &lt;div class&#x3D;&quot;Steps&quot; :class&#x3D;&quot;[direction &#x3D;&#x3D;&#x3D; &#39;horizontal&#39;?&#39;steps-horizontal&#39;:&#39;steps-vertical&#39;]&quot;&gt; &lt;slot&gt;&lt;&#x2F;slot&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default &#123; name: &#39;Steps&#39;, props: &#123; &#x2F;&#x2F; 方向，默认为水平方向 horizontal:vertical direction: &#123; type: String, default: &#39;horizontal&#39; &#125; &#125; &#125; &lt;&#x2F;script&gt; &lt;style scoped lang&#x3D;&quot;less&quot;&gt; @import &quot;less&#x2F;Steps.less&quot;; &lt;&#x2F;style&gt; Step&lt;template&gt; &lt;div class&#x3D;&quot;step&quot; :class&#x3D;&quot;[&#123; &#39;step-vertical&#39;: !directionType &#125;,&#123; &#39;step-horizontal&#39;: directionType &#125;,status,statusType]&quot;&gt; &lt;i class&#x3D;&quot;iconfont&quot; :class&#x3D;&quot;icon&quot;&gt;&lt;&#x2F;i&gt; &lt;span class&#x3D;&quot;title&quot; v-if&#x3D;&quot;title&quot;&gt;&#123;&#123;title&#125;&#125;&lt;&#x2F;span&gt; &lt;span class&#x3D;&quot;content&quot; style&#x3D;&quot;margin-left: 10px&quot; v-if&#x3D;&quot;content&quot;&gt;&#123;&#123;content&#125;&#125;&lt;&#x2F;span&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default &#123; name: &#39;Step&#39;, &#x2F;&#x2F; 监听current改变，将当前的current的状态设置为status:&#39;process&#39; watch: &#123; current: &#123; handler (newValue, oldValue) &#123; this.changeCurrentStepsStatus(newValue, oldValue) &#125;, immediate: true &#125; &#125;, computed: &#123; directionType () &#123; return this.direction &#x3D;&#x3D;&#x3D; &#39;horizontal&#39; &#125;, statusType () &#123; return this.status + &#39;-&#39; + this.direction &#125; &#125;, props: &#123; &#x2F;&#x2F; 每一步的状态属性,&#39;process&#39;:&#39;error&#39;:&#39;wait&#39;:&#39;finish&#39; status: &#123; type: String, default: &#39;process&#39; &#125;, &#x2F;&#x2F; 每一步的标题 title: &#123; type: String, default: &#39;&#39; &#125;, &#x2F;&#x2F; 每一步的内容 content: &#123; type: String, default: &#39;&#39; &#125;, &#x2F;&#x2F; 当前的current current: &#123; type: Number, default: 0 &#125;, &#x2F;&#x2F; 是否自定义每一个步骤的status属性，如果自定义修改必须设置为true customStatus: &#123; type: Boolean, default: false &#125;, &#x2F;&#x2F; 图标属性，为iconfont直接是图标名称即可 icon: &#123; type: String, default: &#39;&#39; &#125;, &#x2F;&#x2F; 方向 horizontal：vertical direction: &#123; type: String, default: &#39;horizontal&#39; &#125; &#125;, methods: &#123; changeCurrentStepsStatus (currentIndex, lastIndex) &#123; this.$nextTick(() &#x3D;&gt; &#123; this.$parent.$parent.$parent.stepsContent.forEach((item, i) &#x3D;&gt; &#123; &#x2F;&#x2F; 改变当前步骤的状态为 process if (i &#x3D;&#x3D;&#x3D; currentIndex) &#123; item.status &#x3D; &#39;process&#39; &#125; &#x2F;&#x2F; 默认状态时候使用 if (!this.customStatus) &#123; if (i &#x3D;&#x3D;&#x3D; lastIndex) &#123; if (lastIndex &gt; currentIndex) &#123; item.status &#x3D; &#39;wait&#39; &#125; else &#123; item.status &#x3D; &#39;finish&#39; &#125; &#125; &#125; &#125;) &#125;) &#125; &#125; &#125; &lt;&#x2F;script&gt; &lt;style scoped lang&#x3D;&quot;less&quot;&gt; @import &quot;less&#x2F;Step.less&quot;; &lt;&#x2F;style&gt; Steps.less.Steps&#123; position: relative; z-index: 999; padding: 16px 0; &amp;.steps-horizontal&#123; //width: 70%; display: flex; align-items: center; justify-content: space-around; &#125; &amp;.steps-vertical&#123; display: inline-block; width: 15%; &#125; &#125; Step.lessi&#123; font-size: 14px; &#125; .step&#123; display: flex; align-items: center; &amp;.step-vertical&#123; margin-bottom: 32px; &#125; &amp;.step-horizontal&#123; justify-content: center; padding-bottom: 8*2px; &#125; &amp;.process&#123; color: #027D8C; font-weight: 700; &amp;-horizontal&#123; border-bottom: 3px solid #027D8C; &#125; &amp;-vertical&#123; border-right: 3px solid #027D8C; &#125; &#125; &amp;.wait&#123; color: #c0c4cc; font-weight: 700; &amp;-horizontal&#123; border-bottom: 3px solid transparent; &#125; &amp;-vertical&#123; border-right: 3px solid transparent; &#125; &#125; &amp;.error &#123; color: #ff301d; font-weight: 700; &amp;-horizontal&#123; border-bottom: 3px solid transparent; &#125; &amp;-vertical&#123; border-right: 3px solid transparent; &#125; &#125; &amp;.finish&#123; color: #21ff11; font-weight: 700; &amp;-horizontal&#123; border-bottom: 3px solid transparent; &#125; &amp;-vertical&#123; border-right: 3px solid transparent; &#125; &#125; .title, .content&#123; font-weight: 700; &#125; &#125; 使用&lt;StepContainer&gt; &lt;StepItem v-for&#x3D;&quot;(item, index) in stepsContent&quot; :key&#x3D;&quot;index&quot; :custom-status&#x3D;&quot;true&quot; :current&#x3D;&quot;current&quot; :icon&#x3D;&quot;item.icon&quot; :status&#x3D;&quot;item.status&quot; :title&#x3D;&quot;item.title&quot; :content&#x3D;&quot;item.content&quot;&gt;&lt;&#x2F;StepItem&gt; &lt;&#x2F;StepContainer&gt; stepsContent: [ &#123; title: &#39;第一步&#39;, content: &#39;批量选择车辆(1&#x2F;3)&#39;, status: &#39;process&#39; &#125;, &#123; title: &#39;第二步&#39;, content: &#39;授权(2&#x2F;3)&#39;, status: &#39;wait&#39; &#125;, &#123; title: &#39;第三步&#39;, content: &#39;授权确认(3&#x2F;3)&#39;, status: &#39;wait&#39; &#125; ] next () &#123; this.current +&#x3D; 1 this.changeOtherStepsStatus() &#125;, prev () &#123; this.current -&#x3D; 1 this.changeOtherStepsStatus() &#125;, changeOtherStepsStatus () &#123; const index &#x3D; this.current if (index &#x3D;&#x3D;&#x3D; 1) &#123; this.getAllCarPosition() &#125; this.stepsContent.forEach((item, i) &#x3D;&gt; &#123; if (i &#x3D;&#x3D;&#x3D; 0) &#123; if (this.tableData.length) &#123; item.status &#x3D; &#39;finish&#39; &#125; else &#123; item.status &#x3D; &#39;error&#39; &#125; &#125; if (i &#x3D;&#x3D;&#x3D; 1) &#123; if (this.selPosForm.position.length) &#123; item.status &#x3D; &#39;finish&#39; &#125; else &#123; item.status &#x3D; &#39;error&#39; &#125; &#125; if (i &gt; index) &#123; item.status &#x3D; &#39;wait&#39; &#125; &#125;) &#125;","permalink":"https://codermino.github.io/2020/11/03/vue%E6%AD%A5%E9%AA%A4%E6%9D%A1%E5%B0%81%E8%A3%85/","photos":[]},{"tags":[{"name":"vue基于view-design封装的底部按钮组件","slug":"vue基于view-design封装的底部按钮组件","permalink":"https://codermino.github.io/tags/vue%E5%9F%BA%E4%BA%8Eview-design%E5%B0%81%E8%A3%85%E7%9A%84%E5%BA%95%E9%83%A8%E6%8C%89%E9%92%AE%E7%BB%84%E4%BB%B6/"}],"title":"vue基于view-design封装的底部按钮组件","date":"2020/11/03","text":"&lt;template&gt; &lt;div class&#x3D;&quot;bottomButton&quot;&gt; &lt;div class&#x3D;&quot;bottom-button&quot; :class&#x3D;&quot;&#123;&#39;margin-top-20&#39;:hasMargin&#125;&quot; style&#x3D;&quot;text-align: right;&quot;&gt; &lt;Button class&#x3D;&quot;create-button margin-right-10&quot; style&#x3D;&quot;background-color:#525A6F !important;&quot; @click&#x3D;&quot;createApp&quot;&gt;&#123;&#123;confirmButtonName&#125;&#125;&lt;&#x2F;Button&gt; &lt;Button class&#x3D;&quot;cancle-button&quot; @click&#x3D;&quot;cancel&quot;&gt;&#123;&#123;cancelButtonName&#125;&#125;&lt;&#x2F;Button&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default &#123; name: &#39;bottomButton&#39;, props: &#123; confirmButtonName: &#123; type: String, default: &#39;创建&#39; &#125;, cancelButtonName: &#123; type: String, default: &#39;取消&#39; &#125;, hasMargin: &#123; type: Boolean, default: true &#125; &#125;, methods: &#123; createApp () &#123; this.$emit(&#39;clickCreate&#39;) &#125;, cancel () &#123; this.$emit(&#39;clickCancle&#39;) &#125; &#125; &#125; &lt;&#x2F;script&gt; &lt;style scoped lang&#x3D;&quot;less&quot;&gt; .create-button&#123; border-color: #525A6F !important; background-color: #525A6F !important; color: #fff !important; &amp;:hover&#123; color: #fff !important; border-color: #525A6F !important; &#125; &#125; .cancle-button&#123; background-color: #f7f7f7 !important; color: #333 !important; &amp;:hover&#123; color: #333 !important; border-color: #dcdee2 !important; background-color: #f7f7f7 !important; &#125; &#125; &lt;&#x2F;style&gt;","permalink":"https://codermino.github.io/2020/11/03/vue%E5%9F%BA%E4%BA%8Eview-design%E5%B0%81%E8%A3%85%E7%9A%84%E5%BA%95%E9%83%A8%E6%8C%89%E9%92%AE%E7%BB%84%E4%BB%B6/","photos":[]},{"tags":[{"name":"js循环异步事件返回结果","slug":"js循环异步事件返回结果","permalink":"https://codermino.github.io/tags/js%E5%BE%AA%E7%8E%AF%E5%BC%82%E6%AD%A5%E4%BA%8B%E4%BB%B6%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C/"}],"title":"js循环异步事件返回结果","date":"2020/11/03","text":"Demo描述: 功能：进行多个系统的切换，不同的系统有不同的菜单。 首先要进行，所有的routes和menu的获取 并且要在initAsyncRouter中进行 resolve([…menus, …menus2])才能完全创建所有的系统菜单路由 开始的时候调用initAsyncRouter方法，进行异步菜单和路由的初始化 获取name为defaultMenu的一个菜单，作为默认显示的菜单 获取其他系统的菜单getOtherDynamicMenus() 这个时候是一个数组，然后要循环异步获取到的数据，并且返回async function initAsyncRouter () &#123; try &#123; const menus &#x3D; await getDynamicMenus() let menus2 &#x3D; await getOtherDynamicMenus() const asyncMenuRes &#x3D; initMenuTree(menus) &#x2F;&#x2F; 添加动态获取的菜单 store.commit(&#39;app&#x2F;setMenuList&#39;, asyncMenuRes.menuList || []) &#x2F;&#x2F; 添加动态路由 store.commit(&#39;app&#x2F;updateAppRouter&#39;, asyncMenuRes.menuRoutes || []) return new Promise((resolve, reject) &#x3D;&gt; &#123; resolve([...menus, ...menus2]) &#125;) &#125; catch (error) &#123; return new Promise((resolve, reject) &#x3D;&gt; &#123; reject(error) &#125;) &#125; &#125; async function getDynamicMenus () &#123; let parentId &#x3D; localStorage.parentId if (!localStorage.parentId) &#123; await util.http.get(&#39;&#x2F;api&#x2F;system&#x2F;menu&#x2F;getMenu&#39;, &#123; params: &#123; parentId: 0 &#125; &#125;).then(response &#x3D;&gt; &#123; parentId &#x3D; response.data.data.filter((item) &#x3D;&gt; &#123; return item.name &#x3D;&#x3D;&#x3D; &#39;defaultMenu&#39; &#125;)[0].id || 0 &#125;).catch(error &#x3D;&gt; &#123; console.log(error) this.$Message.error(&#39;获取数据失败！&#39;) &#125;) &#125; return new Promise((resolve, reject) &#x3D;&gt; &#123; util.http.get(&#39;&#x2F;api&#x2F;getCscpMenusList&#x2F;&#39; + parentId).then(response &#x3D;&gt; &#123; if (response &amp;&amp; response.data.data) &#123; resolve(response.data.data) &#125; else &#123; reject(new Error(&#39;getDynamicMenus error!&#39;)) &#125; &#125;).catch(error &#x3D;&gt; &#123; reject(error) &#125;) &#125;) &#125; function getOtherDynamicMenus () &#123; let menus2 &#x3D; [] return new Promise((resolve, reject) &#x3D;&gt; &#123; util.http.get(&#39;&#x2F;api&#x2F;system&#x2F;menu&#x2F;getMenu&#39;, &#123; params: &#123; parentId: 0 &#125; &#125;).then(response &#x3D;&gt; &#123; request(menus2, response.data.data.filter(item &#x3D;&gt; item.name !&#x3D;&#x3D; &#39;defaultMenu&#39;), resolve) &#125;).catch(error &#x3D;&gt; &#123; console.log(error) this.$Message.error(&#39;获取数据失败！&#39;) &#125;) &#125;) &#125; function request (menus2, data, callback, index &#x3D; 0) &#123; if (index &lt; data.length) &#123; let item &#x3D; data[index] util.http.get(&#39;&#x2F;api&#x2F;getCscpMenusList&#x2F;&#39; + item.id).then(response &#x3D;&gt; &#123; if (response &amp;&amp; response.data.data) &#123; menus2.push(...response.data.data) const asyncMenuRes &#x3D; initMenuTree(response.data.data) &#x2F;&#x2F; 添加动态获取的菜单 store.commit(&#39;app&#x2F;setMenuList&#39;, asyncMenuRes.menuList || []) &#x2F;&#x2F; 添加动态路由 store.commit(&#39;app&#x2F;updateAppRouter&#39;, asyncMenuRes.menuRoutes || []) request(menus2, data, callback, index + 1) &#125; else &#123; console.log(new Error(&#39;getDynamicMenus error!&#39;)) &#125; &#125;).catch(error &#x3D;&gt; &#123; console.log((error)) &#125;) &#125; else &#123; callback(menus2) &#125; &#125; 其他用到的方法function initMenuTree (menus) &#123; menus &#x3D; cleanData(menus) &#x2F;&#x2F; map映射 const menusMap &#x3D; new Map() for (let i &#x3D; 0; i &lt; menus.length; i++) &#123; menusMap.set(menus[i].id, true) &#125; const tree &#x3D; [] let leaves &#x3D; [] for (let i &#x3D; 0; i &lt; menus.length; i++) &#123; if (menusMap.has(menus[i].parentId)) &#123; &#x2F;&#x2F; 叶节点 leaves.push(menus[i]) &#125; else &#123; &#x2F;&#x2F; 根节点 tree.push(menus[i]) &#125; &#125; buildTree(tree, leaves) &#x2F;&#x2F; 保存路由数据原始的关系树 store.commit(&#39;app&#x2F;setRoutesTree&#39;, tree || []) const menuList &#x3D; getMenuList(tree) const menuRoutes &#x3D; getMenuRoutes(tree) return &#123; menuList, menuRoutes &#125; &#125; &#x2F;&#x2F; 保存按钮权限 &amp; 清理无用数据 function cleanData (menus) &#123; const menusCleaned &#x3D; [] const btnPermissionCode &#x3D; [] for (let i &#x3D; 0; i &lt; menus.length; i++) &#123; if (menus[i].permissionCode) &#123; btnPermissionCode.push(menus[i].permissionCode) &#125; if (menus[i].type !&#x3D;&#x3D; &#39;button&#39;) &#123; menusCleaned.push(menus[i]) &#125; &#125; &#x2F;&#x2F; 保存按钮权限码 store.commit(&#39;app&#x2F;setBtnLimitedCodes&#39;, btnPermissionCode) return menusCleaned &#125; function buildTree (tree, leaves) &#123; leaves &#x3D; deleteUselessElement(leaves) while (leaves.length &gt; 0) &#123; leaves.forEach((leaf, index) &#x3D;&gt; &#123; if (leaf) &#123; addLeaf(tree, leaf, index, leaves) &#125; &#125;) leaves &#x3D; deleteUselessElement(leaves) &#125; &#125; function addLeaf (parents, leaf, index, leaves) &#123; for (const parent of parents) &#123; if (parent.id &#x3D;&#x3D;&#x3D; leaf.parentId) &#123; if (parent.children &amp;&amp; Array.isArray(parent.children)) &#123; parent.children.push(leaf) &#125; else &#123; parent.children &#x3D; [] parent.children.push(leaf) &#125; &#x2F;&#x2F; 将leaf标记为null leaves[index] &#x3D; null break &#125; else &#123; if (parent.children &amp;&amp; Array.isArray(parent.children)) &#123; addLeaf(parent.children, leaf, index, leaves) &#125; &#125; &#125; &#125; function deleteUselessElement (array) &#123; let temp &#x3D; [] array.forEach(ele &#x3D;&gt; &#123; if (ele) &#123; temp.push(ele) &#125; &#125;) return temp &#125; function getMenuList (menus) &#123; const tempList &#x3D; [] menus.forEach(ele &#x3D;&gt; &#123; if (ele.type &amp;&amp; ele.type.startsWith(&#39;menu&#39;)) &#123; const tempObj &#x3D; &#123;&#125; if (ele.children) &#123; tempObj.children &#x3D; getMenuList(ele.children) &#125; tempObj.name &#x3D; ele.name tempObj.icon &#x3D; ele.icon || &#39;ios-cube-outline&#39; tempObj.title &#x3D; ele.title tempObj.url &#x3D; ele.url tempList.push(tempObj) &#125; &#125;) return tempList &#125; function getMenuRoutes (tree) &#123; const menuRoutes &#x3D; buildMenuRoutesStep1(tree) &#x2F;&#x2F; 将三级路由结构改为二级 buildMenuRoutesStep2(menuRoutes) &#x2F;&#x2F; 删除无用的路由数据 buildMenuRoutesStep3(menuRoutes) return menuRoutes &#125; function buildMenuRoutesStep1 (menus) &#123; const tempRoutes &#x3D; [] menus.forEach(ele &#x3D;&gt; &#123; const tempObj &#x3D; &#123;&#125; if (ele.children) &#123; tempObj.children &#x3D; buildMenuRoutesStep1(ele.children) &#125; tempObj.parentId &#x3D; ele.parentId tempObj.path &#x3D; ele.url tempObj.name &#x3D; ele.name tempObj.meta &#x3D; &#123; title: ele.title &#125; if (ele.url) &#123; if (routeMap[ele.name]) &#123; tempObj.component &#x3D; routeMap[ele.name] &#125; else if (typeof ele.component &#x3D;&#x3D;&#x3D; &#39;string&#39; &amp;&amp; ele.component.length &gt; 0) &#123; tempObj.component &#x3D; () &#x3D;&gt; import(&#96;@&#x2F;$&#123;ele.component&#125;&#96;) &#125; &#125; else &#123; tempObj.component &#x3D; ele.component &#125; tempRoutes.push(tempObj) &#125;) return tempRoutes &#125; function buildMenuRoutesStep2 (routes, root) &#123; routes.forEach(ele &#x3D;&gt; &#123; if (ele.children) &#123; root &#x3D; ele.parentId &#x3D;&#x3D;&#x3D; 0 ? ele : root buildMenuRoutesStep2(ele.children, root) if (ele.parentId !&#x3D;&#x3D; 0) &#123; if (!ele.component) &#123; ele.children.forEach(item &#x3D;&gt; &#123; &#x2F;&#x2F; 将二级菜单的信息放入子路由中 item.meta.parentName &#x3D; ele.name &#125;) &#125; root.children &#x3D; root.children.concat(ele.children) delete ele.children &#125; &#125; &#125;) &#125; function buildMenuRoutesStep3 (routes) &#123; const temp &#x3D; [] routes.forEach((ele, index) &#x3D;&gt; &#123; if (ele.children) &#123; buildMenuRoutesStep3(ele.children) &#125; if (!ele.component || !ele.path) &#123; routes[index] &#x3D; undefined &#125; else &#123; temp.push(routes[index]) &#125; &#125;) routes.splice(0, routes.length) temp.forEach(el &#x3D;&gt; &#123; routes.push(el) &#125;) &#125;","permalink":"https://codermino.github.io/2020/11/03/js%E5%BE%AA%E7%8E%AF%E5%BC%82%E6%AD%A5%E4%BA%8B%E4%BB%B6%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C/","photos":[]},{"tags":[{"name":"vue的tree懒加载","slug":"vue的tree懒加载","permalink":"https://codermino.github.io/tags/vue%E7%9A%84tree%E6%87%92%E5%8A%A0%E8%BD%BD/"}],"title":"vue的tree懒加载","date":"2020/11/03","text":"el-tree懒加载树el-tree&lt;el-tree ref&#x3D;&quot;async-router-tree&quot; :props&#x3D;&quot;props&quot; node-key&#x3D;&quot;id&quot; :expand-on-click-node&#x3D;&quot;false&quot; :default-expanded-keys&#x3D;&quot;[0]&quot; lazy :load&#x3D;&quot;loadNode&quot; draggable @node-drag-end&#x3D;&quot;handleDragEnd&quot; :allow-drop&#x3D;&quot;allowDrop&quot; :allow-drag&#x3D;&quot;allowDrag&quot;&gt; &lt;span class&#x3D;&quot;custom-tree-node&quot; slot-scope&#x3D;&quot;&#123; node, data &#125;&quot;&gt; &lt;span&gt;&#123;&#123; node.label &#125;&#125;&lt;&#x2F;span&gt; &lt;span&gt; &lt;template v-if&#x3D;&quot;data.id &#x3D;&#x3D;&#x3D; 0&quot;&gt; &lt;Button class&#x3D;&quot;add-root-btn&quot; type&#x3D;&quot;primary&quot; size&#x3D;&quot;small&quot; icon&#x3D;&quot;ios-add&quot; @click&#x3D;&quot;editNode(node, data, &#39;append&#39;)&quot;&gt;&lt;&#x2F;Button&gt; &lt;&#x2F;template&gt; &lt;template v-else&gt; &lt;Button type&#x3D;&quot;default&quot; icon&#x3D;&quot;ios-add&quot; size&#x3D;&quot;small&quot; @click&#x3D;&quot;editNode(node, data, &#39;append&#39;)&quot;&gt;&lt;&#x2F;Button&gt; &lt;Button type&#x3D;&quot;default&quot; icon&#x3D;&quot;ios-remove&quot; size&#x3D;&quot;small&quot; @click&#x3D;&quot;removeNodeConfirmed(node, data)&quot;&gt;&lt;&#x2F;Button&gt; &lt;Button type&#x3D;&quot;default&quot; icon&#x3D;&quot;md-create&quot; size&#x3D;&quot;small&quot; @click&#x3D;&quot;editNode(node, data, &#39;update&#39;)&quot;&gt;&lt;&#x2F;Button&gt; &lt;&#x2F;template&gt; &lt;&#x2F;span&gt; &lt;&#x2F;span&gt; &lt;&#x2F;el-tree&gt; propsprops: &#123; label: &#39;title&#39;, children: &#39;children&#39; &#125;, loadNodeloadNode (node, resolve) &#123; if (node.level &#x3D;&#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; init root of tree let root &#x3D; &#123; id: 0, title: &#39;异步路由配置&#39;, parentId: null &#125; resolve([root]) &#125; else &#123; &#x2F;&#x2F; init leaves of tree this.getNodes(node.data.id).then(value &#x3D;&gt; &#123; return resolve(value) &#125;) &#125; &#125;, getNodes (parentId) &#123; return new Promise((resolve, reject) &#x3D;&gt; &#123; const msg &#x3D; this.$Message.loading(&#123; content: &#39;正在获取数据&#39;, duration: 0 &#125;) const [url, httpConfig] &#x3D; [ &#39;&#x2F;api&#x2F;system&#x2F;menu&#x2F;getMenu&#39;, &#123; params: &#123; parentId &#125; &#125; ] this.$http.get(url, httpConfig).then(response &#x3D;&gt; &#123; msg() resolve(response.data.data) &#125;).catch(error &#x3D;&gt; &#123; msg() this.$Message.error(&#39;获取数据失败！&#39;) reject(error) &#125;) &#125;) &#125;, 剩余的一些参数props: &#123; label: &#39;title&#39;, children: &#39;children&#39; &#125;, currentNode: null, isSubmitDisabled: false, isNodeEdited: false, asyncRoute: null, ruleAsyncRoute: &#123; title: [&#123; required: true, message: &#39;请填写路由标题&#39;, trigger: &#39;blur&#39; &#125;], name: [ &#123; required: true, message: &#39;请填写路由名&#39;, trigger: &#39;blur&#39; &#125;, &#123; validator: (rule, value, callback) &#x3D;&gt; &#123; let reg &#x3D; new RegExp(&#39;[\\\\u4E00-\\\\u9FFF]+&#39;, &#39;g&#39;) if (!reg.test(value)) &#123; callback() &#125; else &#123; callback(new Error(&#39;请输入合法的路由名，不能包含中文。&#39;)) &#125; &#125;, trigger: &#39;blur&#39; &#125; ], url: [ &#123; required: true, message: &#39;请填写路由访问路径&#39;, trigger: &#39;blur&#39; &#125;, &#123; validator: (rule, value, callback) &#x3D;&gt; &#123; let reg &#x3D; new RegExp(&#39;[\\\\u4E00-\\\\u9FFF]+&#39;, &#39;g&#39;) if (!reg.test(value)) &#123; callback() &#125; else &#123; callback(new Error(&#39;请输入合法的路由路径，不能包含中文。&#39;)) &#125; &#125;, trigger: &#39;blur&#39; &#125; ], component: [ &#123; required: true, message: &#39;请填写路由对应的Vue组件&#39;, trigger: &#39;blur&#39; &#125;, &#123; validator: (rule, value, callback) &#x3D;&gt; &#123; let reg &#x3D; new RegExp(&#39;[\\\\u4E00-\\\\u9FFF]+&#39;, &#39;g&#39;) if (!reg.test(value)) &#123; callback() &#125; else &#123; callback(new Error(&#39;请输入合法的组件路径，不能包含中文。&#39;)) &#125; &#125;, trigger: &#39;blur&#39; &#125; ], type: [ &#123; required: true, message: &#39;请选择该节点的数据类型&#39;, trigger: &#39;blur&#39; &#125; ] &#125; 剩余的一些方法initAsyncRoute () &#123; this.asyncRoute &#x3D; &#123; type: &#39;&#39;, name: &#39;&#39;, icon: &#39;ios-folder-outline&#39;, title: &#39;&#39;, url: &#39;&#39;, component: &#39;&#39;, permissionCode: &#39;&#39;, parentId: null, id: null, orderby: 0 &#125; &#125;, loadNode (node, resolve) &#123; if (node.level &#x3D;&#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; init root of tree let root &#x3D; &#123; id: 0, title: &#39;异步路由配置&#39;, parentId: null &#125; resolve([root]) &#125; else &#123; &#x2F;&#x2F; init leaves of tree this.getNodes(node.data.id).then(value &#x3D;&gt; &#123; return resolve(value) &#125;) &#125; &#125;, getNodes (parentId) &#123; return new Promise((resolve, reject) &#x3D;&gt; &#123; const msg &#x3D; this.$Message.loading(&#123; content: &#39;正在获取数据&#39;, duration: 0 &#125;) const [url, httpConfig] &#x3D; [ &#39;&#x2F;api&#x2F;system&#x2F;menu&#x2F;getMenu&#39;, &#123; params: &#123; parentId &#125; &#125; ] this.$http.get(url, httpConfig).then(response &#x3D;&gt; &#123; msg() resolve(response.data.data) &#125;).catch(error &#x3D;&gt; &#123; msg() this.$Message.error(&#39;获取数据失败！&#39;) reject(error) &#125;) &#125;) &#125;, editNode (node, data, act) &#123; this.currentNode &#x3D; node if (act &#x3D;&#x3D;&#x3D; &#39;append&#39;) &#123; this.initAsyncRoute() this.asyncRoute.parentId &#x3D; data.parentId &#x3D;&#x3D;&#x3D; null ? 0 : data.id &#125; else if (act &#x3D;&#x3D;&#x3D; &#39;update&#39;) &#123; this.asyncRoute &#x3D; data &#125; this.isNodeEdited &#x3D; true &#125;, removeNodeConfirmed (node, data) &#123; this.$Modal.confirm(&#123; title: &#39;警告&#39;, content: &#39;确定删除该节点（包括子节点）数据？&#39;, onOk: () &#x3D;&gt; &#123; this.deleteNode(node, data) &#125; &#125;) &#125;, deleteNode (node, data) &#123; const url &#x3D; &#96;&#x2F;api&#x2F;system&#x2F;menu&#x2F;deleteMenu&#x2F;$&#123;data.id&#125;&#96; this.$http.delete(url).then(() &#x3D;&gt; &#123; this.$Message.success(&#39;删除成功！&#39;) this.remove(node) &#125;).catch(() &#x3D;&gt; &#123; this.$Message.error(&#39;删除失败！&#39;) &#125;) &#125;, remove (node) &#123; this.$refs[&#39;async-router-tree&#39;].remove(node) &#125;, handleSubmit (name) &#123; this.$refs[name].validate(valid &#x3D;&gt; &#123; if (valid) &#123; this.isSubmitDisabled &#x3D; true const isAppendNode &#x3D; this.asyncRoute.id &#x3D;&#x3D;&#x3D; null const msg &#x3D; this.$Message.loading(&#123; content: isAppendNode ? &#39;正在添加新节点&#39; : &#39;正在更新节点&#39;, duration: 0 &#125;) const [url, data] &#x3D; [ &#39;&#x2F;api&#x2F;system&#x2F;menu&#x2F;addMenu&#39;, this.asyncRoute ] this.$http.put(url, data).then(response &#x3D;&gt; &#123; if (isAppendNode) &#123; this.asyncRoute.id &#x3D; Number(response.data.id) this.append(this.asyncRoute, this.currentNode) &#125; msg() this.$Message.success(isAppendNode ? &#39;添加节点成功！&#39; : &#39;更新节点成功！&#39;) this.isNodeEdited &#x3D; false this.isSubmitDisabled &#x3D; false &#125;).catch(() &#x3D;&gt; &#123; msg() this.isNodeEdited &#x3D; false this.isSubmitDisabled &#x3D; false this.$Message.error(isAppendNode ? &#39;添加节点失败！&#39; : &#39;更新节点失败！&#39;) &#125;) &#125; &#125;) &#125;, initPutData (node, referenceNode, dropType) &#123; const data &#x3D; this.getItemsUpdated(node, referenceNode, dropType) this.updateDragData(data) &#125;, getItemsUpdated (node, referenceNode, dropType) &#123; switch (dropType) &#123; case &#39;inner&#39;: if (referenceNode.childNodes.length &gt; 1) &#123; return this.filterItemsUpdated(referenceNode.childNodes) &#125; else &#123; node.data.parentId &#x3D; referenceNode.data.id node.data.orderby &#x3D; 0 return [node.data] &#125; case &#39;before&#39;: case &#39;after&#39;: return this.filterItemsUpdated(referenceNode.parent.childNodes, referenceNode.data.parentId) default: break &#125; &#125;, filterItemsUpdated (children, parentId) &#123; const tempArray &#x3D; [] for (let i &#x3D; 0; i &lt; children.length; i++) &#123; if (children[i].data.orderby !&#x3D;&#x3D; (i + 1)) &#123; children[i].data.orderby &#x3D; i + 1 tempArray.push(children[i].data) &#125; if (children[i].data.parentId !&#x3D;&#x3D; parentId) &#123; children[i].data.parentId &#x3D; parentId if (!tempArray.includes(children[i].data)) &#123; tempArray.push(children[i].data) &#125; &#125; &#125; return tempArray &#125;, updateDragData (data) &#123; const url &#x3D; &#39;&#x2F;api&#x2F;system&#x2F;menu&#x2F;updateMenu&#39; this.$http.put(url, data).catch(() &#x3D;&gt; &#123; this.$Message.error(&#39;拖拽的节点数据更新失败，请刷新数据重新尝试！&#39;) &#125;) &#125;, append (data, node) &#123; this.$refs[&#39;async-router-tree&#39;].append(data, node) &#125;, cancel () &#123; this.isNodeEdited &#x3D; false &#125;, handleDragEnd (draggingNode, dropNode, dropType, ev) &#123; if (dropType !&#x3D;&#x3D; &#39;none&#39;) &#123; &#x2F;&#x2F; drag success this.initPutData(draggingNode, dropNode, dropType) &#125; &#125;, allowDrop (draggingNode, dropNode, type) &#123; if (draggingNode.data.parentId &#x3D;&#x3D;&#x3D; 0 &amp;&amp; dropNode.data.parentId &#x3D;&#x3D;&#x3D; 0 &amp;&amp; type &#x3D;&#x3D;&#x3D; &#39;inner&#39;) &#123; &#x2F;&#x2F; 一级菜单节点不允许降为二、三级节点 return false &#125; else if (draggingNode.data.parentId !&#x3D;&#x3D; 0 &amp;&amp; !!!dropNode.data.parentId) &#123; &#x2F;&#x2F; 非一级节点不允许拖拽成为一级节点 return false &#125; else if (dropNode.data.id &#x3D;&#x3D;&#x3D; 0) &#123; return type &#x3D;&#x3D;&#x3D; &#39;inner&#39; &#125; else &#123; return true &#125; &#125;, allowDrag (draggingNode) &#123; return draggingNode.data.id !&#x3D;&#x3D; 0 &#125; &#125;, created () &#123; this.initAsyncRoute() &#125; tree的Demo1描述： 一开始请求第一级节点并且将第一级节点展开，并且记录下node和node.childNodes 并且this.tableData = value用于右侧表格展示数据 点击左侧的树(tree)请求数据，并且记录下currentNode和nodeList 在编辑、添加和修改的时候操作node和nodeList即可 结构*&lt;Modal title&#x3D;&quot;删除数据&quot; :mask-closable&#x3D;&quot;false&quot; v-model&#x3D;&quot;showModal&quot; @on-ok&#x3D;&quot;confirmDel&quot; @on-cancel&#x3D;&quot;cancelDel&quot; &gt; &lt;p style&#x3D;&quot;color: red;&quot;&gt;确认删除该条信息?&lt;&#x2F;p&gt; &lt;&#x2F;Modal&gt; &lt;Modal v-model&#x3D;&quot;addmodalshow&quot; :title&#x3D;&quot;title&quot; :mask-closable&#x3D;&quot;false&quot;&gt; &lt;Form :model&#x3D;&quot;editformData&quot; :label-width&#x3D;&quot;80&quot;&gt; &lt;FormItem label&#x3D;&quot;分类名称&quot;&gt; &lt;Input v-model&#x3D;&quot;editformData.catalogname&quot;&gt;&lt;&#x2F;Input&gt; &lt;&#x2F;FormItem&gt; &lt;FormItem label&#x3D;&quot;备注&quot;&gt; &lt;Input v-model&#x3D;&quot;editformData.remarks&quot; type&#x3D;&quot;textarea&quot;&gt;&lt;&#x2F;Input&gt; &lt;&#x2F;FormItem&gt; &lt;FormItem label&#x3D;&quot;排序字段&quot;&gt; &lt;Input v-model&#x3D;&quot;editformData.ordernum&quot; type&#x3D;&quot;number&quot;&gt;&lt;&#x2F;Input&gt; &lt;&#x2F;FormItem&gt; &lt;&#x2F;Form&gt; &lt;div slot&#x3D;&quot;footer&quot;&gt; &lt;bottom-button :confirmButtonName&#x3D;&quot;confirmButtonName&quot; :hasMargin&#x3D;&quot;false&quot; @clickCreate&#x3D;&quot;ok&quot; @clickCancle&#x3D;&quot;cancel&quot;&gt;&lt;&#x2F;bottom-button&gt; &lt;&#x2F;div&gt; &lt;&#x2F;Modal&gt; &lt;div class&#x3D;&quot;container&quot;&gt; &lt;Card class&#x3D;&quot;card-tree&quot;&gt; &lt;el-tree @node-click&#x3D;&quot;clickNode&quot; ref&#x3D;&quot;tree&quot; :props&#x3D;&quot;props&quot; node-key&#x3D;&quot;id&quot; :expand-on-click-node&#x3D;&quot;true&quot; :default-expanded-keys&#x3D;&quot;defaultExpandsId&quot; lazy :load&#x3D;&quot;loadNode&quot;&gt; &lt;span class&#x3D;&quot;custom-tree-node&quot; slot-scope&#x3D;&quot;&#123; node, data &#125;&quot;&gt; &#123;&#123;data.catalogname&#125;&#125; &lt;&#x2F;span&gt; &lt;&#x2F;el-tree&gt; &lt;&#x2F;Card&gt; &lt;Card class&#x3D;&quot;table-content&quot;&gt; &lt;Row style&#x3D;&quot;text-align: right&quot; class&#x3D;&quot;margin-bottom-10&quot;&gt; &lt;Button type&#x3D;&quot;primary&quot; class&#x3D;&quot;blue-button&quot; @click&#x3D;&quot;addApp&quot;&gt;添加应用&lt;&#x2F;Button&gt; &lt;&#x2F;Row&gt; &lt;Table :columns&#x3D;&quot;columns1&quot; :data&#x3D;&quot;tableData.slice((currentPage-1)*5,5*currentPage)&quot;&gt; &lt;template slot-scope&#x3D;&quot;&#123; row, index &#125;&quot; slot&#x3D;&quot;action&quot;&gt; &lt;Button class&#x3D;&quot;blue-button&quot; type&#x3D;&quot;primary&quot; size&#x3D;&quot;small&quot; style&#x3D;&quot;margin-right: 5px&quot; @click&#x3D;&quot;edit(row, index)&quot;&gt;编辑&lt;&#x2F;Button&gt; &lt;Button class&#x3D;&quot;red-button&quot; type&#x3D;&quot;primary&quot; size&#x3D;&quot;small&quot; @click&#x3D;&quot;deleteRow(row,index)&quot;&gt;删除&lt;&#x2F;Button&gt; &lt;&#x2F;template&gt; &lt;&#x2F;Table&gt; &lt;Page style&#x3D;&quot;text-align: right;&quot; class&#x3D;&quot;margin-top-10&quot; :total&#x3D;&quot;tableData.length&quot; :page-size&#x3D;&quot;5&quot; @on-change&#x3D;&quot;pageChange&quot;&#x2F;&gt; &lt;&#x2F;Card&gt; &lt;&#x2F;div&gt; 数据*props: &#123; label: &#39;catalogname&#39;, children: &#39;children&#39; &#125;, defaultExpandsId: [], columns1: [ &#123; type: &#39;index&#39;, title: &#39;序号&#39;, align: &#39;center&#39; &#125;, &#123; title: &#39;分类名称&#39;, key: &#39;catalogname&#39;, align: &#39;center&#39; &#125;, &#123; title: &#39;备注&#39;, key: &#39;remarks&#39;, align: &#39;center&#39; &#125;, &#123; title: &#39;操作&#39;, slot: &#39;action&#39;, width: 150, align: &#39;center&#39; &#125; ], tableData: [], showModal: false, selectRow: &#123;&#125;, nodeList: [], treeNodeIndex: -1, currentNode: &#123;&#125;, addmodalshow: false, formType: &#39;add&#39;, editformData: &#123; id: null, catalogcode: null, catalogname: null, parentid: null, statue: null, creator: null, creatertime: null, modifytime: null, modifytor: null, remarks: null, ordernum: null, flag: null &#125;, currentPage: 1, title: &#39;添加应用&#39;, confirmButtonName: &#39;创建&#39; method loadNode (node, resolve) &#123; if (node.level &#x3D;&#x3D;&#x3D; 0) &#123; let root &#x3D; &#123;&#125; this.$http.get(&#96;&#x2F;api&#x2F;getDmpAppCatalogsByParentId&#x2F;0&#96;).then(response &#x3D;&gt; &#123; root &#x3D; response.data.data[0] this.defaultExpandsId.push(root.id) resolve([root]) &#125;).catch(error &#x3D;&gt; &#123; this.$Message.error(&#39;获取数据失败！&#39;) &#125;) &#125; else &#123; this.getNodes(node.data.id).then(value &#x3D;&gt; &#123; this.$nextTick(() &#x3D;&gt; &#123; if (node.level &#x3D;&#x3D;&#x3D; 1) &#123; this.currentNode &#x3D; node &#125; this.nodeList &#x3D; node.childNodes &#125;) this.tableData &#x3D; value return resolve(value) &#125;) &#125; &#125;, getNodes (parentId) &#123; return new Promise((resolve, reject) &#x3D;&gt; &#123; const msg &#x3D; this.$Message.loading(&#123; content: &#39;正在获取数据&#39;, duration: 0 &#125;) const [url, httpConfig] &#x3D; [ &#96;&#x2F;api&#x2F;getDmpAppCatalogsByParentId&#x2F;$&#123;parentId&#125;&#96; ] this.$http.get(url, httpConfig).then(response &#x3D;&gt; &#123; msg() resolve(response.data.data) &#125;).catch(error &#x3D;&gt; &#123; msg() this.$Message.error(&#39;获取数据失败！&#39;) reject(error) &#125;) &#125;) &#125;, clickNode (data, node) &#123; this.currentNode &#x3D; node this.nodeList &#x3D; node.childNodes this.getNodes(data.id).then(value &#x3D;&gt; &#123; this.tableData &#x3D; value &#125;) &#125;, deleteRow (row, index) &#123; this.showModal &#x3D; true this.selectRow &#x3D; row this.treeNodeIndex &#x3D; index &#125;, confirmDel () &#123; this.$http.delete(&#96;&#x2F;api&#x2F;dmpAppCatalogs&#x2F;$&#123;this.selectRow.id&#125;&#96;).then(resposne &#x3D;&gt; &#123; if (resposne.data.success) &#123; this.$Message.success(&#39;删除成功！&#39;) this.$refs[&#39;tree&#39;].remove(this.nodeList[this.treeNodeIndex]) this.removeTableData(this.tableData, this.selectRow.id) this.selectRow &#x3D; &#123;&#125; this.treeNodeIndex &#x3D; -1 &#125; &#125;).catch(error &#x3D;&gt; &#123; if (error.response) &#123; this.$Message.error(&#39;删除失败！&#39;) this.selectRow &#x3D; &#123;&#125; this.treeNodeIndex &#x3D; -1 &#125; &#125;) &#125;, cancelDel () &#123; this.selectRow &#x3D; &#123;&#125; this.treeNodeIndex &#x3D; -1 &#125;, removeTableData (data, id) &#123; let index &#x3D; data.findIndex((item) &#x3D;&gt; &#123; return item.id &#x3D;&#x3D;&#x3D; id &#125;) data.splice(index, 1) &#125;, addApp () &#123; this.confirmButtonName &#x3D; &#39;创建&#39; this.title &#x3D; &#39;添加应用&#39; this.addmodalshow &#x3D; true this.formType &#x3D; &#39;add&#39; &#125;, ok () &#123; if (this.formType &#x3D;&#x3D;&#x3D; &#39;add&#39;) &#123; this.editformData.parentid &#x3D; this.currentNode.key this.$http.post(&#39;&#x2F;api&#x2F;dmpAppCatalogs&#39;, this.editformData).then(response &#x3D;&gt; &#123; if (response.data.success) &#123; this.tableData.push(response.data.data) this.append(response.data.data, this.currentNode) this.cancel() this.$Message.success(response.data.msg) &#125; else &#123; this.$Message.error(response.data.msg) &#125; &#125;).catch() &#125; else &#123; this.$http.put(&#39;&#x2F;api&#x2F;dmpAppCatalogs&#39;, this.editformData).then(response &#x3D;&gt; &#123; if (response.data.success) &#123; this.currentNode.loaded &#x3D; false this.currentNode.expand() this.cancel() this.$Message.success(response.data.msg) &#125; else &#123; this.$Message.error(response.data.msg) &#125; &#125;).catch() &#125; &#125;, cancel () &#123; this.addmodalshow &#x3D; false this.editformData &#x3D; &#123; id: null, catalogcode: null, catalogname: null, parentid: null, statue: null, creator: null, creatertime: null, modifytime: null, modifytor: null, remarks: null, ordernum: null, flag: null &#125; &#125;, append (data, node) &#123; this.$refs[&#39;tree&#39;].append(data, node) &#125;, edit (row, index) &#123; &#x2F;&#x2F; 这里通过解构的方式即可 this.confirmButtonName &#x3D; &#39;确定&#39; this.title &#x3D; &#39;编辑应用&#39; this.formType &#x3D; &#39;edit&#39; this.editformData.id &#x3D; row.id this.editformData.catalogcode &#x3D; row.catalogcode this.editformData.catalogname &#x3D; row.catalogname this.editformData.parentid &#x3D; row.parentid this.editformData.statue &#x3D; row.statue this.editformData.creator &#x3D; row.creator this.editformData.creatertime &#x3D; row.creatertime this.editformData.modifytime &#x3D; row.modifytime this.editformData.modifytor &#x3D; row.modifytor this.editformData.remarks &#x3D; row.remarks this.editformData.ordernum &#x3D; row.ordernum this.editformData.flag &#x3D; row.flag &#x2F;&#x2F; this.addmodalshow2 &#x3D; true this.addmodalshow &#x3D; true &#125;, updateTable (table, id) &#123; let index &#x3D; table.findIndex((item) &#x3D;&gt; &#123; return item.id &#x3D;&#x3D;&#x3D; id &#125;) table[index] &#x3D; this.editformData &#125;, pageChange (currentPage) &#123; this.currentPage &#x3D; currentPage &#125; tree的Demo1描述： 一开始的时候展开自定义的root节点，然后请求数据第一级节点 点击的时候发起请求加载节点和请求右侧表格数据 结构*&lt;el-tree ref&#x3D;&quot;tree&quot; :props&#x3D;&quot;props&quot; node-key&#x3D;&quot;ctou&quot; :expand-on-click-node&#x3D;&quot;true&quot; :default-expanded-keys&#x3D;&quot;[&#39;&#39;]&quot; lazy @node-click&#x3D;&quot;clickNode&quot; :load&#x3D;&quot;loadNode&quot;&gt; &lt;span class&#x3D;&quot;custom-tree-node&quot; slot-scope&#x3D;&quot;&#123; node, data &#125;&quot;&gt; &#123;&#123;data.deptName&#125;&#125; &lt;&#x2F;span&gt; &lt;&#x2F;el-tree&gt; 数据 &#x2F;&#x2F; 树节点数据 props: &#123; label: &#39;deptName&#39;, children: &#39;children&#39; &#125;, 方法 loadNode (node, resolve) &#123; if (node.level &#x3D;&#x3D;&#x3D; 0) &#123; let root &#x3D; &#123; deptName: &#39;部门列表&#39;, ctou: &#39;&#39; &#125; resolve([root]) &#125; else &#123; this.getNodes(node.data.ctou).then(value &#x3D;&gt; &#123; return resolve(value) &#125;) &#125; &#125;, getNodes (parentId) &#123; return new Promise((resolve, reject) &#x3D;&gt; &#123; const msg &#x3D; this.$Message.loading(&#123; content: &#39;正在获取数据&#39;, duration: 0 &#125;) const [url, httpConfig] &#x3D; [ this.$util.carBaseUrlUS + &#39;&#x2F;api&#x2F;usOrganizesAllList&#39;, &#123; &#39;parentCode&#39;: parentId &#125; ] this.$http.post(url, httpConfig).then(response &#x3D;&gt; &#123; msg() resolve(response.data) &#125;).catch(error &#x3D;&gt; &#123; msg() this.$Message.error(&#39;获取数据失败！&#39;) reject(error) &#125;) &#125;) &#125;, clickNode (data, node) &#123; this.searchDepName &#x3D; data.deptName this.query2.organizeId &#x3D; data.ctou this.getNodes(data.ctou) this.getData2() &#125;, getData2 (currentPage &#x3D; 1) &#123; this.currentPage &#x3D; currentPage this.$http.post(this.$util.carBaseUrl + &#39;&#x2F;api&#x2F;carManagement&#x2F;queryList&#39;, &#123; t: this.query2, currentPage: this.currentPage, pageSize: this.pageSize &#125;).then(response &#x3D;&gt; &#123; if (response.data.success) &#123; this.tableData &#x3D; response.data.data.data this.total &#x3D; response.data.data.total &#125; else &#123; this.$Message.error(response.data.msg) &#125; &#125;).catch() &#125;,","permalink":"https://codermino.github.io/2020/11/03/vue%E7%9A%84tree%E6%87%92%E5%8A%A0%E8%BD%BD/","photos":[]},{"tags":[{"name":"vue表格跨页选中","slug":"vue表格跨页选中","permalink":"https://codermino.github.io/tags/vue%E8%A1%A8%E6%A0%BC%E8%B7%A8%E9%A1%B5%E9%80%89%E4%B8%AD/"}],"title":"vue表格跨页选中","date":"2020/11/03","text":"view-design表格跨页选中&lt;template&gt; &lt;div&gt; &lt;Table ref&#x3D;&quot;purchaseTable&quot; @on-select-all&#x3D;&quot;handleSelectAll&quot; @on-select-all-cancel&#x3D;&quot;handleSelectAll&quot; @on-select&#x3D;&quot;handleSelectRow&quot; @on-select-cancel&#x3D;&quot;handleCancelRow&quot; :columns&#x3D;&quot;columns1&quot; :data&#x3D;&quot;data1.slice((currentPage-1)*pageSize,pageSize*currentPage)&quot;&gt;&lt;&#x2F;Table&gt; &lt;Page :total&#x3D;&quot;data1.length&quot; :page-size&#x3D;&quot;pageSize&quot; @on-change&#x3D;&quot;getData&quot;&#x2F;&gt; &lt;Button @click&#x3D;&quot;submit&quot;&gt;提交&lt;&#x2F;Button&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default &#123; data() &#123; return &#123; columns1: [ &#123; type: &#39;selection&#39;, width: 60, align: &#39;center&#39; &#125;, &#123; title: &#39;Name&#39;, key: &#39;name&#39; &#125;, &#123; title: &#39;Age&#39;, key: &#39;age&#39; &#125;, &#123; title: &#39;Address&#39;, key: &#39;address&#39; &#125; ], data1: [ &#123; id:1, name: &#39;John Brown&#39;, age: 1, address: &#39;New York No. 1 Lake Park&#39;, date: &#39;2016-10-03&#39; &#125;, &#123; id:2, name: &#39;John Brown&#39;, age: 2, address: &#39;New York No. 1 Lake Park&#39;, date: &#39;2016-10-03&#39; &#125;, &#123; id:3, name: &#39;John Brown&#39;, age: 3, address: &#39;New York No. 1 Lake Park&#39;, date: &#39;2016-10-03&#39; &#125;, &#123; id:4, name: &#39;John Brown&#39;, age: 4, address: &#39;New York No. 1 Lake Park&#39;, date: &#39;2016-10-03&#39; &#125;, &#123; id:5, name: &#39;John Brown&#39;, age: 5, address: &#39;New York No. 1 Lake Park&#39;, date: &#39;2016-10-03&#39; &#125;, &#123; id:6, name: &#39;John Brown&#39;, age: 6, address: &#39;New York No. 1 Lake Park&#39;, date: &#39;2016-10-03&#39; &#125;, &#123; id:7, name: &#39;John Brown&#39;, age: 7, address: &#39;New York No. 1 Lake Park&#39;, date: &#39;2016-10-03&#39; &#125;, &#123; id:8, name: &#39;John Brown&#39;, age: 8, address: &#39;New York No. 1 Lake Park&#39;, date: &#39;2016-10-03&#39; &#125;, &#123; id:9, name: &#39;Jim Green&#39;, age: 9, address: &#39;London No. 1 Lake Park&#39;, date: &#39;2016-10-01&#39; &#125;, &#123; id:10, name: &#39;Joe Black&#39;, age: 10, address: &#39;Sydney No. 1 Lake Park&#39;, date: &#39;2016-10-02&#39; &#125;, &#123; id:11, name: &#39;Jon Snow&#39;, age: 11, address: &#39;Ottawa No. 2 Lake Park&#39;, date: &#39;2016-10-04&#39; &#125; ], pageSize:5, currentPage:1, selectedItems: new Set(),&#x2F;&#x2F;选中的合并项的id &#125; &#125;, methods: &#123; getData(val)&#123; this.currentPage &#x3D; val this.$nextTick(()&#x3D;&gt;&#123; this.setChecked() &#125;) &#125;, &#x2F;&#x2F; 全选和取消全选时触发 handleSelectAll (selection) &#123; if (selection.length)&#123; let data &#x3D; this.$refs.purchaseTable.data data.forEach((item) &#x3D;&gt; &#123; this.selectedItems.add(item) &#125;) &#125; else&#123; let data &#x3D; this.$refs.purchaseTable.data data.forEach(item&#x3D;&gt;&#123; for (let item2 of this.selectedItems) &#123; if (item.id &#x3D;&#x3D;&#x3D; item2.id)&#123; this.selectedItems.delete(item2) &#125; &#125; &#125;) &#125; &#125;, &#x2F;&#x2F; 选中某一行 handleSelectRow (selection,row) &#123; this.selectedItems.add(row) &#125;, &#x2F;&#x2F; 取消某一行 handleCancelRow (selection,row) &#123; for (let item of this.selectedItems) &#123; if (item.id &#x3D;&#x3D;&#x3D; row.id)&#123; this.selectedItems.delete(item) &#125; &#125; &#125;, setChecked() &#123; let objData &#x3D; this.$refs.purchaseTable.objData for (let index in objData) &#123; for (let item of this.selectedItems) &#123; if (item.id &#x3D;&#x3D;&#x3D; objData[index].id) &#123; objData[index]._isChecked &#x3D; true break; &#125; &#125; &#125; &#125;, submit()&#123; console.log([...this.selectedItems]); &#125; &#125;, &#125; &lt;&#x2F;script&gt; element-ui表格跨页选中reserve-selection仅对 type=selection 的列有效，类型为 Boolean，为 true 则会在数据更新之后保留之前选中的数据（需指定 row-key）Boolean — false &lt;template&gt; &lt;div class&#x3D;&quot;table&quot;&gt; &lt;el-table ref&#x3D;&quot;multipleTable&quot; :row-key&#x3D;&quot;(row) &#x3D;&gt; row.id&quot; :data&#x3D;&quot;tableData.slice((currentPage-1)*pageSize,pageSize*currentPage)&quot; style&#x3D;&quot;width: 100%&quot; @selection-change&#x3D;&quot;handleSelectionChange&quot;&gt; &lt;el-table-column type&#x3D;&quot;selection&quot; width&#x3D;&quot;55&quot; :reserve-selection&#x3D;&quot;true&quot;&gt; &lt;&#x2F;el-table-column&gt; &lt;el-table-column label&#x3D;&quot;日期&quot; width&#x3D;&quot;120&quot;&gt; &lt;template slot-scope&#x3D;&quot;scope&quot;&gt;&#123;&#123; scope.row.date &#125;&#125;&lt;&#x2F;template&gt; &lt;&#x2F;el-table-column&gt; &lt;el-table-column prop&#x3D;&quot;name&quot; label&#x3D;&quot;姓名&quot; width&#x3D;&quot;120&quot;&gt; &lt;&#x2F;el-table-column&gt; &lt;el-table-column prop&#x3D;&quot;address&quot; label&#x3D;&quot;地址&quot; show-overflow-tooltip&gt; &lt;&#x2F;el-table-column&gt; &lt;&#x2F;el-table&gt; &lt;el-pagination layout&#x3D;&quot;prev, pager, next&quot; :total&#x3D;&quot;tableData.length&quot; :page-size.sync&#x3D;&quot;pageSize&quot; :current-page.sync&#x3D;&quot;currentPage&quot; @current-change&#x3D;&quot;pageChange&quot;&gt; &lt;&#x2F;el-pagination&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default &#123; name: &quot;table&quot;, data() &#123; return &#123; tableData: [ &#123; id:0, date: &#39;2016-05-03&#39;, name: &#39;王小虎&#39;, address: &#39;上海市普陀区金沙江路 1518 弄&#39; &#125;, &#123; id:1, date: &#39;2016-05-02&#39;, name: &#39;王小虎&#39;, address: &#39;上海市普陀区金沙江路 1518 弄&#39; &#125;, &#123; id:2, date: &#39;2016-05-04&#39;, name: &#39;王小虎&#39;, address: &#39;上海市普陀区金沙江路 1518 弄&#39; &#125;, &#123; id:3, date: &#39;2016-05-01&#39;, name: &#39;王小虎&#39;, address: &#39;上海市普陀区金沙江路 1518 弄&#39; &#125;, &#123; id:4, date: &#39;2016-05-08&#39;, name: &#39;王小虎&#39;, address: &#39;上海市普陀区金沙江路 1518 弄&#39; &#125;,&#123; id:5, date: &#39;2016-05-03&#39;, name: &#39;王小虎&#39;, address: &#39;上海市普陀区金沙江路 1518 弄&#39; &#125;, &#123; id:6, date: &#39;2016-05-02&#39;, name: &#39;王小虎&#39;, address: &#39;上海市普陀区金沙江路 1518 弄&#39; &#125;, &#123; id:7, date: &#39;2016-05-04&#39;, name: &#39;王小虎&#39;, address: &#39;上海市普陀区金沙江路 1518 弄&#39; &#125;, &#123; id:8, date: &#39;2016-05-01&#39;, name: &#39;王小虎&#39;, address: &#39;上海市普陀区金沙江路 1518 弄&#39; &#125;, &#123; id:9, date: &#39;2016-05-08&#39;, name: &#39;王小虎&#39;, address: &#39;上海市普陀区金沙江路 1518 弄&#39; &#125;], multipleSelection: [], pageSize:5, currentPage:1 &#125; &#125;, methods: &#123; handleSelectionChange(val) &#123; this.multipleSelection &#x3D; val; console.log(this.multipleSelection); &#125;, pageChange(page)&#123; this.currentPage &#x3D; page &#125; &#125;, &#125; &lt;&#x2F;script&gt;","permalink":"https://codermino.github.io/2020/11/03/vue%E8%A1%A8%E6%A0%BC%E8%B7%A8%E9%A1%B5%E9%80%89%E4%B8%AD/","photos":[]},{"tags":[{"name":"render函数再理解","slug":"render函数再理解","permalink":"https://codermino.github.io/tags/render%E5%87%BD%E6%95%B0%E5%86%8D%E7%90%86%E8%A7%A3/"}],"title":"render函数再理解","date":"2020/10/23","text":"理解render是为补救template缺点而诞生的template是有标签，根据标签插值内容render厉害一点，可以渲染标签，并添加到虚拟DOM中注意下： template是模板语法，而render是js语法，render其实是用来生成模板； render用多了，发现挺麻烦，有一个插件jsx可以让render代码写得更自在 虚拟DOMVue通过建立一个虚拟DOM对真实DOM发生的变化保持追踪。return createElement(‘h1’, ‘Hello World!’)createElement 到底会返回什么呢？其实不是一个实际的 DOM 元素。它更准确的名字是createNodeDescription，因为它所包含的信息会告诉 Vue 页面上需要渲染什么样的节点，及其子节点。我们把这样的节点描述为“虚拟节点 (Virtual Node)”，也常简写它为“VNode”。“虚拟 DOM”是我们对由 Vue 组件树建立起来的整个 VNode 树的称呼。 render方法会传入一个createElement函数，它是一个用于创建DOM元素或者用于实例化其他组件的构造方法。render方法必须返回一个createElement函数的调用结果，也就是模版内的顶层元素（这个方法在vue2的习惯性使用中经常用h来命名）。 Demo export default &#123; render: function(createElement) &#123; const menu_items &#x3D; [&quot;首页&quot;,&quot;搜索&quot;,&quot;分类&quot;,&quot;系统&quot;] return createElement(&#39;ul&#39;, menu_items.map(item &#x3D;&gt; &#123; return createElement(&#39;li&#39;, &#123; class: &#123; &#39;uk-nav&#39;: true &#125;, domProps: &#123; innerHTML: item &#125; &#125;) &#125;) ) &#125;, &#125; 相当于模板语法： &lt;ul&gt; &lt;li v-for&#x3D;&quot;item in menu_items&quot; :class&#x3D;&quot;&#123;&#39;uk-nav&#39;: true&#125;&quot;&gt; &#123;&#123; item &#125;&#125; &lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; createElement的定义createElement(tag,data,children) 返回值vNode（虚拟节点） 参数说明: tag 类型：String/Object/Function 说明：一个HTML标签，组件类型,或一个函数 Data 类型：Object 说明：一个对应属性的数据对象,用于向创建的节点对象设置属性值 Children 类型：String/Array 说明：子节点 向构造的VNode对象设置文本时可以直接传入字符串，例如： createElement(‘div’,’这是行内文本’) 输出结果就是： 这是行内文本 data对象属性表&#123; // 和`v-bind:class`一样的 API 'class': &#123; foo: true, bar: false &#125;, // 和`v-bind:style`一样的 API style: &#123; color: 'red', fontSize: '14px' &#125;, // 正常的 HTML 特性 attrs: &#123; id: 'foo' &#125;, // 组件 props props: &#123; myProp: 'bar' &#125;, // DOM 属性 domProps: &#123; innerHTML: 'baz' &#125;, // 事件监听器基于 `on` // 所以不再支持如 `v-on:keyup.enter` 修饰器 // 需要手动匹配 keyCode。 on: &#123; click: this.clickHandler &#125;, // 仅对于组件，用于监听原生事件，而不是组件内部使用 // `vm.$emit` 触发的事件。 nativeOn: &#123; click: this.nativeClickHandler &#125;, // 自定义指令。注意，你无法对 `binding` 中的 `oldValue` // 赋值，因为 Vue 已经自动为你进行了同步。 directives: [ &#123; name: 'my-custom-directive', value: '2', expression: '1 + 1', arg: 'foo', modifiers: &#123; bar: true &#125; &#125; ], // Scoped slots in the form of // &#123; name: props =&gt; VNode | Array&lt;VNode&gt; &#125; scopedSlots: &#123; default: props =&gt; createElement('span', props.text) &#125;, // 如果组件是其他组件的子组件，需为插槽指定名称 slot: 'name-of-slot', // 其他特殊顶层属性 key: 'myKey', ref: 'myRef' &#125; Demo&lt;!DOCTYPE html&gt; &lt;html lang&#x3D;&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt; &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt; &lt;title&gt;Render&lt;&#x2F;title&gt; &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;div id&#x3D;&quot;container&quot;&gt; &lt;tb-heading&gt;&lt;&#x2F;tb-heading&gt; &lt;&#x2F;div&gt; &lt;script&gt; Vue.component(&#39;tb-heading&#39;, &#123; render: function(createElement) &#123; const menu_items &#x3D; [&quot;首页&quot;,&quot;搜索&quot;,&quot;分类&quot;,&quot;系统&quot;] return createElement(&#39;ul&#39;, menu_items.map(item &#x3D;&gt; &#123; return createElement(&#39;li&#39;, &#123; class: &#123; &#39;uk-nav&#39;: true &#125;, domProps: &#123; innerHTML: item &#125; &#125;) &#125;) ) &#125;, &#125;); new Vue(&#123; el: &#39;#container&#39;, methods: &#123; &#125; &#125;); &lt;&#x2F;script&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; 理解createElement在使用render函数，其中还有另一个需要掌握的部分，那就是createElement。接下来我们需要熟悉的是如何在createElement函数中生成模板。那么我们分两个部分来对createElement进行理解。 createElement参数createElement可以是接受多个参数: 第一个参数：{String | Object | Function}第一个参数对于createElement而言是一个必须的参数，这个参数可以是字符串string、是一个对象object，也可以是一个函数function。 &lt;div id&#x3D;&quot;app&quot;&gt; &lt;custom-element&gt;&lt;&#x2F;custom-element&gt; &lt;&#x2F;div&gt; Vue.component(&#39;custom-element&#39;, &#123; render: function (createElement) &#123; return createElement(&#39;div&#39;) &#125; &#125;) let app &#x3D; new Vue(&#123; el: &#39;#app&#39; &#125;) 接着把上例中的String换成一个Object，比如： Vue.component(&#39;custom-element&#39;, &#123; render: function (createElement) &#123; return createElement(&#123; template: &#96;&lt;div&gt;Hello Vue!&lt;&#x2F;div&gt;&#96; &#125;) &#125; &#125;) 除此之外，还可以传一个Function，比如： Vue.component(&#39;custom-element&#39;, &#123; render: function (createElement) &#123; var eleFun &#x3D; function () &#123; return &#123; template: &#96;&lt;div&gt;Hello Vue!&lt;&#x2F;div&gt;&#96; &#125; &#125; return createElement(eleFun()) &#125; &#125;) 这里传了一个eleFun()函数给createElement，而这个函数返回的是一个对象。 第二个参数:{Object}createElement是一个可选参数，这个参数是一个Object。来看一个小示例： &lt;div id&#x3D;&quot;app&quot;&gt; &lt;custom-element&gt;&lt;&#x2F;custom-element&gt; &lt;&#x2F;div&gt; Vue.component(&#39;custom-element&#39;, &#123; render: function (createElement) &#123; var self &#x3D; this &#x2F;&#x2F; 第一个参数是一个简单的HTML标签字符 “必选” &#x2F;&#x2F; 第二个参数是一个包含模板相关属性的数据对象 “可选” return createElement(&#39;div&#39;, &#123; &#39;class&#39;: &#123; foo: true, bar: false &#125;, style: &#123; color: &#39;red&#39;, fontSize: &#39;14px&#39; &#125;, attrs: &#123; id: &#39;boo&#39; &#125;, domProps: &#123; innerHTML: &#39;Hello Vue!&#39; &#125; &#125;) &#125; &#125;) let app &#x3D; new Vue(&#123; el: &#39;#app&#39; &#125;) 第三个参数：{String | Array}createElement还有第三个参数，这个参数是可选的，可以给其传一个String或Array。比如下面这个小示例： &lt;div id&#x3D;&quot;app&quot;&gt; &lt;custom-element&gt;&lt;&#x2F;custom-element&gt; &lt;&#x2F;div&gt; Vue.component(&#39;custom-element&#39;, &#123; render: function (createElement) &#123; var self &#x3D; this return createElement( &#39;div&#39;, &#x2F;&#x2F; 第一个参数是一个简单的HTML标签字符 “必选” &#123; class: &#123; title: true &#125;, style: &#123; border: &#39;1px solid&#39;, padding: &#39;10px&#39; &#125; &#125;, &#x2F;&#x2F; 第二个参数是一个包含模板相关属性的数据对象 “可选” [ createElement(&#39;h1&#39;, &#39;Hello Vue!&#39;), createElement(&#39;p&#39;, &#39;开始学习Vue!&#39;) ] &#x2F;&#x2F; 第三个参数是传了多个子元素的一个数组 “可选” ) &#125; &#125;) let app &#x3D; new Vue(&#123; el: &#39;#app&#39; &#125;) 看看template和render方式怎么创建相同效果的一个组件:template &lt;div id&#x3D;&quot;app&quot;&gt; &lt;custom-element&gt;&lt;&#x2F;custom-element&gt; &lt;&#x2F;div&gt; Vue.component(&#39;custom-element&#39;, &#123; template: &#96;&lt;div id&#x3D;&quot;box&quot; :class&#x3D;&quot;&#123;show: show&#125;&quot; @click&#x3D;&quot;handleClick&quot;&gt;Hello Vue!&lt;&#x2F;div&gt;&#96;, data () &#123; return &#123; show: true &#125; &#125;, methods: &#123; handleClick: function () &#123; console.log(&#39;Clicked!&#39;) &#125; &#125; &#125;) render Vue.component(&#39;custom-element&#39;, &#123; render: function (createElement) &#123; return createElement(&#39;div&#39;, &#123; class: &#123; show: this.show &#125;, attrs: &#123; id: &#39;box&#39; &#125;, on: &#123; click: this.handleClick &#125; &#125;, &#39;Hello Vue!&#39;) &#125;, data () &#123; return &#123; show: true &#125; &#125;, methods: &#123; handleClick: function () &#123; console.log(&#39;Clicked!&#39;) &#125; &#125; &#125;) 最后声明一个Vue实例，并挂载到id为#app的一个元素上： let app &#x3D; new Vue(&#123; el: &#39;#app&#39; &#125;) 使用JavaScript代替模板功能在使用Vue模板的时候，我们可以在模板中灵活的使用v-if、v-for、v-model和之类的。但在render函数中是没有提供专用的API。如果在render使用这些，需要使用原生的JavaScript来实现。 v-if和v-for在render函数中可以使用if/else和map来实现template中的v-if和v-for。 &lt;ul v-if&#x3D;&quot;items.length&quot;&gt; &lt;li v-for&#x3D;&quot;item in items&quot;&gt;&#123;&#123; item &#125;&#125;&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;p v-else&gt;No items found.&lt;&#x2F;p&gt; 换成render函数，可以这样写： Vue.component(&#39;item-list&#39;,&#123; props: [&#39;items&#39;], render: function (createElement) &#123; if (this.items.length) &#123; return createElement(&#39;ul&#39;, this.items.map((item) &#x3D;&gt; &#123; return createElement(&#39;item&#39;) &#125;)) &#125; else &#123; return createElement(&#39;p&#39;, &#39;No items found.&#39;) &#125; &#125; &#125;) &lt;div id&#x3D;&quot;app&quot;&gt; &lt;item-list :items&#x3D;&quot;items&quot;&gt;&lt;&#x2F;item-list&gt; &lt;&#x2F;div&gt; let app &#x3D; new Vue(&#123; el: &#39;#app&#39;, data () &#123; return &#123; items: [&#39;大漠&#39;, &#39;W3cplus&#39;, &#39;blog&#39;] &#125; &#125; &#125;) v-modelrender函数中也没有与v-model相应的API，如果要实现v-model类似的功能，同样需要使用原生JavaScript来实现。 &lt;div id&#x3D;&quot;app&quot;&gt; &lt;el-input :name&#x3D;&quot;name&quot; @input&#x3D;&quot;val &#x3D;&gt; name &#x3D; val&quot;&gt;&lt;&#x2F;el-input&gt; &lt;&#x2F;div&gt; Vue.component(&#39;el-input&#39;, &#123; render: function (createElement) &#123; var self &#x3D; this return createElement(&#39;input&#39;, &#123; domProps: &#123; value: self.name &#125;, on: &#123; input: function (event) &#123; self.$emit(&#39;input&#39;, event.target.value) &#125; &#125; &#125;) &#125;, props: &#123; name: String &#125; &#125;) let app &#x3D; new Vue(&#123; el: &#39;#app&#39;, data () &#123; return &#123; name: &#39;大漠&#39; &#125; &#125; &#125;) 插槽你可以从this.$slots获取VNodes列表中的静态内容 render: function (createElement) &#123; &#x2F;&#x2F; 相当于 &#96;&lt;div&gt;&lt;slot&gt;&lt;&#x2F;slot&gt;&lt;&#x2F;div&gt;&#96; return createElement(&#39;div&#39;, this.$slots.default) &#125; 还可以从this.$scopedSlots中获得能用作函数的作用域插槽，这个函数返回VNodes: props: [&#39;message&#39;], render: function (createElement) &#123; &#x2F;&#x2F; &#96;&lt;div&gt;&lt;slot :text&#x3D;&quot;message&quot;&gt;&lt;&#x2F;slot&gt;&lt;&#x2F;div&gt;&#96; return createElement(&#39;div&#39;, [ this.$scopedSlots.default(&#123; text: this.message &#125;) ]) &#125; 如果要用渲染函数向子组件中传递作用域插槽，可以利用VNode数据中的scopedSlots域： &lt;div id&#x3D;&quot;app&quot;&gt; &lt;custom-ele&gt;&lt;&#x2F;custom-ele&gt; &lt;&#x2F;div&gt; Vue.component(&#39;custom-ele&#39;, &#123; render: function (createElement) &#123; return createElement(&#39;div&#39;, [ createElement(&#39;child&#39;, &#123; scopedSlots: &#123; default: function (props) &#123; return [ createElement(&#39;span&#39;, &#39;From Parent Component&#39;), createElement(&#39;span&#39;, props.text) ] &#125; &#125; &#125;) ]) &#125; &#125;) Vue.component(&#39;child&#39;, &#123; render: function (createElement) &#123; return createElement(&#39;strong&#39;, this.$scopedSlots.default(&#123; text: &#39;This is Child Component&#39; &#125;)) &#125; &#125;) let app &#x3D; new Vue(&#123; el: &#39;#app&#39; &#125;) JSX如果写习惯了template，然后要用render函数来写，一定会感觉好痛苦，特别是面对复杂的组件的时候。不过我们在Vue中使用JSX可以让我们回到更接近于模板的语法上。 import AnchoredHeading from &#39;.&#x2F;AnchoredHeading.vue&#39; new Vue(&#123; el: &#39;#demo&#39;, render: function (h) &#123; return ( &lt;AnchoredHeading level&#x3D;&#123;1&#125;&gt; &lt;span&gt;Hello&lt;&#x2F;span&gt; world! &lt;&#x2F;AnchoredHeading&gt; ) &#125; &#125;) 将 h 作为 createElement 的别名是 Vue 生态系统中的一个通用惯例，实际上也是 JSX 所要求的，如果在作用域中 h 失去作用，在应用中会触发报错。 总结回过头来看，Vue中的渲染核心关键的几步流程还是非常清晰的： new Vue，执行初始化 挂载$mount方法，通过自定义render方法、template、el等生成render函数 通过Watcher监听数据的变化 当数据发生变化时，render函数执行生成VNode对象 通过patch方法，对比新旧VNode对象，通过DOM Diff算法，添加、修改、删除真正的DOM元素至此，整个new Vue的渲染过程完毕。","permalink":"https://codermino.github.io/2020/10/23/render%E5%87%BD%E6%95%B0%E5%86%8D%E7%90%86%E8%A7%A3/","photos":[]},{"tags":[{"name":"vue中的.capture事件修饰符的用法","slug":"vue中的-capture事件修饰符的用法","permalink":"https://codermino.github.io/tags/vue%E4%B8%AD%E7%9A%84-capture%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%9A%84%E7%94%A8%E6%B3%95/"}],"title":"vue中的.capture事件修饰符的用法","date":"2020/10/22","text":".capture事件修饰符的作用添加事件侦听器时使用事件捕获模式即是给元素添加一个监听器，当元素发生冒泡时，先触发带有该修饰符的元素。若有多个该修饰符，则由外而内触发。就是谁有该事件修饰符，就先触发谁。 Demo&lt;!DOCTYPE html&gt; &lt;html lang&#x3D;&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;.capture事件修饰符&lt;&#x2F;title&gt; &lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt; * &#123; margin: 0 auto; text-align:center; line-height: 40px; &#125; div &#123; width: 100px; &#125; #obj1 &#123; background: deeppink; &#125; #obj2 &#123; background: pink; &#125; #obj3 &#123; background: hotpink; &#125;#obj4 &#123; background: #ff4225; &#125; &lt;&#x2F;style&gt; &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcdn.net&#x2F;ajax&#x2F;libs&#x2F;vue&#x2F;2.6.7&#x2F;vue.min.js&quot;&gt;&lt;&#x2F;script&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;div id&#x3D;&quot;content&quot;&gt; &lt;div id&#x3D;&quot;obj1&quot; v-on:click.capture&#x3D;&quot;doc&quot;&gt; obj1 &lt;div id&#x3D;&quot;obj2&quot; v-on:click.capture&#x3D;&quot;doc&quot;&gt; obj2 &lt;div id&#x3D;&quot;obj3&quot; v-on:click&#x3D;&quot;doc&quot;&gt; obj3 &lt;div id&#x3D;&quot;obj4&quot; v-on:click&#x3D;&quot;doc&quot;&gt; obj4 &lt;!--点击obj4的时候，弹出的顺序为：obj1、obj2、obj4、obj3； 由于1，2有修饰符，故而先触发事件，然后就是4本身触发，最后冒泡事件。 --&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; var content &#x3D; new Vue(&#123; el: &quot;#content&quot;, data: &#123; id: &#39;&#39; &#125;, methods: &#123; doc: function () &#123; this.id&#x3D; event.currentTarget.id; alert(this.id) &#125; &#125; &#125;) &lt;&#x2F;script&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt;","permalink":"https://codermino.github.io/2020/10/22/vue%E4%B8%AD%E7%9A%84-capture%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%9A%84%E7%94%A8%E6%B3%95/","photos":[]},{"tags":[{"name":"vue悬停之后显示抽屉","slug":"vue悬停之后显示抽屉","permalink":"https://codermino.github.io/tags/vue%E6%82%AC%E5%81%9C%E4%B9%8B%E5%90%8E%E6%98%BE%E7%A4%BA%E6%8A%BD%E5%B1%89/"}],"title":"vue悬停之后显示抽屉","date":"2020/10/20","text":"具体页面&lt;template&gt; &lt;div class&#x3D;&quot;drawer&quot;&gt; &lt;div&gt; &lt;Icon @mouseenter.native&#x3D;&quot;mouseenter&quot; @mouseleave.native&#x3D;&quot;mouseleave&quot; type&#x3D;&quot;ios-apps&quot; style&#x3D;&quot;font-size: 30px;cursor:pointer;&quot; @click&#x3D;&quot;value2&#x3D;true&quot;&#x2F;&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;side-drawer&quot;&gt; &lt;Drawer title&#x3D;&quot;Basic Drawer&quot; placement&#x3D;&quot;left&quot; :closable&#x3D;&quot;false&quot; v-model&#x3D;&quot;value2&quot; :inner&#x3D;&quot;true&quot; :transfer&#x3D;&quot;false&quot;&gt; &lt;p&gt;Some contents...&lt;&#x2F;p&gt; &lt;p&gt;Some contents...&lt;&#x2F;p&gt; &lt;p&gt;Some contents...&lt;&#x2F;p&gt; &lt;&#x2F;Drawer&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; import util from &#39;..&#x2F;util&#x2F;util&#39; export default &#123; name: &quot;drawer&quot;, data() &#123; return &#123; value2: false &#125; &#125;, methods: &#123; mouseenter(e) &#123; util.debounce(() &#x3D;&gt; &#123; this.value2 &#x3D; true &#125;,1000) &#125;, mouseleave(e)&#123; util.cancelDebounce() &#125; &#125;, &#125; &lt;&#x2F;script&gt; &lt;style scoped&gt; .drawer&#123; width: 100%; height: 100%; &#125; .side-drawer&#123; position: relative; left:0; height: 100%; &#125; &lt;&#x2F;style&gt; util.jslet timeout = null function debounce (fn, wait = 500) &#123; if (timeout !== null) clearTimeout(timeout) timeout = setTimeout(fn, wait) &#125; function cancelDebounce() &#123; if (timeout !== null) clearTimeout(timeout) &#125; export default &#123; debounce, cancelDebounce &#125; App.vue&lt;template&gt; &lt;div id&#x3D;&quot;app&quot;&gt; &lt;keep-alive exclude&#x3D;&quot;detail&quot;&gt; &lt;router-view&#x2F;&gt; &lt;&#x2F;keep-alive&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;style&gt; html, body &#123; width: 100%; height: 100%; background: #f0f0f0; overflow: hidden; word-break: break-all; word-wrap: break-word; &#125; #app &#123; width: 100%; height: 100%; &#125; &lt;&#x2F;style&gt;","permalink":"https://codermino.github.io/2020/10/20/vue%E6%82%AC%E5%81%9C%E4%B9%8B%E5%90%8E%E6%98%BE%E7%A4%BA%E6%8A%BD%E5%B1%89/","photos":[]},{"tags":[{"name":"vue如何避免变量赋值后双向绑定","slug":"vue如何避免变量赋值后双向绑定","permalink":"https://codermino.github.io/tags/vue%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC%E5%90%8E%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/"}],"title":"vue如何避免变量赋值后双向绑定","date":"2020/10/20","text":"案例在点击编辑按钮的时候需要传入数据，但是在打开的对话框中修改对应的表单数据展示界面的数据也被修改了。 解决需要避免直接赋值导致的数据双向绑定如： this.list = this.list2, 结果在list改变后 list2也改变，这不是我们想要的效果第一种：利用 JSON.parse 和 JSON.stringify this.list= JSON.parse( JSON.stringify(this.list2)) 第二种：ES6 的解构语法 this.list= &#123; ...this.list2&#125; this.arr= [...this.arr2]","permalink":"https://codermino.github.io/2020/10/20/vue%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC%E5%90%8E%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/","photos":[]},{"tags":[{"name":"el-tree新增和删除节点后如何刷新tree","slug":"el-tree新增和删除节点后如何刷新tree","permalink":"https://codermino.github.io/tags/el-tree%E6%96%B0%E5%A2%9E%E5%92%8C%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9%E5%90%8E%E5%A6%82%E4%BD%95%E5%88%B7%E6%96%B0tree/"}],"title":"el-tree新增和删除节点后如何刷新tree","date":"2020/10/19","text":"当新增节点后刷新当前节点 node.loaded = false;node.expand();//新建子节点是刷新一次本节点的展开请求，而重命名和删除则需要刷新父级节点的的展开事件， 删除节点node.parent.loaded = falsenode.parent.expand()","permalink":"https://codermino.github.io/2020/10/19/el-tree%E6%96%B0%E5%A2%9E%E5%92%8C%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9%E5%90%8E%E5%A6%82%E4%BD%95%E5%88%B7%E6%96%B0tree/","photos":[]},{"tags":[{"name":"vue图片未加载完成显示占位图","slug":"vue图片未加载完成显示占位图","permalink":"https://codermino.github.io/tags/vue%E5%9B%BE%E7%89%87%E6%9C%AA%E5%8A%A0%E8%BD%BD%E5%AE%8C%E6%88%90%E6%98%BE%E7%A4%BA%E5%8D%A0%E4%BD%8D%E5%9B%BE/"}],"title":"vue图片未加载完成显示占位图","date":"2020/10/19","text":"&lt;template&gt; &lt;div class&#x3D;&quot;container&quot;&gt; &lt;img v-if&#x3D;&quot;url&quot; :src&#x3D;&quot;url&quot; alt&#x3D;&quot;&quot; @load&#x3D;&quot;imgLoad&quot;&gt; &lt;img v-else src&#x3D;&quot;..&#x2F;assets&#x2F;placeholder-image.jpg&quot; alt&#x3D;&quot;&quot;&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; import &#123;reactive,toRefs&#125; from &#39;vue&#39; export default &#123; name: &quot;showImg&quot;, setup()&#123; const state &#x3D; reactive(&#123; url:null, showImg:false &#125;) setTimeout(()&#x3D;&gt;&#123; state.url &#x3D; require(&quot;..&#x2F;assets&#x2F;logo.png&quot;) &#125;,3000) const imgLoad &#x3D; ()&#x3D;&gt;&#123; state.showImg &#x3D; true &#125; return&#123; ...toRefs(state), imgLoad &#125; &#125; &#125; &lt;&#x2F;script&gt; &lt;style scoped&gt; .container&#123; width: 100px; height: 100px; &#125; .container img&#123; width: 100%; &#125; &lt;&#x2F;style&gt;","permalink":"https://codermino.github.io/2020/10/19/vue%E5%9B%BE%E7%89%87%E6%9C%AA%E5%8A%A0%E8%BD%BD%E5%AE%8C%E6%88%90%E6%98%BE%E7%A4%BA%E5%8D%A0%E4%BD%8D%E5%9B%BE/","photos":[]},{"tags":[{"name":"vue3的provide和Inject","slug":"vue3的provide和Inject","permalink":"https://codermino.github.io/tags/vue3%E7%9A%84provide%E5%92%8CInject/"}],"title":"vue3的provide和Inject","date":"2020/10/19","text":"使用provide提供 const location = ref('North Pole') const geolocation = reactive(&#123; longitude: 90, latitude: 135 &#125;) provide('location', location) provide('geolocation', geolocation) 注入tip：注入的inject使用的时候和ref一样 const userLocation = inject('location', 'The Universe') const userGeolocation = inject('geolocation') return &#123; userLocation, userGeolocation &#125; 修改注入的值不推荐在inject的子组件中直接修改 1. 在父组件中provide一个修改provide的方法 const updateLocation = () =&gt; &#123; location.value = 'South Pole' &#125; provide('updateLocation', updateLocation) 2. 在子组件中注入和使用 const updateUserLocation = inject('updateLocation') 以上的方式注入的值，可以在子组件中进行修改如果想防止在子组件中进行修改，可以在provide的时候把值修改为readonly的形式 provide('location', readonly(location)) provide('geolocation', readonly(geolocation)) 这样在子组件中就无法修改，并且会发出警告","permalink":"https://codermino.github.io/2020/10/19/vue3%E7%9A%84provide%E5%92%8CInject/","photos":[]},{"tags":[{"name":"insertAdjacentHTML方法详解","slug":"insertAdjacentHTML方法详解","permalink":"https://codermino.github.io/tags/insertAdjacentHTML%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"}],"title":"insertAdjacentHTML方法详解","date":"2020/10/19","text":"insertHtml方法名称：insertHtml(where,el,html) 参数介绍：where：插入位置。包括beforeBegin,beforeEnd,afterBegin,afterEnd。el：用于参照插入位置的html元素对象html：要插入的html代码 insertAdjacentHTML原型：insertAdajcentHTML(swhere,stext) 参数：swhere: 指定插入html标签语句的地方，stext:要插入的内容 有四种值可用： beforeBegin: 插入到标签开始前 afterBegin:插入到标签开始标记之后 beforeEnd:插入到标签结束标记前 afterEnd:插入到标签结束标记后insertAdjacentText方法与insertAdjacentHTML方法类似，只不过只能插入纯文本，参数相同 Demo var obj = document.getElementById(\"btn1\"); obj.insertAdjacentHTML(\"afterEnd\",\"&lt;br&gt;&lt;input name='txt1'&gt;\"); var obj2 = document.getElementById(\"paral\"); obj2.insertAdjacentHTML(\"afterBegin\",\"&lt;h1&gt; 在文本前容器内插入内容1&lt;/h1&gt;\"); obj2.insertAdjacentHTML(\"beforeEnd\",\"&lt;h2&gt; 在文本后容器内插入内容2&lt;/h2&gt;\"); obj2.insertAdjacentHTML(\"beforeBegin\",\"&lt;h4&gt; 在文本前容器外插入内容4&lt;/h1&gt;\"); obj2.insertAdjacentHTML(\"afterEnd\",\"&lt;h5&gt; 在文本后容器外插入内容5&lt;/h2&gt;\");","permalink":"https://codermino.github.io/2020/10/19/insertAdjacentHTML%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/","photos":[]},{"tags":[{"name":"vue的data必须是一个函数","slug":"vue的data必须是一个函数","permalink":"https://codermino.github.io/tags/vue%E7%9A%84data%E5%BF%85%E9%A1%BB%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0/"}],"title":"vue的data必须是一个函数","date":"2020/10/19","text":"Vue组件为什么data必须是一个函数 前言我们需要先复习下原型链的知识，其实这个问题取决于 js ，而并非是 vue 。 function Component()&#123; this.data = this.data &#125; Component.prototype.data = &#123; name:'jack', age:22, &#125; 解开疑问基于此，我们来看看这个问题： function Component()&#123; &#125; Component.prototype.data = &#123; name:'jack', age:22, &#125; var componentA = new Component(); var componentB = new Component(); componentA.data.age=55; console.log(componentA,componentB) 此时，componentA 和 componentB data之间指向了同一个内存地址，age 都变成了 55， 导致了问题！ 接下来很好解释为什么 vue 组件需要 function 了： function Component()&#123; this.data = this.data() &#125; Component.prototype.data = function ()&#123; return &#123; name:'jack', age:22, &#125; &#125; var componentA = new Component(); var componentB = new Component(); componentA.data.age=55; console.log(componentA,componentB) 此时，componentA 和 componentB data之间相互独立,age 分别是 55 和 22 ，没有问题！ 总结在函数内声明实例属性保存data，每个实例对象的data都是经过一次函数执行得到有不同的返回结果，所以返回data的值具有自己独立的作用域。 在定义Vue实例时，给Vue传参是一个对象，对象中data就是一个函数，Vue在实例化的时候会调用这个函数每个实例都会返回新的值，data得到不同的值作用域另外，赋值函数不一定要定义在原型上，也可以定义为函数或类的实例方法总结对象为引用关系，当复用组件时，由于数据对象都指向同一个data对象，当找一个组件中修改data时，其他重用的组件中的data会同时被修改，但是使用返回的对象的函数，由于每次返回的都是一个新对象，保障了引用地址不同，则不会出现修改同一个数据的问题. Demo&lt;body&gt; &lt;div id&#x3D;&quot;app&quot;&gt; &lt;counter&gt;&lt;&#x2F;counter&gt; &lt;&#x2F;div&gt; &lt;template id&#x3D;&quot;temp1&quot;&gt; &lt;div&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;+1&quot; @click&#x3D;&quot;increment&quot;&gt; &lt;h3&gt;&#123;&#123;count&#125;&#125;&lt;&#x2F;h3&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; var dataObj &#x3D; &#123;count: 0&#125;; Vue.component(&#39;counter&#39;,&#123; template:&#39;#temp1&#39;, data()&#123; return dataObj &#125;, methods:&#123; increment() &#123; this.count++ &#125; &#125; &#125;) var vm &#x3D; new Vue(&#123; el: &quot;#app&quot;, data:&#123;&#125;, methods: &#123;&#125; &#125;) &lt;&#x2F;script&gt; &lt;&#x2F;body&gt; 分析如上代码： 首先创建一个名字为counter的组件，data函数中返回一个外部定义的对象的值，如果直接给data属性设置一个对象而不是函数，那么会在浏览器中直接报错 在浏览器中运行代码每次点击+1按钮，下边的值就会加一 如果我们在页面上同时使用三个counter组件&lt;div id&#x3D;&quot;app&quot;&gt; &lt;counter&gt;&lt;&#x2F;counter&gt; &lt;hr&gt; &lt;counter&gt;&lt;&#x2F;counter&gt; &lt;hr&gt; &lt;counter&gt;&lt;&#x2F;counter&gt; &lt;hr&gt; &lt;&#x2F;div&gt; 然后在浏览器中再次浏览点击任意一个+1按钮，三个数同时变化。因为它们都指向了同一个对象。我们当然希望点击不同的按钮只实现当前组件内数据的变化，那么，我们在函数中返回一个对象，每次创建一个组建的时候，在内存中同时开辟一块空间给当前组件存放data，这样，就不会出现共用一个data的现象。我们只需将如上代码进行一点更改 因为此时我们每次返回的对象的地址都是不一样的，所以在组件对值修改时，会去寻找对应该组件data返回对象的地址，这样就能很好地控制组件数据独立。 data: function ()&#123; &#x2F;&#x2F;return dataObj return&#123; count：0 &#125; &#125;,","permalink":"https://codermino.github.io/2020/10/19/vue%E7%9A%84data%E5%BF%85%E9%A1%BB%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0/","photos":[]},{"tags":[{"name":"package.json的^和~区别","slug":"package-json的-和-区别","permalink":"https://codermino.github.io/tags/package-json%E7%9A%84-%E5%92%8C-%E5%8C%BA%E5%88%AB/"}],"title":"package.json的^和~区别","date":"2020/10/19","text":"很显然这个dependencies对象中的key是依赖项的名称，值则是版本号，但是版本号前面有的啥也没有，比如：“array-flatten”: “1.1.1”，有的有波浪号，比如：“accepts”: “~1.3.7”，也有的有插入符号，比如：“body-parser”: “^1.19.0”。 那这些到底有啥区别呢？其实也比较简单： 波浪号〜匹配最新补丁版本号，也就是版本号的第三个数字。比如~1.2.3将匹配所有1.2.x版本，但将在1.3.0上停止。 插入符号^ 更宽松。它匹配的是最新次要版本号，也就是第二个数字。比如：^ 1.2.3将匹配任何1.x.x版本，包括1.3.0，但将在2.0.0上停止。 前面啥符号也没有，很显然意思就是确定唯一指定的版本号。当然这里还可以写&gt;，&gt;=，&lt;，&lt;=，比如： \"dependencies\": &#123; \"accepts\": \"~1.3.7\", \"array-flatten\": \"1.1.1\", \"body-parser\": \"^1.19.0\", \"content-disposition\": \"&gt;0.5.3\", \"content-type\": \"~1.0.4\", \"cookie\": \"^0.4.0\", \"cookie-signature\": \"&lt;1.0.6\", \"debug\": \"&gt;=2.6.9\", \"depd\": \"~1.1.2\", \"encodeurl\": \"&lt;1.0.2\" &#125; 意思也很简单，就是大于，或者大于等于，小于或者小于等于后面的版本号。如果前面是星号*，那意思就是匹配任何版本。如果版本号的值是latest，那意思安装的永远是最新发布的版本。 如果只匹配版本号的其中一位，除了上面的做法外，还有一种，那就是用x，比如：1.2.x，就可以匹配1.2.1，1.2.2，…，但是1.3.0肯定是不行的。 \"dependencies\": &#123; \"accepts\": \"1.3.x\" &#125;","permalink":"https://codermino.github.io/2020/10/19/package-json%E7%9A%84%E5%92%8C-%E5%8C%BA%E5%88%AB/","photos":[]},{"tags":[{"name":"vue3composition抽离","slug":"vue3composition抽离","permalink":"https://codermino.github.io/tags/vue3composition%E6%8A%BD%E7%A6%BB/"}],"title":"vue3composition抽离","date":"2020/10/19","text":"composition API的好处 方便代码抽离 可以将属于同一个业务功能的属性和方法等抽离出去方便管理 抽离成一个函数 const peopleProp = ()=&gt;&#123; const age = ref(18) const state = reactive(&#123; count:0 &#125;) watch( [age,()=&gt;state.count], ([newAge, newCount], [oldAge, oldCount]) =&gt; &#123; console.log(newAge, newCount); &#125; ) const changeValue = ()=&gt;&#123; age.value = 20 state.count ++ &#125; return&#123; state, age, changeValue &#125; &#125; 引用 const &#123;state,age,changeValue,changeEmployee&#125; = peopleProp() 导出 return&#123; ...toRefs(state), age, changeValue, changeEmployee &#125; 抽离成单独的文件抽离 import &#123;ref,reactive,watch&#125; from 'vue' const peopleProp = ()=&gt;&#123; const age = ref(18) const state = reactive(&#123; count:0, employee:[ &#123;name:'张三',sex:'男'&#125;, &#123;name:'张三2',sex:'男'&#125;, &#123;name:'张三3',sex:'男'&#125;, &#123;name:'张三4',sex:'男'&#125;, &#123;name:'张三5',sex:'男'&#125; ] &#125;) watch( [age,()=&gt;state.count], ([newAge, newCount], [oldAge, oldCount]) =&gt; &#123; console.log(newAge, newCount); &#125; ) const changeValue = ()=&gt;&#123; age.value = 20 state.count ++ &#125; const changeEmployee = ()=&gt;&#123; state.employee[2].name = '孙赫' console.log(state.employee); &#125; return&#123; state, age, changeValue, changeEmployee &#125; &#125; export default peopleProp 引入 const &#123;state,age,changeValue,changeEmployee&#125; = peopleProp() 导出 return&#123; ...toRefs(state), age, changeValue, changeEmployee &#125;","permalink":"https://codermino.github.io/2020/10/19/vue3composition%E6%8A%BD%E7%A6%BB/","photos":[]},{"tags":[{"name":"vue3的ref和reactive区别","slug":"vue3的ref和reactive区别","permalink":"https://codermino.github.io/tags/vue3%E7%9A%84ref%E5%92%8Creactive%E5%8C%BA%E5%88%AB/"}],"title":"vue3的ref和reactive区别","date":"2020/10/19","text":"###区别 ref只可以监听简单数据，reactive可以监听所有数据 ref这种写法简单，但也有弊端，经过尝试， 我发现他只能监听一些如数字、字符串、布尔之类的简单数据 而如果需要监听如上面代码一样的jsonArray我们在vue2种都会使用$set来进行变更， 到了vue3我们终于可以愉快的使用reactive来实现了。 使用方式不一样 ref修改数据需要使用这样count.value=xxx的形式，而reactive只需要state.reactiveField=值这样来使用 第二点体现在template中引用时候为reactiveField，不需要state，也就是说我reactive对象里面字段是应该直接使用的 体现在reactive在return时候需要toRefs来转换成响应式对象 Demo1在vue2中使用下标修改的方式不能触发视图更新 &lt;template&gt; &lt;div&gt; &lt;el-input v-model&#x3D;&quot;datalist[0]&quot;&gt;&lt;&#x2F;el-input&gt; &#123;&#123;datalist[0]&#125;&#125; &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;change1&quot;&gt;change1&lt;&#x2F;el-button&gt; &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;change2&quot;&gt;change2&lt;&#x2F;el-button&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default&#123; data()&#123; return&#123; datalist:[&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;] &#125; &#125;, methods:&#123; change1()&#123; this.datalist[0]&#x3D;&#39;111&#39;; &#125;, change2()&#123; this.$set(this.datalist,0,&#39;222&#39;); &#125; &#125; &#125; &lt;&#x2F;script&gt; Demo2在vue3中使用下标修改可以触发视图更新 &#123;&#123;datalist[0]&#125;&#125; &lt;button @click&#x3D;&quot;change1&quot;&gt;change1&lt;&#x2F;button&gt; import &#123;reactive&#125; from &#39;vue&#39; const test &#x3D; ()&#x3D;&gt;&#123; const state2 &#x3D; reactive(&#123; datalist:[&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;] &#125;) const change1 &#x3D; ()&#x3D;&gt;&#123; state2.datalist[0]&#x3D;&#39;111&#39;; &#125; return&#123; state2, change1 &#125; &#125; export default test","permalink":"https://codermino.github.io/2020/10/19/vue3%E7%9A%84ref%E5%92%8Creactive%E5%8C%BA%E5%88%AB/","photos":[]},{"tags":[{"name":"副作用函数","slug":"副作用函数","permalink":"https://codermino.github.io/tags/%E5%89%AF%E4%BD%9C%E7%94%A8%E5%87%BD%E6%95%B0/"}],"title":"副作用函数","date":"2020/10/16","text":"概念 函数或者表达式修改了它的SCOPE之外的状态 函数或者表达式除了返回语句外还与外部世界或者它所调用的函数有明显的交互行为 函数的副作用 函数副作用指当调用函数时，除了返回函数值之外，还对主调用函数产生附加的影响。 例如修改全局变量（函数外的变量）或修改参数。 函数副作用会给程序设计带来不必要的麻烦，给程序带来十分难以查找的错误， 并且降低程序的可读性。严格的函数式语言要求函数必须无副作用。 函数的副作用相关的几个概念， Pure Function、 Impure Function、 Referential Transparent。 纯函数 ( Pure Function )输入输出数据流全是显式（Explicit）的。显式（Explicit）的意思是，函数与外界交换数据只有一个唯一渠道——参数和返回值。函数从函数外部接受的所有输入信息都通过参数传递到该函数内部。函数输出到函数外部的所有信息都通过返回值传递到该函数外部。 非纯函数 ( Impure Function )与之相反。 隐式（Implicit）的意思是，函数通过参数和返回值以外的渠道，和外界进行数据交换。比如读取/修改全局变量，都叫作以隐式的方式和外界进行数据交换。 引用透明 ( Referential Transparent )引用透明的概念与函数的副作用相关，且受其影响。如果程序中两个相同值得表达式能在该程序的任何地方互相替换，而不影响程序的动作，那么该程序就具有引用透明性。它的优点是比非引用透明的语言的语义更容易理解，不那么晦涩。纯函数式语言没有变量，所以它们都具有引用透明性。 以下示例说明了引用透明与函数副作用的结合 result1 = (fun(a) + b) / (fun(a) -c); temp = fun(a); result2 = (temp + b) / (temp -c); 如果函数没有副作用，那么result1和result2将是等价的。然而如果fun有副作用，比如让b或c加1，那么result1和result2将不相等。因此，副作用违背了引用透明性。 在JavaScript中，引入了函数。但显然JS中的函数可以访问、修改全局变量（或定义在函数外的变量），如下 var a = 5; function fun()&#123; a = 10; &#125; fun(); // a 变成了10 JS中要想保证函数无副作用这项特性，只能依靠编程人员的习惯，即 函数入口使用参数运算，而不修改它 函数内不修改函数外的变量，如全局变量 运算结果通过函数返回给外部（出口）","permalink":"https://codermino.github.io/2020/10/16/%E5%89%AF%E4%BD%9C%E7%94%A8%E5%87%BD%E6%95%B0/","photos":[]},{"tags":[{"name":"vue3的watch和watchEffect","slug":"vue3的watch和watchEffect","permalink":"https://codermino.github.io/tags/vue3%E7%9A%84watch%E5%92%8CwatchEffect/"}],"title":"vue3的watch和watchEffect","date":"2020/10/16","text":"watchEffect它在响应跟踪依赖项的同时立即运行函数，并在依赖项发生更改时重新运行函数。用到那个属性，就会追踪哪个属性的变化 const count = ref(0) watchEffect(() =&gt; console.log(count.value)) // -&gt; logs 0 setTimeout(() =&gt; &#123; count.value++ // -&gt; logs 1 &#125;, 100) Stopping the WatcherWhen watchEffect is called during a component’s setup() function or lifecycle hooks,the watcher is linked to the component’s lifecycleand will be automatically stopped when the component is unmounted.In other cases, it returns a stop handle which can be called to explicitly stop the watcher: 当watchEffect在组件的setup()函数或者生命周期钩子函数中调用的时候，watcher被连接到组件的生命周期并且当组件卸载的时候自动停止。在其他情况下，它返回一个stop句柄函数能够被直接调用来停止观察。 const stop = watchEffect(() =&gt; &#123; /* ... */ &#125;) // later stop() Side Effect InvalidationSometimes the watched effect function will perform asynchronous side effectsthat need to be cleaned up when it is invalidated(i.e state changed before the effects can be completed).The effect function receives an onInvalidate functionthat can be used to register an invalidation callback.This invalidation callback is called when: the effect is about to re-run the watcher is stopped (i.e. when the component is unmounted if watchEffect is used inside setup() or lifecycle hooks)有时被观察的负作用函数将被表现为同步的负作用函数，需要被清理当它无效的时候。（例如状态被改变在相应完成之前）。负作用函数接收一个无效的function能够被用来注册一个无效化的回调函数。这个无效化回调函数能够被调用当： 这个结果即将被重新运行 当前的watcher被停止 如果watchEffect被使用在setup()或者生命周期钩子函数中，当这个组件被卸载的时候watchEffect(onInvalidate =&gt; &#123; // 这是一个异步函数 const token = performAsyncOperation(id.value) onInvalidate(() =&gt; &#123; // id has changed or watcher is stopped. // invalidate previously pending async operation token.cancel() &#125;) &#125;) Demo使用onInvalidate回调函数实现一个防抖操作子组件 const asyncEmit = val =&gt;&#123; return setTimeout(()=&gt;&#123; ctx.emit('inputChange',val) &#125;,500) &#125; ; watchEffect(onInvalidate =&gt; &#123; const timerId = asyncEmit(state.inputData); onInvalidate(() =&gt; &#123; // id has changed or watcher is stopped. // invalidate previously pending async operation clearTimeout(timerId) &#125;) &#125;) const inputChange = (e)=&gt;&#123; state.inputData = e.target.value &#125; 父组件 &lt;HelloWorld @inputChange=\"inputChange\" msg=\"Welcome to Your Vue.js App\"/&gt; const inputChange = (value)=&gt;&#123; console.log(value); &#125; We are registering the invalidation callback via a passed-in functioninstead of returning it from the callback because the return value isimportant for async error handling.It is very common for the effect functionto be an async function when performing data fetching:我们正在注册一个无效化回调通过function代替从回调中返回它因为这个返回的值是非常重要的对于异步错误处理。它是非常普遍的对于负作用函数作为一个异步方法表现为数据请求： const data = ref(null) watchEffect(async onInvalidate =&gt; &#123; onInvalidate(() =&gt; &#123;...&#125;) // we register cleanup function before Promise resolves data.value = await fetchData(props.id) &#125;) An async function implicitly returns a Promise,but the cleanup function needs to be registered immediatelybefore the Promise resolves. In addition,Vue relies on the returned Promise toautomatically handle potential errors in the Promise chain.一个异步函数隐式的返回一个Promise但是清理函数需要被立即注册在resolve这个Promise之前.另外，Vue依赖于返回的Promise去自动处理潜在的错误在Promise链中。 Effect Flush TimingwatcheEffect有另外一个参数来控制watchEffect的调用时间 这种方式的waTtchEffect是在onBeforeUpdate和onUpdated之前调用(flush默认值为pre) watchEffect(() =&gt; console.log(count.value)) 这种方式的waTtchEffect是在onBeforeUpdate之后和onUpdated之前调用 watchEffect( () =&gt; console.log(count.value), &#123; flush:'post' &#125; ) watchEffect( () =&gt; console.log(count.value), &#123; flush:'sync' &#125; ) onBeforeUpdate(() =&gt; &#123; console.log('onBeforeUpdate!') &#125;) onUpdated(() =&gt; &#123; console.log('onUpdated!') &#125;) setTimeout(() =&gt; &#123; count.value++ &#125;, 2000) Watcher DebuggingThe onTrack and onTrigger options can be used to debug a watcher’s behavior. onTrack will be called when a reactive property or ref is tracked as a dependency onTrigger will be called when the watcher callback is triggered by the mutation of a dependencyBoth callbacks will receive a debugger event which containsinformation on the dependency in question. It is recommendedto place a debugger statement in thesecallbacks to interactively inspect the dependency:onTrack和onTrigger选项能够被用来进行debugger onTrack能够被调用当一个响应式的属性和ref属性被追踪最为一个依赖 onTrigger将被调用当观察者回调被触发通过修改一个依赖这两个回调都将接受一个debugger事件，并且包含信息在这个依赖问题。它被记录来放置一个debugger语句在这些回调来交互检查这些依赖.watchEffect( () =&gt; &#123; /* side effect */ &#125;, &#123; onTrigger(e) &#123; debugger &#125; &#125; ) onTrack and onTrigger only work in development mode. 这两个回调函数仅仅在生产模式下起作用* watch对比Compared to watchEffect, watch allows us to: Perform the side effect lazily; Be more specific about what state should trigger the watcher to re-run; Access both the previous and current value of the watched state. 表现为惰性 更加明确或者具体的指明哪个属性应该触发这个观察者重新运行 同时接受观察的属性的之前的值和新的值 监听单一数据源Watching a Single Source// watching a getter const state = reactive(&#123; count: 0 &#125;) watch( () =&gt; state.count, // 或者() =&gt; &#123;return state.count&#125; (count, prevCount) =&gt; &#123; /* ... */ &#125; ) // directly watching a ref const count = ref(0) watch(count, (count, prevCount) =&gt; &#123; /* ... */ &#125;) 监听多个数据源Watching Multiple Sourceswatch([fooRef, barRef], ([foo, bar], [prevFoo, prevBar]) =&gt; &#123; /* ... */ &#125;) Shared Behavior with watchEffectwatch shares behavior with watchEffectin terms of manual stoppage,side effect invalidation (with onInvalidate passed to the callback as the 3rd argument instead),flush timing and debugging.watch和watchEffect同样具有stop、invalidation、flush timing和debugging等参数 Demo使用watch实现一个防抖操作 watch( ()=&gt;&#123; return state.inputData &#125;, (newValue,oldValue,onInvalidate)=&gt;&#123; // 执行异步任务，并得到关闭异步任务的 timerId const timerId = asyncEmit(newValue); // 如果 watch 监听被重复执行了，则会先清除上次未完成的异步任务 onInvalidate(() =&gt; &#123; clearTimeout(timerId) &#125;); &#125; ); watch的第二个option的参数 immediate:true,立即触发，例如当刷新页面的时候，如果没有这个属性， 那么第一次创建的时候不会触发watch deep:true深度监听,监听对象内部的属性变化也会触发watch Demo*监听路由变化watch( ()=&gt;&#123; return router &#125;, (value)=&gt;&#123; console.log(value.currentRoute.value.name); &#125;, &#123; immediate:true, deep:true &#125; ) Demo2*const age = ref(18) const state = reactive(&#123; count:0, employee:[ &#123;name:'张三',sex:'男'&#125;, &#123;name:'张三2',sex:'男'&#125;, &#123;name:'张三3',sex:'男'&#125;, &#123;name:'张三4',sex:'男'&#125;, &#123;name:'张三5',sex:'男'&#125; ] &#125;) watch( [age,()=&gt;state.count], ([newAge, newCount], [oldAge, oldCount]) =&gt; &#123; console.log(newAge, newCount); &#125; )","permalink":"https://codermino.github.io/2020/10/16/vue3%E7%9A%84watch%E5%92%8CwatchEffect/","photos":[]},{"tags":[{"name":"vue3的props和attrs","slug":"vue3的props和attrs","permalink":"https://codermino.github.io/tags/vue3%E7%9A%84props%E5%92%8Cattrs/"}],"title":"vue3的props和attrs","date":"2020/10/16","text":"都知道props这个属性而$attrs属性可以看做props的加强版，用来简化vue组件传值，那么这两个属性具体有什么区别呢？ props 要先声明才能取值，attrs 不用先声明 props 声明过的属性，attrs 里不会再出现 props 不包含事件，attrs 包含 props 支持 string 以外的类型，attrs 只有 string 类型 Demo父组件中引用子组件 msg传递的值，是通过props进行接受了 msg2没有被props接收&lt;HelloWorld msg=\"Welcome to Your Vue.js App\" msg2=\"true\"/&gt; 官方说明解释：包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)。 意思就是父组件往子组件传没有在props里声明过的值时，子组件可以通过$attrs接受， 且只包含父组件没有在props里声明的值。 父组件&lt;template&gt; &lt;div class&#x3D;&quot;home&quot;&gt; &lt;child gender&#x3D;&quot;male&quot; age&#x3D;&quot;18&quot;&#x2F;&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; import Child from &#39;..&#x2F;components&#x2F;Child&#39; export default &#123; name: &#39;home&#39;, components: &#123; Child, &#125; &lt;&#x2F;script&gt; 子组件&lt;template&gt; &lt;div&gt; -----------------Child------------------ &lt;br&gt; &lt;span&gt;gender: &#123;&#123;$attrs[&#39;gender&#39;]&#125;&#125;&lt;&#x2F;span&gt; &lt;br&gt; &lt;span&gt;age: &#123;&#123;$attrs[&#39;age&#39;]&#125;&#125;&lt;&#x2F;span&gt; &lt;br&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default &#123; name: &#39;Child&#39; &#125; &lt;&#x2F;script&gt; &lt;style&gt; &lt;&#x2F;style&gt;","permalink":"https://codermino.github.io/2020/10/16/vue3%E7%9A%84props%E5%92%8Cattrs/","photos":[]},{"tags":[{"name":"css对话框旁边的箭头","slug":"css对话框旁边的箭头","permalink":"https://codermino.github.io/tags/css%E5%AF%B9%E8%AF%9D%E6%A1%86%E6%97%81%E8%BE%B9%E7%9A%84%E7%AE%AD%E5%A4%B4/"}],"title":"css对话框旁边的箭头","date":"2020/10/15","text":"无意中看到的效果 &lt;div class=\"demo\"&gt;&lt;/div&gt; &lt;style&gt; .demo&#123; width:0; height:0px; border:100px solid transparent; border-color:#f00 #ff0 #05f #0f0; &#125; &lt;/style&gt; 直接设置一个边框的大小，然后颜色顺序：上、右、下、左；是不是感觉很神奇呢。 css三角形1.实现一个简单的三角形使用CSS盒模型中的border（边框）即可实现如下所示的三角形： 实现原理：首先来看在为元素添加border时，border的样子；假设有如下代码： &lt;div&gt;&lt;/div&gt; div &#123; width: 50px; height: 50px; border: 2px solid orange; &#125; 效果这是我们平常使用border最普遍的情况——往往只给border一个较小的宽度（通常为1-2px）；然而这样的日常用法就会容易让大家对border的形成方式产生误解，即认为元素的border是由四个矩形边框拼接而成。 然而事实并不是这样。实际上，元素的border是由三角形组合而成，为了说明这个问题，我们可以增大border的宽度，并为各border边设置不同的颜色： div &#123; width: 50px; height: 50px; border: 40px solid; border-color: orange blue red green; &#125; 效果图： 既然如此，那么更进一步，把元素的内容尺寸设置为0会发生什么情况呢？ div &#123; width: 0; height: 0; border: 40px solid; border-color: orange blue red green; &#125; 效果我们将惊奇地发现，此时元素由上下左右4个三角形“拼接”而成；那么，为了实现最终的效果，即保留最下方的三角形，还应该怎么做？很简单，我们只需要把其它border边的颜色设置为白色或透明色： div &#123; width: 0; height: 0; border: 40px solid; border-color: transparent transparent red; &#125; 最终的简单三角形就绘制出来了。同理，如果想要得到其它边上的三角形，只需要将剩余的border边颜色设置为白色或透明色即可。 不过，被“隐藏”的上border仍然占据着空间，要想使得绘制出的三角形尺寸最小化，还需要将上border的宽度设置为0（其它情况同理）： div &#123; width: 0; height: 0; border-width: 0 40px 40px; border-style: solid; border-color: transparent transparent red; &#125; 2.实现带边框的三角形带边框的三角形是指为三角形添加其它颜色的边框，如同为元素添加border一样：由于不能继续通过为已有三角形设置border的方法来为其设置边框（因为三角形本身就是利用border实现的），所以只好另想办法。而能想到的一个最自然的方法就是三角形叠放，即把当前三角形叠放在更大的三角形上方，上图所示的实现方法就是把黄色三角形放在了尺寸更大的蓝色三角形上。 为了实现这样的效果，需要利用绝对定位方法：首先定义出外面的蓝色三角形： &lt;div id=\"blue\"&gt;&lt;div&gt; #blue &#123; position:relative; width: 0; height: 0; border-width: 0 40px 40px; border-style: solid; border-color: transparent transparent blue; &#125; 效果随后需要定义黄色三角形，由于黄色三角形的定位需要参考蓝色三角形的位置，所以需要用到绝对定位方法。为此还需要将黄色三角形作为蓝色三角形的子元素。一个可行的办法是在蓝色三角形内部定义一个额外的标签以表示黄色三角形，但为了节约标签起见，更好的办法是使用伪元素: #blue:after &#123; content: \"\"; width: 0; height: 0; position: absolute; top: 0px; left: 0px; border-width: 0 40px 40px; border-style: solid; border-color: transparent transparent yellow; &#125; 得到的效果需要特别注意此时定义出的黄色三角形与蓝色三角形之间位置的偏移关系，该偏移将受到top、left（本例中）以及黄色三角形本身border宽度的共同影响。 可能会有这样的疑问：为什么黄色三角形会向左偏移一段距离呢，按道理不应该完全重合在蓝色三角形上吗，就像下面这样？如果有这样的疑问，说明还没有对绝对定位产生足够的认识。绝对定位的区域是基于绝对定位父元素的padding区域，然后在此基础上运用top、left、right、bottom等一系列属性来约束绝对定位子元素的位置。在本例中，由于蓝色三角形作为绝对定位父元素，其内容的尺寸为0，则内容区域就是该三角形的上顶点：对于黄色三角形，由于设置了left: 0和top: 0，所以黄色三角形的所有内容（包括border、margin）将根据蓝色三角形的上顶点进行定位。可以把此时left: 0和top: 0分别看作是两面“隔墙”——即上隔墙和左隔墙，黄色三角形的所有内容只能在上隔墙的下方和左隔墙的右方区域。 由于黄色三角形的内容区域也位于其顶点处，且对其设置了左右各40px的border，所以黄色三角形的内容区域将向右偏移40px，从而形成了之前的效果。 想想看将黄色三角形的位置设置为left: 0和bottom: 0,会得到怎样的定位效果？（下图所示）搞懂了绝对定位后，只需要在原代码上稍作修改就可以将黄色三角形的顶点与蓝色三角形顶点相重合，同时还应该适当缩小黄色三角形的尺寸（按相似三角形等比例缩小）： #blue:after &#123; content: \"\"; position: absolute; top: 0px; left: -38px; border-width: 0 38px 38px; border-style: solid; border-color: transparent transparent yellow; &#125; 效果在上面的代码中，特意删除了之前对width: 0和height: 0的设置，因为子元素具有position:absolute设置，这会使得元素尺寸在不显式设置宽度和高度的情况下，收缩到元素内容的尺寸，由于内容设置的是content: “”，所以子元素的尺寸默认也就是0了。故设置width: 0和height: 0就变得多余了。 最后一步就是利用top将黄色三角形向下移动至合适的位置： #blue:after &#123; content: \"\"; position: absolute; top: 1px; left: -38px; border-width: 0 38px 38px; border-style: solid; border-color: transparent transparent yellow; &#125; 最终效果：学会了带边框三角形的绘制，那么实现类似如下三角形箭头自然也是不在话下了：代码 #blue:after &#123; content: \"\"; position: absolute; top: 2px; left: -38px; border-width: 0 38px 38px; border-style: solid; border-color: transparent transparent #fff; &#125; 3.绘制其它角度的三角形绘制其它角度的三角形，如：或者就更简单了，其实它们都是基于之前绘制的三角形而来的。如果想绘制右直角三角，则将左border设置为0；如果想绘制左直角三角，将右border设置为0即可（其它情况同理）。 Demodiv &#123; width: 0; height: 0; border: 40px solid; border-left: 0; border-color: transparent transparent red; &#125;","permalink":"https://codermino.github.io/2020/10/15/css%E5%AF%B9%E8%AF%9D%E6%A1%86%E6%97%81%E8%BE%B9%E7%9A%84%E7%AE%AD%E5%A4%B4/","photos":[]},{"tags":[{"name":"vue生命周期和MVVM","slug":"vue生命周期和MVVM","permalink":"https://codermino.github.io/tags/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8CMVVM/"}],"title":"vue生命周期和MVVM","date":"2020/10/15","text":"一、MVVM模式MVVM 是Model-View-ViewModel 的缩写， 它是一种基于前端开发的架构模式， 其核心是提供对View 和 ViewModel 的双向数据绑定， 这使得ViewModel 的状态改变可以自动传递给 View，即所谓的数据双向绑定。 Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑； View 代表UI 组件，它负责将数据模型转化成UI 展现出来， ViewModel 是一个同步View 和 Model的对象。在MVVM架构下， View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互， Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中， 而Model 数据的变化也会立即反应到View 上。 Vue.js 是一个提供了 MVVM 风格的双向数据绑定的 Javascript 库， 专注于View 层。它的核心是 MVVM 中的 VM，也就是 ViewModel。 ViewModel负责连接 View 和 Model，保证视图和数据的一致性，这种轻量级的架构让前端开发更加高效、便捷。 二、生命周期Vue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载Dom、渲染→更新→渲染、销毁等一系列过程，我们称这是Vue的生命周期。通俗说就是Vue实例从创建到销毁的过程，就是生命周期。总共分为8个阶段如下所示： beforeCreate—-创建前：组件实例被创建时，组件属性计算之前，数据对象data都为undefined，未初始化。 created—-创建后：组件实例创建完成，属性已经绑定，数据对象data已存在，但dom未生成，$el未存在。 beforeMount—挂载前：vue实例的$el和data都已初始化，挂载之前为虚拟的dom节点，data.message未替换。 mounted—–挂载后：vue实例挂载完成，data.message成功渲染。 beforeUpdate—-更新前：当data变化时，会触发beforeUpdate方法。 updated—-更新后：当data变化时，会触发updated方法。 beforeDestory—销毁前：组件销毁之前调用。 destoryed—销毁后： 组件销毁之后调用，对data的改变不会再触发周期函数，vue实例已解除事件监听和dom绑定， 但dom结构依然存在。 三、生命周期图解 什么是生命周期? 简而言之:从生到死的过程,从Vue实例创建-运行-销毁的过程 Vue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载Dom、渲染→更新→渲染、销毁等一系列过程 生命周期方法? Vue从生到死的过程中伴随着各种各样的事件,这些事件会自动触发一些方法.这些方法我们统称为生命周期方法 生命周期钩子 = 生命周期函数 = 生命周期事件 创建期间生命周期方法 beforeCreate: created: beforeMount mounted 运行期间生命周期方法 beforeUpdate updated 销毁期间的生命周期方法 beforeDestroy destroyed &lt;!DOCTYPE html&gt; &lt;html lang&#x3D;&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;Vue生命周期方法&lt;&#x2F;title&gt; &lt;!--引入vue框架--&gt; &lt;script src&#x3D;&quot;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;div id&#x3D;&quot;app&quot;&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;p&gt; &lt;&#x2F;div&gt; &lt;script&gt; let vm &#x3D; new Vue(&#123; el:&#39;#app&#39;, data:&#123; msg:&quot;IT程序员的日常&quot; &#125;, methods:&#123; say:function () &#123; console.log(&quot;IT程序员的日常&quot;); &#125; &#125;, beforeCreate:function () &#123; &#x2F;*执行beforeCreate的时候,表示Vue刚刚出生,还没有任何内容,data&#x2F;methods都没有初始化*&#x2F; &#x2F;&#x2F;console.log(this.msg); &#x2F;&#x2F;this.say(); &#x2F;&#x2F;console.log(this.say); &#125;, created:function () &#123; &#x2F;*执行created的时候,表示Vue实例已经初始化好了部分内容,data&#x2F;methods * 想在Vue实例中最早访问到data&#x2F;methods,只有在这个方法才能访问 *&#x2F; &#x2F;&#x2F;console.log(this.msg); &#x2F;&#x2F;this.say(); &#x2F;&#x2F; console.log(this.say); &#125;, beforeMount:function () &#123; &#x2F;*执行beforeMount,表示已经根据数据编译好了模板,但是还没有渲染到界面上*&#x2F; &#x2F;&#x2F; console.log(document.querySelector(&quot;p&quot;).innerText); &#x2F;&#x2F; console.log(document.querySelector(&quot;p&quot;).innerHTML); &#125;, mounted:function () &#123; &#x2F;*执行mounted,表示已经根据数据编译好了模板,已经将模板有渲染到界面上,此时可以对界面进行其他操作了*&#x2F; console.log(document.querySelector(&quot;p&quot;).innerText); console.log(document.querySelector(&quot;p&quot;).innerHTML); &#125;, beforeUpdate:function()&#123; &#x2F;*主要data中的数据发生了变化就会执行 * 执行beforeUpdate时候,data的数据已经是最新的了,但是没有更新界面上的数据 * * *&#x2F; &#x2F;&#x2F; console.log(this.msg); &#x2F;&#x2F; console.log(document.querySelector(&quot;p&quot;).innerText); &#x2F;&#x2F; console.log(document.querySelector(&quot;p&quot;).innerHTML); &#125;, updated:function () &#123; &#x2F;*主要data中的数据发生了变化就会执行 * 执行updated时候,data的数据已经是最新的了,界面上的数据也已经更新 * * *&#x2F; console.log(this.msg); console.log(document.querySelector(&quot;p&quot;).innerText); console.log(document.querySelector(&quot;p&quot;).innerHTML); &#125;, beforeDestroy:function()&#123; &#x2F;*执行beforeDestroy的时候,表示Vue实例即将销毁,但是还未销毁,实例中的数据等都可以使用 * 最后能使用Vue实例的地址 * *&#x2F; &#125;, destroyed:function () &#123; &#x2F;* * 执行destroyed的时候,表示vue实例完全销毁,实例中的任何内容都不能被使用了 * *&#x2F; &#125; &#125;) &lt;&#x2F;script&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt;","permalink":"https://codermino.github.io/2020/10/15/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8CMVVM/","photos":[]},{"tags":[{"name":"vue数据双向绑定原理","slug":"vue数据双向绑定原理","permalink":"https://codermino.github.io/tags/vue%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86/"}],"title":"vue数据双向绑定原理","date":"2020/10/15","text":"vue实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式， 通过 Object.defineProperty() 来劫持各个属性的setter，getter， 在数据变动时发布消息给订阅者，触发相应监听回调。 当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时， Vue 将遍历它的属性，用 Object.defineProperty() 将它们转为 getter/setter。 用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。 vue的数据双向绑定 将MVVM作为数据绑定的入口， 整合Observer，Compile和Watcher三者，通过Observer来监听自己的model的数据变化， 通过Compile来解析编译模板指令（vue中是用来解析 &#123;&#123;&#125;&#125;）， 最终利用watcher搭起observer和Compile之间的通信桥梁， 达到数据变化 —&gt;视图更新；视图交互变化（input）—&gt;数据model变更双向绑定效果。 js实现简单的双向绑定：","permalink":"https://codermino.github.io/2020/10/15/vue%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86/","photos":[]},{"tags":[{"name":"vue的is属性","slug":"vue的is属性","permalink":"https://codermino.github.io/tags/vue%E7%9A%84is%E5%B1%9E%E6%80%A7/"}],"title":"vue的is属性","date":"2020/10/15","text":"vue的is属性简单说就是扩展 html标签的限制错误写法 正确写法通过 ：is 切换不同的组件可以任何 容器 使用 ：is","permalink":"https://codermino.github.io/2020/10/15/vue%E7%9A%84is%E5%B1%9E%E6%80%A7/","photos":[]},{"tags":[{"name":"proxy笔记","slug":"proxy笔记","permalink":"https://codermino.github.io/tags/proxy%E7%AC%94%E8%AE%B0/"}],"title":"proxy笔记","date":"2020/10/14","text":"一、proxy概述Proxy的兼容性 proxy在目标对象的外层搭建了一层拦截，外界对目标对象的某些操作，必须通过这层拦截 var proxy = new Proxy(target, handler); new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象， handler参数也是一个对象，用来定制拦截行为 var target = &#123; name: 'poetries' &#125;; var logHandler = &#123; get: function(target, key) &#123; console.log(`$&#123;key&#125; 被读取`); return target[key]; &#125;, set: function(target, key, value) &#123; console.log(`$&#123;key&#125; 被设置为 $&#123;value&#125;`); target[key] = value; &#125; &#125; var targetWithLog = new Proxy(target, logHandler); targetWithLog.name; // 控制台输出：name 被读取 targetWithLog.name = 'others'; // 控制台输出：name 被设置为 others console.log(target.name); // 控制台输出: others targetWithLog 读取属性的值时，实际上执行的是 logHandler.get ：在控制台输出信息，并且读取被代理对象 target 的属性。 在targetWithLog 设置属性值时，实际上执行的是 logHandler.set ：在控制台输出信息，并且设置被代理对象 target 的属性的值// 由于拦截函数总是返回35，所以访问任何属性都得到35 var proxy = new Proxy(&#123;&#125;, &#123; get: function(target, property) &#123; return 35; &#125; &#125;); proxy.time // 35 proxy.name // 35 proxy.title // 35 Proxy 实例也可以作为其他对象的原型对象var proxy = new Proxy(&#123;&#125;, &#123; get: function(target, property) &#123; return 35; &#125; &#125;); let obj = Object.create(proxy); obj.time // 35 proxy对象是obj对象的原型，obj对象本身并没有time属性，所以根据原型链，会在proxy对象上读取该属性，导致被拦截 Proxy的作用对于代理模式 Proxy 的作用主要体现在三个方面 拦截和监视外部对对象的访问 降低函数或类的复杂度 在复杂操作前对操作进行校验或对所需资源进行管理二、Proxy所能代理的范围–handler实际上 handler 本身就是ES6所新设计的一个对象. 它的作用就是用来自定义代理对象的各种可代理操作 。 它本身一共有13中方法,每种方法都可以代理一种操作.其13种方法如下 // 在读取代理对象的原型时触发该操作，比如在执行 Object.getPrototypeOf(proxy) 时。 handler.getPrototypeOf() // 在设置代理对象的原型时触发该操作，比如在执行 Object.setPrototypeOf(proxy, null) 时。 handler.setPrototypeOf() // 在判断一个代理对象是否是可扩展时触发该操作，比如在执行 Object.isExtensible(proxy) 时。 handler.isExtensible() // 在让一个代理对象不可扩展时触发该操作，比如在执行 Object.preventExtensions(proxy) 时。 handler.preventExtensions() // 在获取代理对象某个属性的属性描述时触发该操作，比如在执行 Object.getOwnPropertyDescriptor(proxy, \"foo\") 时。 handler.getOwnPropertyDescriptor() // 在定义代理对象某个属性时的属性描述时触发该操作，比如在执行 Object.defineProperty(proxy, \"foo\", &#123;&#125;) 时。 andler.defineProperty() // 在判断代理对象是否拥有某个属性时触发该操作，比如在执行 \"foo\" in proxy 时。 handler.has() // 在读取代理对象的某个属性时触发该操作，比如在执行 proxy.foo 时。 handler.get() // 在给代理对象的某个属性赋值时触发该操作，比如在执行 proxy.foo = 1 时。 handler.set() // 在删除代理对象的某个属性时触发该操作，比如在执行 delete proxy.foo 时。 handler.deleteProperty() // 在获取代理对象的所有属性键时触发该操作，比如在执行 Object.getOwnPropertyNames(proxy) 时。 handler.ownKeys() // 在调用一个目标对象为函数的代理对象时触发该操作，比如在执行 proxy() 时。 handler.apply() // 在给一个目标对象为构造函数的代理对象构造实例时触发该操作，比如在执行new proxy() 时。 handler.construct() 三、Proxy场景3.1 实现私有变量var target = &#123; name: 'poetries', _age: 22 &#125; var logHandler = &#123; get: function(target,key)&#123; if(key.startsWith('_'))&#123; console.log('私有变量age不能被访问') return false &#125; return target[key]; &#125;, set: function(target, key, value) &#123; if(key.startsWith('_'))&#123; console.log('私有变量age不能被修改') return false &#125; target[key] = value; &#125; &#125; var targetWithLog = new Proxy(target, logHandler); // 私有变量age不能被访问 targetWithLog.name; // 私有变量age不能被修改 targetWithLog.name = 'others'; 在下面的代码中，我们声明了一个私有的 apiKey，便于 api 这个对象内部的方法调用，但不希望从外部也能够访问 api._apiKey var api = &#123; _apiKey: '123abc456def', /* mock methods that use this._apiKey */ getUsers: function()&#123;&#125;, getUser: function(userId)&#123;&#125;, setUser: function(userId, config)&#123;&#125; &#125;; // logs '123abc456def'; console.log(\"An apiKey we want to keep private\", api._apiKey); // get and mutate _apiKeys as desired var apiKey = api._apiKey; api._apiKey = '987654321'; 很显然，约定俗成是没有束缚力的。使用 ES6 Proxy 我们就可以实现真实的私有变量了， 下面针对不同的读取方式演示两个不同的私有化方法。 第一种方法是使用 set / get 拦截读写请求并返回 undefined: let api = &#123; _apiKey: '123abc456def', getUsers: function()&#123; &#125;, getUser: function(userId)&#123; &#125;, setUser: function(userId, config)&#123; &#125; &#125;; const RESTRICTED = ['_apiKey']; api = new Proxy(api, &#123; get(target, key, proxy) &#123; if(RESTRICTED.indexOf(key) &gt; -1) &#123; throw Error(`$&#123;key&#125; is restricted. Please see api documentation for further info.`); &#125; return Reflect.get(target, key, proxy); &#125;, set(target, key, value, proxy) &#123; if(RESTRICTED.indexOf(key) &gt; -1) &#123; throw Error(`$&#123;key&#125; is restricted. Please see api documentation for further info.`); &#125; return Reflect.get(target, key, value, proxy); &#125; &#125;); // 以下操作都会抛出错误 console.log(api._apiKey); api._apiKey = '987654321'; 第二种方法是使用 has 拦截 in 操作 var api = &#123; _apiKey: '123abc456def', getUsers: function()&#123; &#125;, getUser: function(userId)&#123; &#125;, setUser: function(userId, config)&#123; &#125; &#125;; const RESTRICTED = ['_apiKey']; api = new Proxy(api, &#123; has(target, key) &#123; return (RESTRICTED.indexOf(key) &gt; -1) ? false : Reflect.has(target, key); &#125; &#125;); // these log false, and `for in` iterators will ignore _apiKey console.log(\"_apiKey\" in api); for (var key in api) &#123; if (api.hasOwnProperty(key) &amp;&amp; key === \"_apiKey\") &#123; console.log(\"This will never be logged because the proxy obscures _apiKey...\") &#125; &#125; 3.2 抽离校验模块让我们从一个简单的类型校验开始做起， 这个示例演示了如何使用 Proxy 保障数据类型的准确性 let numericDataStore = &#123; count: 0, amount: 1234, total: 14 &#125;; numericDataStore = new Proxy(numericDataStore, &#123; set(target, key, value, proxy) &#123; if (typeof value !== 'number') &#123; throw Error(\"Properties in numericDataStore can only be numbers\"); &#125; return Reflect.set(target, key, value, proxy); &#125; &#125;); // 抛出错误，因为 \"foo\" 不是数值 numericDataStore.count = \"foo\"; // 赋值成功 numericDataStore.count = 333; 如果要直接为对象的所有属性开发一个校验器可能很快就会让代码结构变得臃肿， 使用 Proxy 则可以将校验器从核心逻辑分离出来自成一体 function createValidator(target, validator) &#123; return new Proxy(target, &#123; _validator: validator, set(target, key, value, proxy) &#123; if (target.hasOwnProperty(key)) &#123; let validator = this._validator[key]; if (!!validator(value)) &#123; return Reflect.set(target, key, value, proxy); &#125; else &#123; throw Error(`Cannot set $&#123;key&#125; to $&#123;value&#125;. Invalid.`); &#125; &#125; else &#123; throw Error(`$&#123;key&#125; is not a valid property`) &#125; &#125; &#125;); &#125; const personValidators = &#123; name(val) &#123; return typeof val === 'string'; &#125;, age(val) &#123; return typeof age === 'number' &amp;&amp; age &gt; 18; &#125; &#125; class Person &#123; constructor(name, age) &#123; this.name = name; this.age = age; return createValidator(this, personValidators); &#125; &#125; const bill = new Person('Bill', 25); // 以下操作都会报错 bill.name = 0; bill.age = 'Bill'; bill.age = 15; 通过校验器和主逻辑的分离，你可以无限扩展 personValidators 校验器的内容， 而不会对相关的类或函数造成直接破坏。 更复杂一点，我们还可以使用 Proxy 模拟类型检查， 检查函数是否接收了类型和数量都正确的参数 let obj = &#123; pickyMethodOne: function(obj, str, num) &#123; /* ... */ &#125;, pickyMethodTwo: function(num, obj) &#123; /*... */ &#125; &#125;; const argTypes = &#123; pickyMethodOne: [\"object\", \"string\", \"number\"], pickyMethodTwo: [\"number\", \"object\"] &#125;; obj = new Proxy(obj, &#123; get: function(target, key, proxy) &#123; var value = target[key]; return function(...args) &#123; var checkArgs = argChecker(key, args, argTypes[key]); return Reflect.apply(value, target, args); &#125;; &#125; &#125;); function argChecker(name, args, checkers) &#123; for (var idx = 0; idx &lt; args.length; idx++) &#123; var arg = args[idx]; var type = checkers[idx]; if (!arg || typeof arg !== type) &#123; console.warn(`You are incorrectly implementing the signature of $&#123;name&#125;. Check param $&#123;idx + 1&#125;`); &#125; &#125; &#125; obj.pickyMethodOne(); // &gt; You are incorrectly implementing the signature of pickyMethodOne. Check param 1 // &gt; You are incorrectly implementing the signature of pickyMethodOne. Check param 2 // &gt; You are incorrectly implementing the signature of pickyMethodOne. Check param 3 obj.pickyMethodTwo(\"wopdopadoo\", &#123;&#125;); // &gt; You are incorrectly implementing the signature of pickyMethodTwo. Check param 1 // No warnings logged obj.pickyMethodOne(&#123;&#125;, \"a little string\", 123); obj.pickyMethodOne(123, &#123;&#125;); 3.3 访问日志对于那些调用频繁、运行缓慢或占用执行环境资源较多的属性或接口， 开发者会希望记录它们的使用情况或性能表现， 这个时候就可以使用 Proxy 充当中间件的角色，轻而易举实现日志功能 let api = &#123; _apiKey: '123abc456def', getUsers: function() &#123; /* ... */ &#125;, getUser: function(userId) &#123; /* ... */ &#125;, setUser: function(userId, config) &#123; /* ... */ &#125; &#125;; function logMethodAsync(timestamp, method) &#123; setTimeout(function() &#123; console.log(`$&#123;timestamp&#125; - Logging $&#123;method&#125; request asynchronously.`); &#125;, 0) &#125; api = new Proxy(api, &#123; get: function(target, key, proxy) &#123; var value = target[key]; return function(...arguments) &#123; logMethodAsync(new Date(), key); return Reflect.apply(value, target, arguments); &#125;; &#125; &#125;); api.getUsers(); 3.4 预警和拦截假设你不想让其他开发者删除 noDelete 属性， 还想让调用 oldMethod 的开发者了解到这个方法已经被废弃了， 或者告诉开发者不要修改 doNotChange 属性，那么就可以使用 Proxy 来实现 let dataStore = &#123; noDelete: 1235, oldMethod: function() &#123;/*...*/ &#125;, doNotChange: \"tried and true\" &#125;; const NODELETE = ['noDelete']; const NOCHANGE = ['doNotChange']; const DEPRECATED = ['oldMethod']; dataStore = new Proxy(dataStore, &#123; set(target, key, value, proxy) &#123; if (NOCHANGE.includes(key)) &#123; throw Error(`Error! $&#123;key&#125; is immutable.`); &#125; return Reflect.set(target, key, value, proxy); &#125;, deleteProperty(target, key) &#123; if (NODELETE.includes(key)) &#123; throw Error(`Error! $&#123;key&#125; cannot be deleted.`); &#125; return Reflect.deleteProperty(target, key); &#125;, get(target, key, proxy) &#123; if (DEPRECATED.includes(key)) &#123; console.warn(`Warning! $&#123;key&#125; is deprecated.`); &#125; var val = target[key]; return typeof val === 'function' ? function(...args) &#123; Reflect.apply(target[key], target, args); &#125; : val; &#125; &#125;); // these will throw errors or log warnings, respectively dataStore.doNotChange = \"foo\"; delete dataStore.noDelete; dataStore.oldMethod(); 3.5 过滤操作某些操作会非常占用资源，比如传输大文件，这个时候如果文件已经在分块发送了， 就不需要在对新的请求作出相应（非绝对），这个时候就可以使用 Proxy 对当请求进行特征检测，并根据特征过滤出哪些是不需要响应的，哪些是需要响应的。 下面的代码简单演示了过滤特征的方式，并不是完整代码，相信大家会理解其中的妙处 let obj = &#123; getGiantFile: function(fileId) &#123;/*...*/ &#125; &#125;; obj = new Proxy(obj, &#123; get(target, key, proxy) &#123; return function(...args) &#123; const id = args[0]; let isEnroute = checkEnroute(id); let isDownloading = checkStatus(id); let cached = getCached(id); if (isEnroute || isDownloading) &#123; return false; &#125; if (cached) &#123; return cached; &#125; return Reflect.apply(target[key], target, args); &#125; &#125; &#125;); 3.6 中断代理Proxy 支持随时取消对 target 的代理，这一操作常用于完全封闭对数据或接口的访问。 在下面的示例中，我们使用了 Proxy.revocable 方法创建了可撤销代理的代理对象： let sensitiveData = &#123; username: 'devbryce' &#125;; const &#123;sensitiveData, revokeAccess&#125; = Proxy.revocable(sensitiveData, handler); function handleSuspectedHack()&#123; revokeAccess(); &#125; // logs 'devbryce' console.log(sensitiveData.username); handleSuspectedHack(); // TypeError: Revoked console.log(sensitiveData.username);","permalink":"https://codermino.github.io/2020/10/14/proxy%E7%AC%94%E8%AE%B0/","photos":[]},{"tags":[{"name":"js深拷贝和浅拷贝","slug":"js深拷贝和浅拷贝","permalink":"https://codermino.github.io/tags/js%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/"}],"title":"js深拷贝和浅拷贝","date":"2020/10/13","text":"浅拷贝// 浅拷贝只是拷贝一层, 更深层次对象级别的只拷贝引用. // 深拷贝拷贝多层, 每一级别的数据都会拷贝. var obj = &#123; id: 1, name: 'andy', msg: &#123; age: 18 &#125; &#125;; var o = &#123;&#125;; // for (var k in obj) &#123; // // k 是属性名 obj[k] 属性值 // o[k] = obj[k]; // &#125; // console.log(o); // o.msg.age = 20; // console.log(obj); console.log('--------------'); Object.assign(o, obj); console.log(o); o.msg.age = 20; console.log(obj); console.log('--------------'); Object.assign(o, obj); console.log(o); o.msg.age = 20; console.log(obj); let o2 = &#123;...obj&#125;; console.log(o2); o2.msg.age = 30; console.log(obj); 深拷贝// 深拷贝拷贝多层, 每一级别的数据都会拷贝. var obj = &#123; id: 1, name: 'andy', msg: &#123; age: 18 &#125;, color: ['pink', 'red'] &#125;; var o = &#123;&#125;; // 封装函数 function deepCopy(newobj, oldobj) &#123; for (var k in oldobj) &#123; // 判断我们的属性值属于那种数据类型 // 1. 获取属性值 oldobj[k] var item = oldobj[k]; // 2. 判断这个值是否是数组 if (item instanceof Array) &#123; newobj[k] = []; deepCopy(newobj[k], item) &#125; else if (item instanceof Object) &#123; // 3. 判断这个值是否是对象 newobj[k] = &#123;&#125;; deepCopy(newobj[k], item) &#125; else &#123; // 4. 属于简单数据类型 newobj[k] = item; &#125; &#125; &#125; deepCopy(o, obj); console.log(o); var arr = []; console.log(arr instanceof Object); o.msg.age = 20; console.log(obj); function deepCopy2(target)&#123; let copyed_objs = [];//此数组解决了循环引用和相同引用的问题，它存放已经递归到的目标对象 function _deepCopy(target)&#123; if((typeof target !== 'object')||!target)&#123;return target;&#125; for(let i= 0 ;i&lt;copyed_objs.length;i++)&#123; if(copyed_objs[i].target === target)&#123; return copyed_objs[i].copyTarget; &#125; &#125; let obj = &#123;&#125;; if(Array.isArray(target))&#123; obj = [];//处理target是数组的情况 &#125; copyed_objs.push(&#123;target:target,copyTarget:obj&#125;); Object.keys(target).forEach(key=&gt;&#123; if(obj[key])&#123; return;&#125; obj[key] = _deepCopy(target[key]); &#125;); return obj; &#125; return _deepCopy(target); &#125; let o2 = deepCopy2(o); console.log(o2); o2.msg.age = 20; console.log(obj); 深拷贝Demo2function deepClone(obj) &#123; var newObj = obj instanceof Array ? [] : &#123;&#125;; if (typeof obj !== 'object') &#123; return obj; &#125; else &#123; for (let i in obj) &#123; newObj[i] = typeof obj[i] === 'object' ? deepClone(obj[i]) : obj[i]; &#125; &#125; return newObj; &#125; var a = [1, 2, 4, 6, \"a\", \"12\", [1, 2],[&#123;name:'zs',age:18&#125;,&#123;name:'zs',age:18&#125;]]; var b = deepClone(a); a[3] = 7; a[7][0].name='sunhe' console.log(a); console.log(b); var obj = &#123; id: 1, name: 'andy', msg: &#123; age: 18 &#125;, color: ['pink', 'red'] &#125;; let data = deepClone(obj) console.log(data)","permalink":"https://codermino.github.io/2020/10/13/js%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/","photos":[]},{"tags":[{"name":"fetch用法","slug":"fetch用法","permalink":"https://codermino.github.io/tags/fetch%E7%94%A8%E6%B3%95/"}],"title":"fetch用法","date":"2020/10/12","text":"介绍fetch是新一代XMLHttpRequest的一种替代方案。无需安装其他库。可以在浏览器中直接提供其提供的api轻松与后台进行数据交互。 基本用法fetch（url，&#123;parmas&#125;）.then(res&#x3D;&gt; return res.json() &#x2F;&#x2F;返回promise对象 ).then(data&#x3D;&gt;&#123; return data &#x2F;&#x2F;返回真正数据 &#125;).catch(err&#x3D;&gt;&#123; throw new Error(err) &#125;) get方式fetch(&#96;&#x2F;api&#x2F;goodbook&#x2F;catalog?key&#x3D;d6c40ecb5a128109903810ca9c21d878&amp;dtype&#x3D;&#39;json&#39;&#96;) .then(res &#x3D;&gt; &#123; return res.json(); &#125;) .then(res &#x3D;&gt; &#123; &#x2F;&#x2F; 这里返回的数据就是我们想要请求的json数据 console.log(res); &#125;) post方式fetch(url+&quot;&#x2F;stats&#x2F;getUserList&quot;,&#123; method:&quot;POST&quot;, headers:&#123; &#39;Content-Type&#39;: &#39;application&#x2F;x-www-form-urlencoded&#39; &#125;, body:qs.stringify(data) &#125;).then(res&#x3D;&gt;&#123; console.log(res) return res.json(); &#125;).then(data&#x3D;&gt;&#123; console.log(&quot;返回值：&quot;,data) &#125;).catch(err&#x3D;&gt;&#123; console.log(err) &#125;) Demofetch(&#39;http:&#x2F;&#x2F;localhost:3000&#x2F;books&#39;, &#123; method: &#39;post&#39;, body: JSON.stringify(&#123; uname: &#39;zhangsan&#39;, pwd: &#39;456&#39; &#125;), headers: &#123; &#39;Content-Type&#39;: &#39;application&#x2F;json&#39; &#125; &#125;) .then(function(data) &#123; &#x2F;&#x2F; return data.text(); return response.json(); &#125;).then(function(data) &#123; console.log(data); &#125;) note fetch返回的是promise对象。所以fetch().then()第一个then里返回的并不是真正的数据。 而是一个promise，所以我们需要通过链式操作第二个then()来获取真正的数据。 fetch发送参数是通过body字段来实现的。body是fetch第二个参数的必选参数之一。 params的参数如下:* method(String): HTTP请求方法，默认为GET * body(String): HTTP的请求参数 * headers(Object): HTTP的请求头，默认为{} * credentials(String): 默认为omit,忽略的意思，也就是不带cookie;还有两个参数， same-origin，意思就是同源请求带cookie；include,表示无论跨域还是同源请求都会带cookie body带的参数是一个序列化以后的字符串。类似 name=”coc”&amp;age=30.所以这里我们通过qs库进行了序列化。","permalink":"https://codermino.github.io/2020/10/12/fetch%E7%94%A8%E6%B3%95/","photos":[]},{"tags":[{"name":"vite笔记","slug":"vite笔记","permalink":"https://codermino.github.io/tags/vite%E7%AC%94%E8%AE%B0/"}],"title":"vitenote","date":"2020/10/12","text":"vite的优点 快如闪电的轻量级的冷服务启动 瞬间的热更新 真正的随机应变的编译 能够了解更多的细节和为什么 开始note:目前vite只工作在vue3的版本上，也就是说vue2的版本是无法使用的 $ npm init vite-app &lt;project-name&gt; $ cd &lt;project-name&gt; $ npm install $ npm run dev 对编译的支持TypeScriptVite supports importing .ts files and &lt;script lang=\"ts\"&gt; in Vue SFCs out of the box. CSS / JSON Importing官网介绍 You can directly import .css and .json files from JavaScript (including &lt;script&gt; tags of *.vue files, of course). * .json files export their content as an object that is the default export. * .css files do not export anything unless it ends with .module.css (See CSS Modules below). Importing them leads to the side effect of them being injected to the page during dev, and being included in the final style.css of the production build. Both CSS and JSON imports also support Hot Module Replacement. vite对于css和json移入都是支持的 .json文件内容作为对象导出 .css文件不需要导出，除非它以.module.css结尾 CSS和JSON引入也支持热更新 使用xxx.module.css的方式引入son.module.css文件内容 .son2 .title&#123; color: green; &#125; 引入 import sonstyle from &#39;.&#x2F;css&#x2F;son.module.css&#39; composition API中使用并return setup(props,context)&#123; return&#123; sonstyle &#125; &#125; 使用 &lt;div class=\"son\" :class=\"sonstyle.son2\"&gt; &lt;h1&gt;123&lt;/h1&gt; &lt;h2 :class=\"sonstyle.title\"&gt;456&lt;/h2&gt; &lt;/div&gt; 在.vue文件中使用style module的方式引入 &lt;style scoped vars&#x3D;&quot;&#123; color &#125;&quot; module&gt; .text &#123; color: var(--color); &#125; &lt;&#x2F;style&gt;使用 &lt;h3 :class=\"$style.text\"&gt;&#123;&#123;people.name&#125;&#125;-&#123;&#123;people.id&#125;&#125;&lt;/h3&gt; Dev Server Proxyconst path &#x3D; require(&#39;path&#39;) module.exports &#x3D; &#123; proxy: &#123; &#39;&#x2F;api&#39;: &#123; target: &#39;http:&#x2F;&#x2F;apis.juhe.cn&#39;, changeOrigin: true, rewrite: path &#x3D;&gt; path.replace(&#x2F;^\\&#x2F;api&#x2F;, &#39;&#39;) &#125; &#125;, alias: &#123; &#x2F;&#x2F; 键必须以斜线开始和结束 &#39;&#x2F;@&#x2F;&#39;: path.resolve(__dirname, &#39;.&#x2F;src&#39;) &#x2F;&#x2F; &#39;&#x2F;@components&#x2F;&#39;: path.resolve(__dirname, &#39;.&#x2F;src&#x2F;components&#39;) &#125; &#125; alias(设置别名)设置 alias: &#123; &#x2F;&#x2F; 键必须以斜线开始和结束 &#39;&#x2F;@&#x2F;&#39;: path.resolve(__dirname, &#39;.&#x2F;src&#39;) &#x2F;&#x2F; &#39;&#x2F;@components&#x2F;&#39;: path.resolve(__dirname, &#39;.&#x2F;src&#x2F;components&#39;) &#125; 使用 import sonCom from &#39;&#x2F;@&#x2F;components&#x2F;sonCom.vue&#39;","permalink":"https://codermino.github.io/2020/10/12/vitenote/","photos":[]},{"tags":[{"name":"vue3reactive(响应式对象)和toRefs","slug":"vue3reactive-响应式对象-和toRefs","permalink":"https://codermino.github.io/tags/vue3reactive-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%AF%B9%E8%B1%A1-%E5%92%8CtoRefs/"}],"title":"vue3reactive(响应式对象)和toRefs","date":"2020/10/09","text":"&lt;template&gt; &lt;div id&#x3D;&quot;app&quot;&gt; &lt;p&gt;姓名：&#123;&#123;name&#125;&#125;&lt;&#x2F;p&gt; &lt;p&gt; &lt;button @click&#x3D;&quot;changeAge(-1)&quot;&gt;-&lt;&#x2F;button&gt; 年龄：&#123;&#123;age&#125;&#125; &lt;button @click&#x3D;&quot;changeAge(1)&quot;&gt;+&lt;&#x2F;button&gt; &lt;&#x2F;p&gt; &lt;p&gt; 出生年份： &lt;button @click&#x3D;&quot;changeYear(-1)&quot;&gt;-&lt;&#x2F;button&gt; &#123;&#123;year&#125;&#125; &lt;button @click&#x3D;&quot;changeYear(1)&quot;&gt;+&lt;&#x2F;button&gt; &lt;&#x2F;p&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; import &#123; ref, computed, reactive,toRefs &#125; from &quot;vue&quot;; export default &#123; name: &quot;app&quot;, data() &#123; return &#123; name: &quot;xiaosan&quot;, &#125;; &#125;, setup() &#123; const data &#x3D; reactive(&#123; &#x2F;&#x2F; 建立一个响应式对象 name: &quot;小四&quot;, age: 18, year: computed(&#123; get: () &#x3D;&gt; &#123; return 2020 - data.age; &#125;, set: (val) &#x3D;&gt; &#123; data.age &#x3D; 2020 - val; &#125;, &#125;), &#125;); function changeAge(val) &#123; data.age +&#x3D; val; &#x2F;&#x2F;想改变值或获取值 必须.value &#125; function changeYear(val) &#123; data.year &#x3D; data.year + val; &#125; return &#123; &#x2F;&#x2F;必须返回 模板中才能使用 ...toRefs(data),&#x2F;&#x2F;讲响应式的对象变为普通对象 在家。。。结构，在模板中就可以直接使用属性，不用data.name changeAge, changeYear, &#125;; &#125;, &#125;; &lt;&#x2F;script&gt;","permalink":"https://codermino.github.io/2020/10/09/vue3reactive-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%AF%B9%E8%B1%A1-%E5%92%8CtoRefs/","photos":[]},{"tags":[{"name":"js传递多个参数","slug":"js传递多个参数","permalink":"https://codermino.github.io/tags/js%E4%BC%A0%E9%80%92%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0/"}],"title":"js中的this总结","date":"2020/10/09","text":"this的指向问题可以用一句话总结就是：this总是指向调用的对象，也就是说this指向谁与函数声明的位置没有关系，只与调用的位置有关。这是判断this的一个大体原则，而具体的小原则按照优先级的不同大致可以分为以下几点： 一.优先级：new绑定&gt;显式绑定&gt;隐式绑定&gt;默认绑定 new绑定new方式是优先级最高的一种调用方式，也就是说只要是出现new方式来调用一个函数，this肯定会指向new调用函数新创建的对象。 function() thisTo(a)&#123; this.a=a; &#125; var data=new thisTo(2); //在这里进行了new绑定 console.log(data.a); //2 显式绑定显示绑定指的是通过call()和apply()方法对函数进行的调用，对this影响的优先级仅次于new绑定。 function thisTo()&#123; console.log(this.a); &#125; var data=&#123; a:2 &#125;; thisTo.call(data)); //2 隐式绑定 隐式绑定是指通过对象的属性进行添加，从而调用this所在函数，该方式的优先级在显示绑定之后。 function thisTo()&#123; console.log(this.a); &#125; var data=&#123; a:2, foo:thisTo //通过属性引用this所在函数 &#125;; data.foo(); //2 默认绑定 默认绑定是指当上面这三条绑定规则都不符合时采用的绑定规则， 默认绑定会把this默认绑定到全局对象中，是优先级最低的绑定规则。 function thisTo()&#123; console.log(this.a); &#125; var a=2; //a是全局对象的一个同名属性 thisTo(); //2 二.this绑定的特殊情况隐式丢失当进行隐式绑定时，如果进行一次引用赋值或者传参操作，会造成this的丢失， 从而最后将this绑定到全局对象中去。引用赋值丢失function thisTo()&#123; console.log(this.a); &#125; var data=&#123; a:2, foo:thisTo //通过属性引用this所在函数 &#125;; var a=3;//全局属性 var newData=data.foo; //这里进行了一次引用赋值 newData(); // 3 原理：因为newData实际上引用的是foo函数本身，跟data对象没有任何关系,data对象只是一个中间桥梁。 而newData就是一个本身不带a属性的对象，自然最后只能把a绑定到全局对象上了。 传参丢失function thisTo()&#123; console.log(this.a); &#125; var data=&#123; a:2, foo:thisTo //通过属性引用this所在函数 &#125;; var a=3;//全局属性 setTimeout(data.foo,100);// 3 原理：setTimeout(fn,delay) { fn(); } 实际上fn是一个参数传递的引用(fn=data.foo)，与引用丢失的原理一样 Function.prototype.bind()为了解决隐式丢失的问题，ES5提供了bind方法，bind()会返回一个硬编码的新函数，它会把参数设置为this的上下文并调用原始函数。 function thisTo()&#123; console.log(this.a); &#125; var data=&#123; a:2 &#125;; var a=3; var bar=thisTo.bind(data); console.log(bar()); //2 间接引用间接引用是指一个定义对象的方法引用另一个对象存在的方法，这种情况下会使得this进行默认绑定。 function thisTo()&#123; console.log(this.a); &#125; var data=&#123; a:2, foo:thisTo &#125;; var newData=&#123; a:3 &#125; var a=4; data.foo(); //2 (newData.foo=data.foo)() //4 原理：newData.foo=data.foo的返回值是目标函数的引用， 因此调用的位置实际上是foo(), 根据之前的隐式丢失里面说的原则，这里会应用默认绑定。 ES6箭头函数ES6的箭头函数在this这块是一个特殊的改进，箭头函数使用了词法作用域取代了传统的this机制，所以箭头函数无法使用上面所说的这些this优先级的原则，注意的是在箭头函数中，是根据外层父亲作用域来决定this的指向问题。 function thisTo()&#123; setTimeout(function()&#123; console.log(this.a); &#125;,100); &#125; var obj=&#123; a:2 &#125; var a=3; thisTo.call(obj); //3 不用箭头函数，发生隐式丢失，最后的this默认绑定到全局作用域，输出3。 function thisTo()&#123; setTimeout(()=&gt;&#123; console.log(this.a); &#125;,100); &#125; var obj=&#123; a:2 &#125; var a=3;加粗文字 thisTo.call(obj); //2 用了箭头函数，不会发生隐式丢失，this绑定到外层父作用域thisTO()，thisTo的被调用者是obj对象，所以最后的this到obj对象中，输出2。 如果不用箭头函数实现相同的输出，可以采用下面这种方式： function thisTo()&#123; var self=this; //在当前作用域中捕获this setTimeout(function()&#123; console.log(self.a); //传入self代替之前的this &#125;,100); &#125; var obj=&#123; a:2 &#125; var a=3; thisTo.call(obj); //2 总结this的绑定机制，就是要找到这个函数的直接调用位置，然后应用绑定的四条规则， 当出现满足多个规则时，按照优先级的高低决定最终的绑定规则。 此外注意几种特殊情况，特别是ES6中的箭头函数。 函数调用模式的时候，this指向windowfunction aa()&#123; console.log(this) &#125; aa() //window 方法调用模式的时候，this指向方法所在的对象var a=&#123;&#125;; a.name = 'hello'; a.getName = function()&#123; console.log(this.name) &#125; a.getName() //'hello' 构造函数模式的时候，this指向新生成的实例function Aaa(name)&#123; this.name= name; this.getName=function()&#123; console.log(this.name) &#125; &#125; var a = new Aaa('kitty'); a.getName() // 'kitty' var b = new Aaa('bobo'); b.getName() // 'bobo' apply/call调用模式的时候，this指向apply/call方法中的第一个参数var list1 = &#123;name:'andy'&#125; var list2 = &#123;name:'peter'&#125; function d()&#123; console.log(this.name) &#125; d.call(list1) // 'andy' d.call(list2) // 'peter' setTimeOut函数Demo1var num &#x3D; 0; function Obj ()&#123; this.num &#x3D; 1, this.getNum &#x3D; function()&#123; console.log(this.num); &#125;, this.getNumLater &#x3D; function()&#123; setTimeout(function()&#123; console.log(this.num); &#125;, 1000) &#125; &#125; var obj &#x3D; new Obj; obj.getNum();&#x2F;&#x2F;1 打印的为obj.num，值为1 obj.getNumLater()&#x2F;&#x2F;0 打印的为window.num，值为0 从上述例子中可以看到setTimeout中函数内的this是指向了window对象，这是由于setTimeout()调用的代码运行在与所在函数完全分离的执行环境上.这会导致这些代码中包含的 this 关键字会指向 window (或全局)对象。 但是在setTimeout中传入的不是函数时，this则指向当前对象 var num &#x3D; 0; function Obj ()&#123; this.num &#x3D; 1, this.getNum &#x3D; function()&#123; console.log(this.num); &#125;, this.getNumLater &#x3D; function()&#123; setTimeout(console.log(this.num), 1000) &#125; &#125; var obj &#x3D; new Obj; obj.getNum();&#x2F;&#x2F;1 打印的为obj.num，值为1 obj.getNumLater()&#x2F;&#x2F;1 打印的为obj.num，值为1 从以上两个例子可以看出，当在setTimeout中传入的参数为函数时，函数内部的this才会指向window对象。","permalink":"https://codermino.github.io/2020/10/09/js%E4%B8%AD%E7%9A%84this%E6%80%BB%E7%BB%93/","photos":[]},{"tags":[{"name":"css3动画控制元素淡入淡出","slug":"css3动画控制元素淡入淡出","permalink":"https://codermino.github.io/tags/css3%E5%8A%A8%E7%94%BB%E6%8E%A7%E5%88%B6%E5%85%83%E7%B4%A0%E6%B7%A1%E5%85%A5%E6%B7%A1%E5%87%BA/"}],"title":"css3的animation-fill-mode","date":"2020/10/09","text":"&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;style&gt; div &#123; width: 100px; height: 100px; background: red; position: relative; animation: mymove 5s infinite alternate; -moz-animation: mymove 5s infinite alternate; /* Firefox */ -webkit-animation: mymove 5s infinite alternate; /* Safari and Chrome */ -o-animation: mymove 5s infinite alternate; /* Opera */ animation-fill-mode: both; &#125; @keyframes mymove &#123; from &#123; top: 0px; &#125; to &#123; top: 200px; &#125; &#125; @-moz-keyframes mymove /* Firefox */ &#123; from &#123; top: 0px; &#125; to &#123; top: 200px; &#125; &#125; @-webkit-keyframes mymove /* Safari and Chrome */ &#123; from &#123; top: 0px; &#125; to &#123; top: 200px; &#125; &#125; @-o-keyframes mymove /* Opera */ &#123; from &#123; top: 0px; &#125; to &#123; top: 200px; &#125; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;&lt;b&gt;注释：&lt;/b&gt;本例在 Internet Explorer 中无效。&lt;/p&gt; &lt;div&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; &lt;!-- 这是摘自w3school的一段关于keyframes的代码，大家有兴趣的可以看一下， http://www.w3school.com.cn/tiy/t.asp?f=css3_keyframes 大家可以看到一个红色正方形，从上方运动到下面，再快速回到上面，再按animation:5s;从上面运动到下方，这样周而复始.那么在这个里面起关键的是keyframes，定义了动画，而animation:infinite 5s；则定义了动画效果，其中infinite代表的是循环，周而复始的这个过程。去掉这个，我们则看到红色正方形缓缓下来之后再快速回到上面后就不再动了。 那么我们想使正方形运动一次后留在下面，应该如何处理，这就是animation-fill-mode的作用，我今天在teambition网站上看到了他们的导航条的效果便是利用了这个，根据w3，animation-fill-mode有四个属性，none,forwards,backwards,both，其中none和forwards使得运动物体动画结束后回到动画前的状态，而both和forwards则使运动物体在动画结束后保留动画结束前最后一帧的效果，因此如 果我们希望正方形运动一次后停在下方，则需要使用animation-fill-mode这个属性。 而alternate则是达到往返效果，我们在实现摆钟动画时往往可能需要这个，我们不可能希望摆钟从左摆到右是一个我们确定的频率，从右摆到左又是一个急速的状态，没有保持一致。这样视觉上会大打折扣，大家可以在这个红色正方形上实验一下。譬如animation:mymove 5s infinite;变为 animation:mymove 5s infinite alternate； 来实际观察一下效果。 --&gt;","permalink":"https://codermino.github.io/2020/10/09/css3%E7%9A%84animation-fill-mode/","photos":[]},{"tags":[{"name":"vue数据赋值但视图没更新","slug":"vue数据赋值但视图没更新","permalink":"https://codermino.github.io/tags/vue%E6%95%B0%E6%8D%AE%E8%B5%8B%E5%80%BC%E4%BD%86%E8%A7%86%E5%9B%BE%E6%B2%A1%E6%9B%B4%E6%96%B0/"}],"title":"vue数据赋值但视图没更新","date":"2020/10/09","text":"出现的问题&lt;script&gt; export default &#123; data() &#123; return &#123; userInfo: &#123; name: '子君', sex: '男' &#125; &#125; &#125;, methods: &#123; // 在这里添加用户的公众号 handleAddOfficialAccount() &#123; this.userInfo.officialAccount = '前端有的玩' &#125; &#125; &#125; &lt;/script&gt; 在上边的代码中，我们触发事件之后添加一个新的属性，但是，点击按钮之后没有并没有生效。原因:在vue内部,数据响应是通过Object.definePrototype监听对象每一个键的getter、setter方法来实现的，但是通过这种方法只能监听到已有的属性，新增的属性是无法监测到的，下边提供四种方式: 方法一:将本来要新增的属性在data中提前定义好userInfo: &#123; name: &#39;子君&#39;, sex: &#39;男&#39;, officialAccount: &#39;&#39; &#125; &#x2F;&#x2F; 在这里添加用户的公众号 handleAddOfficialAccount() &#123; console.log(&#39;点击了&#39;) this.userInfo.officialAccount &#x3D; &#39;我来了&#39; &#125; 方法二:直接替换掉userInfo&#x2F;&#x2F; 在这里添加用户的公众号 handleAddOfficialAccount() &#123; this.userInfo &#x3D; &#123; ...this.userInfo, officialAccount: &#39;我来了&#39; &#125; &#125; 方法三:使用 Vue.set其实上边两种方法都有点取巧的嫌疑，其实对于新增属性，vue官方专门提供了一个新的方法Vue.set用来解决新增属性无法触发数据响应。Vue.set方法定义: /** * target 要修改的对象 * prpertyName 要添加的属性名称 * value 要添加的属性值 */ Vue.set( target, propertyName, value ) &#x2F;&#x2F; 在这里添加用户的公众号 handleAddOfficialAccount() &#123; this.$set(this.userInfo, &#39;officialAccount&#39;, &#39;我来了&#39;) &#125; 方式四：使用$forceUpdate$forceUpdate的存在，让许多前端开发者不会再去注意 数据双向绑定的原理，无论什么时候，反正我修改了data之后，调用一下$forceUpdate就会让vue组件重新去渲染，bug是不会存在的。但是实际上这个方法并不建议使用，因为它会引起许多不必要的性能消耗。针对数组的特定方法其实不仅仅是对象，数组也存在数据修改之后不响应的情况 &lt;template&gt; &lt;div&gt; &lt;ul&gt; &lt;li v-for&#x3D;&quot;item in list&quot; :key&#x3D;&quot;item&quot;&gt; &#123;&#123; item &#125;&#125; &lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;button @click&#x3D;&quot;handleChangeName&quot;&gt;修改名称&lt;&#x2F;button&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default &#123; data() &#123; return &#123; list: [&#39;张三&#39;, &#39;李四&#39;] &#125; &#125;, methods: &#123; &#x2F;&#x2F; 修改用户名称 handleChangeName() &#123; this.list[0] &#x3D; &#39;王五&#39; &#125; &#125; &#125; &lt;&#x2F;script&gt; 上边代码希望将张三的名字换成王五，实际上这个修改并不能生效，这是因为vue不能检测到以下变动的数组： 当你利用索引直接设置一个项时，例如this.list[index] = newVal 修改数组的length属性，例如:this.list.length = 0 向上边提到的Vue.set和$forceUpdate()都可以解决这个问题&#x2F;&#x2F; 修改用户名称 handleChangeName() &#123; this.list[0] &#x3D; &#39;王五&#39; this.$forceUpdate() &#125; &#x2F;&#x2F; 修改用户名称 handleChangeName() &#123; this.$set(this.list, 0, &#39;王二&#39;) &#125; 在操作数组的时候，我们一般会用到数据提供的很多方法，比如push、pop、splice等等,在vue中调用数组上面提供的这些方法修改数组的值是可以触发数据响应的，比如上面的代码可以改为以下的代码即可触发数据响应&#x2F;&#x2F; 修改用户名称 handleChangeName() &#123; this.list.splice(0, 1, &#39;王石&#39;) &#125; 实际上，如果vue仅仅依赖getter和setter，是无法做到在数组调用push、pop等方法来触发数据响应的，因此vue实际上是通过劫持这些方法，对这些方法进行包装变异来实现的vue对数组的以下方法进行的包装变异: push pop shift unshift splice sort reverse","permalink":"https://codermino.github.io/2020/10/09/vue%E6%95%B0%E6%8D%AE%E8%B5%8B%E5%80%BC%E4%BD%86%E8%A7%86%E5%9B%BE%E6%B2%A1%E6%9B%B4%E6%96%B0/","photos":[]},{"tags":[{"name":"vue的render函数","slug":"vue的render函数","permalink":"https://codermino.github.io/tags/vue%E7%9A%84render%E5%87%BD%E6%95%B0/"}],"title":"vue的render函数","date":"2020/10/07","text":"理解createElementVue通过建立一个虚拟DOM对真实的DOM发生变化保存追踪，如下代码：return createElement(‘h1’, this.title);createElement返回的是包含的信息会告诉VUE页面上需要渲染什么样的节点及其子节点。我们称这样的节点为虚拟DOM，可以简写为VNode， createElement 参数 // @return &#123;VNode&#125; createElement( // &#123;String | Object | Function&#125; // 一个HTML标签字符串，组件选项对象，或者一个返回值类型为String/Object的函数。该参数是必须的 'div', // &#123;Object&#125; // 一个包含模板相关属性的数据对象，这样我们可以在template中使用这些属性，该参数是可选的。 &#123; &#125;, // &#123;String | Array&#125; // 子节点（VNodes）由 createElement() 构建而成。可选参数 // 或简单的使用字符串来生成的 \"文本节点\"。 [ 'xxxx', createElement('h1', '一则头条'), createElement(MyComponent, &#123; props: &#123; someProp: 'xxx' &#125; &#125;) ] ) 理解深入data对象。在模板语法中，我们可以使用 v-bind:class 和 v-bind:style 来绑定属性，在VNode数据对象中，下面的属性名的字段级别是最高的。该对象允许我们绑定普通的html特性，就像DOM属性一样。如下： &#123; // 和`v-bind:class`一样的 API 'class': &#123; foo: true, bar: false &#125;, // 和`v-bind:style`一样的 API style: &#123; color: 'red', fontSize: '14px' &#125;, // 正常的 HTML 特性 attrs: &#123; id: 'foo' &#125;, // 组件 props props: &#123; myProp: 'bar' &#125;, // DOM 属性 domProps: &#123; innerHTML: 'baz' &#125;, // 事件监听器基于 `on` // 所以不再支持如 `v-on:keyup.enter` 修饰器 // 需要手动匹配 keyCode。 on: &#123; click: this.clickHandler &#125;, // 仅对于组件，用于监听原生事件，而不是组件内部使用 `vm.$emit` 触发的事件。 nativeOn: &#123; click: this.nativeClickHandler &#125;, // 自定义指令。注意事项：不能对绑定的旧值设值 // Vue 会为您持续追踪 directives: [ &#123; name: 'my-custom-directive', value: '2', expression: '1 + 1', arg: 'foo', modifiers: &#123; bar: true &#125; &#125; ], // Scoped slots in the form of // &#123; name: props =&gt; VNode | Array&lt;VNode&gt; &#125; scopedSlots: &#123; default: props =&gt; createElement('span', props.text) &#125;, // 如果组件是其他组件的子组件，需为插槽指定名称 slot: 'name-of-slot', // 其他特殊顶层属性 key: 'myKey', ref: 'myRef' &#125; 上面的data数据可能不太好理解，我们来看一个demo，就知道它是如何使用的了，如下代码： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;演示Vue&lt;/title&gt; &lt;style&gt; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;tb-heading :level=\"2\"&gt; Hello world! &lt;/tb-heading&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src=\"./vue.js\"&gt;&lt;/script&gt; &lt;script&gt; var getChildrenTextContent = function(children) &#123; return children.map(function(node) &#123; return node.children ? getChildrenTextContent(node.children) : node.text &#125;).join('') &#125;; Vue.component('tb-heading', &#123; render: function(createElement) &#123; var headingId = getChildrenTextContent(this.$slots.default) .toLowerCase() .replace(/\\W+/g, '-') .replace(/(^\\-|\\-$)/g, '') return createElement( 'h' + this.level, [ createElement('a', &#123; attrs: &#123; name: headingId, href: '#' + headingId &#125;, style: &#123; color: 'red', fontSize: '20px' &#125;, 'class': &#123; foo: true, bar: false &#125;, // DOM属性 domProps: &#123; innerHTML: 'baz' &#125;, // 组件props props: &#123; myProp: 'bar' &#125;, // 事件监听基于 'on' // 所以不再支持如 'v-on:keyup.enter' 修饰语 // 需要手动匹配 KeyCode on: &#123; click: function(event) &#123; event.preventDefault(); console.log(111); &#125; &#125; &#125;, this.$slots.default) ] ) &#125;, props: &#123; level: &#123; type: Number, required: true &#125; &#125; &#125;); new Vue(&#123; el: '#container' &#125;); &lt;/script&gt; &lt;/html&gt; 对应的属性使用方法和上面一样既可以了，我们可以打开页面查看下效果也是可以的。如下 VNodes 不一定必须唯一 （文档中说要唯一）文档中说 VNode必须唯一；说 下面的 render function 是无效的：但是我通过测试时可以的，如下代码： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;演示Vue&lt;/title&gt; &lt;style&gt; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;tb-heading :level=\"2\"&gt; Hello world! &lt;/tb-heading&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src=\"./vue.js\"&gt;&lt;/script&gt; &lt;script&gt; Vue.component('tb-heading', &#123; render: function(createElement) &#123; var pElem = createElement('p', 'hello world'); return createElement('div', [ pElem, pElem ]) &#125;, props: &#123; level: &#123; type: Number, required: true &#125; &#125; &#125;); new Vue(&#123; el: '#container' &#125;); &lt;/script&gt; &lt;/html&gt; 虚拟DOMVue通过建立一个虚拟DOM对真实DOM发生的变化保持追踪上面的createElement 返回的不是一个实际的DOM元素，更准确的名字是createNodeDescription，它包含的信息会告知vue页面上需要渲染出上面样的节点，这种节点描述为虚拟节点 Virtual Node ,简称 Vcode,虚拟DOM是我们对有Vue组件建立起来的整个VNode树的称呼 createElement参数需要了解在createElement函数中接受的参数接受两个参数: createElement(A,B,C); A:可以是标签名，组件名 B:就是标签/vue组件里面需要的数据 C :子节点 深入data对象在vnode数据对象中，下列属性名是级别最高的字段，vnode数据对象中允许绑定普通的HTML特性，就像DOM属性一样，比如innerHTML会取代v-html指令,下面贴出的是数据对象中常用的属性名称注意到 DOM属性的innerHTML和字节点的创建不能并存，innerHTML会覆盖子节点但是如果想要去动态渲染自己定义的模板呢，就需要先全局注册这个组件才行.在动态渲染自定义的组件的时候，创建的子节点是不生效的VNodes必须唯一组件树中，所有的VNodes必须是唯一的，例如var mc = createElement(‘p’,’hello world’);return createElement(‘div’,[mc,mc]);//这种写法是无效的 如何在render中实现v-model双向数据绑定的效果","permalink":"https://codermino.github.io/2020/10/07/vue%E7%9A%84render%E5%87%BD%E6%95%B0/","photos":[]},{"tags":[{"name":"es6解构","slug":"es6解构","permalink":"https://codermino.github.io/tags/es6%E8%A7%A3%E6%9E%84/"}],"title":"es6解构","date":"2020/10/07","text":"解构destructuring：百度百科的意思是结构分解，ES6 中允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring） 作用这是一种将数据结构分解为更小的部分的过程，从而达到简化提取信息的目的。 对象解构 形式对象解构语法是在赋值对象的左侧使用了对象字面量，如：同名变量解构赋值 let node = &#123; type : 'identifier', name : 'foo' &#125;; let &#123;type,name&#125; = node; console.log(type);//'identifier' console.log(name);//'foo' 不同变量解构赋值 let node = &#123; type : 'identifier', name : 'foo' &#125;; let &#123;type:localType,name:localName&#125; = node; console.log(localType);//'identifier' console.log(localName);//'foo' 注意点 使用var、let、const对对象进行解构时，必须提供初始化器（即等号右边的值） 不使用var、let、const赋值时，需要将解构语句使用（）进行包裹（&#123;type，name&#125; = node);//&#123;&#125;在js中作为代码块，单独使用加等号会报错会报错 默认值当你使用解构赋值语句时，如果指定的本地变量没有同名属性，那么该变量会被赋值为undefined，可以对其进行指定默认值 let node = &#123; type : 'identifier', name : 'foo' &#125;; let &#123;type,name,val&#125; = node; console.log(val);//undefined (&#123;type,name,val = '234'&#125; = node) console.log(val);//'234' 嵌套的对象解构使用类似于对象字面量的语法，可以深入到嵌套的对象结构中去提取你想要的数据 let node = &#123; type: \"Identifier\", name: \"foo\", loc: &#123; start: &#123; line: 1, column: 1 &#125;, end: &#123; line: 1, column: 4 &#125; &#125; &#125;; let &#123; loc: &#123; start &#125;&#125; = node; console.log(start.line); // 1 console.log(start.column); // 1 这种方法使得本地变量start被赋值node中的loc的start对象，值得注意的是这种操作与直接node.loc.start的赋值是一致的，所以要注意值类型与引用类型的区别 注意点:此语句中并没有任何变量被绑定 // 没有变量被声明！ let &#123; loc: &#123;&#125; &#125; = node; 数组解构 形式数组解构的语法看起来与对象解构非常相似，只是将对象字面量替换成了数组字面量。数组解构时，解构作用在数组内部的位置上，而不是作用在对象的具名属性上let colors = [ \"red\", \"green\", \"blue\" ]; let [ firstColor, secondColor ] = colors; console.log(firstColor); // \"red\" console.log(secondColor); // \"green\" 所以，对于数组解构，最主要在于位置的固定，当然，如果不想赋值某些值，可以直接略过，如：var s = [1,2,3,4,5]; let [,,T] = s; console,log(T);//3 注意点 使用var、let、const对对象进行解构时，必须提供初始化器（即等号右边的值） 不使用var、let、const赋值时，需要将解构语句使用（）进行包裹，因为数组的[]，与{}是不同的 对互换两个变量的值很有用，如排序算法中使用的，可以直接用let a = 3; let b = 4; [b,a] = [a,b]; console.log(a);//4 console.log(b);//3 默认值数组解构赋值同样允许在数组任意位置指定默认值。当指定位置的项不存在、或其值为undefined ，那么该默认值就会被使用let colors = [ \"red\" ]; let [ firstColor, secondColor = \"green\" ] = colors; console.log(firstColor); // \"red\" console.log(secondColor); // \"green\" 嵌套的数组结构与对象类似，只是仍使用的是数组字面量let colors = [ \"red\", [ \"green\", \"lightgreen\" ], \"blue\" ]; console.log(secondColor); // \"green\" 剩余项数组解构有个与函数的剩余参数类似的、名为剩余项（ rest items ）的概念，它使用” …” 语法来将剩余的项目赋值给一个指定的变量let colors = [ \"red\", \"green\", \"blue\" ]; let [ firstColor, ...restColors ] = colors; console.log(firstColor); // \"red\" console.log(restColors.length); // 2 console.log(restColors[0]); // \"green\" console.log(restColors[1]); // \"blue\" 混合解构既有函数的解构，也有数组的解构，也只需要对象的创建出字面量来赋值即可，如： let node = &#123; type: \"Identifier\", loc: &#123; start: &#123; line: 1, column: 1 &#125; &#125;, range: [0, 3] &#125;; let &#123; loc: &#123; start &#125;, range: [ startIndex ] &#125; = node; console.log(start.line); // 1 console.log(start.column); // 1 console.log(startIndex); // 0 实际使用- 参数解构// options 上的属性表示附加参数 function setCookie(name, value, options) &#123; options = options || &#123;&#125;; let secure = options.secure, path = options.path, domain = options.domain, expires = options.expires; // 设置 cookie 的代码 &#125; //可以改写为：对options进行解构并赋予默认值 function setCookie(name, value, &#123; secure, path, domain, expires &#125; = &#123;&#125;) &#123; // ... &#125;","permalink":"https://codermino.github.io/2020/10/07/es6%E8%A7%A3%E6%9E%84/","photos":[]},{"tags":[{"name":"uniapp的navigator的open","slug":"uniapp的navigator的open","permalink":"https://codermino.github.io/tags/uniapp%E7%9A%84navigator%E7%9A%84open/"}],"title":"uniapp的navigator的open-type跳转问题","date":"2020/10/07","text":"navigator的open-type属性 可选值 ‘navigate’、‘redirect’、‘switchTab’，对应于wx.navigateTo、wx.redirectTo、wx.switchTab的功能 open-type=”navigate”等价于API的 wx.navigateTo 而wx.navigateTo的url是需要跳转的应用内非 tabBar 的页面的路径 open-type=”redirect”等价于API的 wx.redirectTo 而wx.redirectTo的url是需要跳转的应用内非 tabBar 的页面的路径 open-type=”switchTab”等价于API的 wx.switchTab而wx.switchTab的url是需要跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面 最后一个switchTab事件触发以后 把前面的页面都关闭了","permalink":"https://codermino.github.io/2020/10/07/uniapp%E7%9A%84navigator%E7%9A%84open-type%E8%B7%B3%E8%BD%AC%E9%97%AE%E9%A2%98/","photos":[]},{"tags":[{"name":"css3动画控制元素淡入淡出","slug":"css3动画控制元素淡入淡出","permalink":"https://codermino.github.io/tags/css3%E5%8A%A8%E7%94%BB%E6%8E%A7%E5%88%B6%E5%85%83%E7%B4%A0%E6%B7%A1%E5%85%A5%E6%B7%A1%E5%87%BA/"}],"title":"css3动画控制元素淡入淡出","date":"2020/10/07","text":"html部分&lt;div class&#x3D;&quot;demo&quot;&gt;&lt;&#x2F;div&gt; css部分/*定义公共淡入淡出效果 fadenum*/ @-webkit-keyframes fadenum&#123; 0%&#123; opacity: 0; &#125; 100%&#123; opacity: 1; &#125; &#125; @-moz-keyframes fadenum&#123; 0%&#123; opacity: 0; &#125; 100%&#123; opacity: 1; &#125; &#125; @-o-keyframes fadenum&#123; 0%&#123; opacity: 0; &#125; 100%&#123; opacity: 1; &#125; &#125; @keyframes fadenum&#123; 0%&#123; opacity: 0; &#125; 100%&#123; opacity: 1; &#125; &#125; /*元素使用该效果*/ .demo&#123; width: 300px; height: 200px; background: red; -webkit-animation: fadenum 4s ease; -moz-animation: fadenum 4s ease; animation:fadenum 4s ease; &#125;","permalink":"https://codermino.github.io/2020/10/07/css3%E5%8A%A8%E7%94%BB%E6%8E%A7%E5%88%B6%E5%85%83%E7%B4%A0%E6%B7%A1%E5%85%A5%E6%B7%A1%E5%87%BA/","photos":[]},{"tags":[{"name":"iview输入框去掉边框","slug":"iview输入框去掉边框","permalink":"https://codermino.github.io/tags/iview%E8%BE%93%E5%85%A5%E6%A1%86%E5%8E%BB%E6%8E%89%E8%BE%B9%E6%A1%86/"}],"title":"iview输入框去掉边框","date":"2020/10/07","text":"html部分&lt;i-input class&#x3D;&quot;txtput&quot; :maxlength&#x3D;&quot;20&quot; placeholder&#x3D;&quot;请输入...&quot; &gt;&lt;&#x2F;i-input&gt; css部分/* 穿透进iview的input框 */ .txtput &gt;&gt;&gt; .ivu-input&#123; width: 85%; border: none; outline:none; font-size: 20px; margin-left: 0%; border-bottom: 1.3px solid gainsboro; &#125; /* 去除点击之后的input框 */ .txtput &gt;&gt;&gt; .ivu-input:focus&#123; outline:none; border:none; box-shadow: 0 0 0 2px transparent; border-bottom: 1.3px solid gainsboro; &#125;","permalink":"https://codermino.github.io/2020/10/07/iview%E8%BE%93%E5%85%A5%E6%A1%86%E5%8E%BB%E6%8E%89%E8%BE%B9%E6%A1%86/","photos":[]},{"tags":[{"name":"vue3note","slug":"vue3note","permalink":"https://codermino.github.io/tags/vue3note/"}],"title":"vue3notehexo","date":"2020/10/07","text":"","permalink":"https://codermino.github.io/2020/10/07/vue3note/","photos":[]},{"tags":[{"name":"vue父子组件数据双向绑定","slug":"vue父子组件数据双向绑定","permalink":"https://codermino.github.io/tags/vue%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/"}],"title":"vue父子组件数据双向绑定","date":"2020/10/06","text":"Vue单向数据流单向数据流：父组件可以向子组件通过属性形式传递参数，传递的参数也可以随时随意修改；但子组件不能修改父组件传递过来的参数。只能用父组件传递的数据。 原因 原因：因为子组件接收父组件传递过来的数据，并不是一个基础类型的数据类型， 而是类似于object这种引用类型的数据类型。如果修改了引用类型的数据， 在使用子组件时，则会造成其他子组件接收数据的错误 方法一父组件 &lt;child-test :inputData&#x3D;&quot;inputData&quot; @inputdataChange&#x3D;&quot;inputdataChange&quot;&gt;&lt;&#x2F;child-test&gt; &lt;span&gt;&#123;&#123;inputData&#125;&#125;&lt;&#x2F;span&gt; 子组件 &lt;template&gt; &lt;div class&#x3D;&quot;childTest&quot;&gt; 输入内容&lt;input type&#x3D;&quot;text&quot; :value&#x3D;&quot;inputData&quot; @input&#x3D;&quot;inputChange&quot;&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default &#123; name: &quot;childTest&quot;, props: &#123; inputData: &#123; type: String, default: &#39;&#39; &#125;, &#125;, methods: &#123; inputChange(e) &#123; this.$emit(&#39;inputdataChange&#39;,e.target.value) &#125; &#125;, &#125; &lt;&#x2F;script&gt; 方法二(使用v-model)官方介绍 允许一个自定义组件在使用 v-model 时定制 prop 和 event。默认情况下， **一个组件上的 v-model 会把 value 用作 prop 且把 input 用作 event** 但是一些输入类型比如单选框和复选框按钮可能想使用 value prop 来达到不同的目的。 使用 model 选项可以回避这些情况产生的冲突。 父组件不需要做方法监听，而是通过v-model指令绑定一个变量即可。1、子组件通过props接受一个父组件通过v-model指令绑定的变量 props: ['value'] 2、子组件新建一个model对象 model: &#123; prop: 'value', // props接受的变量名称 event: 'change' //定义一个方法 &#125; 父组件 &lt;child-test2 v-model&#x3D;&quot;inputData&quot;&gt;&lt;&#x2F;child-test2&gt; &#123;&#123;inputData&#125;&#125; 父组件则只要v-model绑定一个变量即可，当输入框改变时inputValue就会得到响应。 子组件 &lt;template&gt; &lt;div class&#x3D;&quot;childTest2&quot;&gt; &lt;!-- 输入值: &lt;input type&#x3D;&quot;text&quot; :value&#x3D;&quot;value&quot; @input&#x3D;&quot;inputChange&quot;&gt;--&gt; &lt;!-- 输入值: &lt;input type&#x3D;&quot;text&quot; :value&#x3D;&quot;inputData&quot; @change&#x3D;&quot;inputValueChange&quot;&gt;--&gt; 输入值: &lt;input type&#x3D;&quot;text&quot; :value&#x3D;&quot;inputData&quot; @input&#x3D;&quot;inputValueChange&quot;&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default &#123; name: &quot;childTest2&quot;, &#x2F;&#x2F; props: &#123; &#x2F;&#x2F; value: &#123; &#x2F;&#x2F; type: String &#x2F;&#x2F; &#125; &#x2F;&#x2F; &#125;, props: &#123; inputData: &#123; type: String &#125; &#125;, model: &#123; prop: &#39;inputData&#39;, &#x2F;&#x2F; props接受的变量名称 event: &#39;change&#39; &#x2F;&#x2F;定义一个方法(默认为input) &#125;, methods: &#123; &#x2F;&#x2F; inputChange(e) &#123; &#x2F;&#x2F; this.$emit(&#39;input&#39;,e.target.value); &#x2F;&#x2F; &#125;, inputValueChange(e)&#123; this.$emit(&#39;change&#39;,e.target.value); &#125; &#125;, &#125; 在input框改变的事件里通过$emit触发在model对象里面定义的change方法,并传入输入的的值。 &lt;&#x2F;script&gt; Demo父组件 &lt;template&gt; &lt;div&gt; &lt;model-test-son v-model&#x3D;&quot;msg&quot;&gt;&lt;&#x2F;model-test-son&gt; &#123;&#123;msg&#125;&#125; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; import modelTestSon from &#39;.&#x2F;modelTestSon&#39; export default &#123; name: &quot;modelTest&quot;, components:&#123; modelTestSon &#125;, data() &#123; return &#123; msg: &#39;123&#39; &#125; &#125;, &#125; &lt;&#x2F;script&gt; 子组件 &lt;template&gt; &lt;div @click&#x3D;&quot;changeMsg&quot;&gt;点击改变msg&lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default &#123; name: &quot;modelTestSon&quot;, model: &#123; prop: &#39;msg&#39;, &#x2F;&#x2F; props接受的变量名称 event: &#39;change&#39; &#x2F;&#x2F;定义一个方法(默认为input) &#125;, props: &#123; msg: &#123; type: String, default:&#39;&#39; &#125; &#125;, methods: &#123; changeMsg() &#123; this.$emit(&#39;change&#39;, &#39;456&#39;) &#125; &#125;, &#125; &lt;&#x2F;script&gt;","permalink":"https://codermino.github.io/2020/10/06/vue%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/","photos":[]},{"tags":[{"name":"callback函数","slug":"callback函数","permalink":"https://codermino.github.io/tags/callback%E5%87%BD%E6%95%B0/"}],"title":"callback函数","date":"2020/09/28","text":"A callback is a function that is passed as an argument to another function and is executed after its parent function has completed. function add (num, callback) &#123; if (num &gt; 10) &#123; // eslint-disable-next-line standard/no-callback-literal callback(num + 1) &#125; else &#123; callback(num) &#125; &#125; add(0, item =&gt; &#123; console.log(item) &#125;)","permalink":"https://codermino.github.io/2020/09/28/callback%E5%87%BD%E6%95%B0/","photos":[]},{"tags":[{"name":"mysql优化一般步骤","slug":"mysql优化一般步骤","permalink":"https://codermino.github.io/tags/mysql%E4%BC%98%E5%8C%96%E4%B8%80%E8%88%AC%E6%AD%A5%E9%AA%A4/"}],"title":"mysql优化一般步骤","date":"2020/09/20","text":"创建索引 总体上来说，子查询还是不如连接查询快 select优化插入大量数据的时候，先删除索引，导完再把索引添加上。 InnoDB的表按照主键顺序插入会比较快。 先将自动提交修改为手动提交。（AUTOCOMMIT=0时比1时快） 优化insert语句 多行数据最好一次性插入，这样还可以用INSERT DELAYED让数据放在内存队列中，快速插入。 户当从一个文本文件装载一个表时，使用LOAD DATA 1NFILE。这通常比使用很多INSERT语句快20倍。 优化ORDER BY语句通过索引直接返回的已经是有序数据，尽量减少额外的排序。 #以下可用:# SELECT*FROM fiabname ORDER BY key_partl,key_part2； SELECT*FROM tabname WHERE key_partl=1 ORDER BY key_partl DESC, key_part2 DESC； SELE*FROM tabname ORDER BY key_partl oESC, key_part2 DESC； #以下勿用# SELECT * FROM tabname ORDER BY key_partl DESC, key_part2 ASC: --order by的字段混合ASC和ESC SELECT * FROM tabname WHERE key2=constant ORDER BY keyl; 一用于查询行的关键字与ORDER B丫中所使用的不相同 SELECT*FROM tabname ORDER BY keyl, key2; 一对不同的关键字使用ORDER BY 优化GROUP BY语句默认情况下，MySQL对所有GROUP BY coll,col2,…的字段进行排序。 例如：select payment_date, sum(amount) from payment group by payment_date； 优化之后：select payment_date, sum(amount) from payment group by payment_date order by null;禁止了排序 优化OR条件对于含有OR的查询子句，如果要利用索引，则OR之间的每个条件列都必须用到索引; 如果没有索引.则应该考虑增加索引。 如果or前后的字段是符合索引，则索引会失效，因为mysql是分别查询之后 再UNION在一起的。 优化分页查询\"limit 1000,20\" 前1000条记录都会被抛弃，查询和排序的代价非常高。 a: 先单独查询出分页记录对应的主键，再连表查询出主键加其他字段。（避免了全表扫描） 优化前：select film_id, description from film order by title limit 50,5; 优化后：select a.film_id, a.description from film a inner join (select film_id from film order by title limit 50,5) b on a.film_id=b.film_id； 使用SQL提示索引提示：select count(*) from rental use index (idx_rental date)； 索引忽略：select count(*) from rental ignore index (idx_rental date); 强制索引：select * from rental force index (idx_fk_inventory_id) where inventory_id&gt;1; 常用sql技巧1：使用正则表达式 2：巧用RAND()提取随机行 select * from category order by rand() limit 5；随机排序之后去前5条记录。","permalink":"https://codermino.github.io/2020/09/20/mysql%E4%BC%98%E5%8C%96%E4%B8%80%E8%88%AC%E6%AD%A5%E9%AA%A4/","photos":[]},{"tags":[{"name":"mysql查询某时间范围的数据","slug":"mysql查询某时间范围的数据","permalink":"https://codermino.github.io/tags/mysql%E6%9F%A5%E8%AF%A2%E6%9F%90%E6%97%B6%E9%97%B4%E8%8C%83%E5%9B%B4%E7%9A%84%E6%95%B0%E6%8D%AE/"}],"title":"mysql查询某时间范围的数据","date":"2020/09/20","text":"根据时间范围查询对应的数据-- 查询今天的数据 select * from daily where to_days(createtime) = to_days(CURDATE()); -- 查询昨天的数据 select * from daily where to_days(CURDATE()) - to_days(createtime)&lt;=1; -- 查询最近7天的数据 select * from daily where createtime &gt; DATE_SUB(CURDATE(),INTERVAL 7 DAY); -- 查询最近一个季度的数据 select * from daily where createtime &gt; DATE_SUB(CURDATE(), INTERVAL 3 MONTH) -- 最近一年的数据 select * from daily where createtime &gt; DATE_SUB(CURDATE(), INTERVAL 1 YEAR); -- 本季度的数据 select * from daily where quarter(createtime) = quarter(CURDATE()); -- 上季度的数据 select * from daily where quarter(createtime) = quarter(DATE_SUB(CURDATE(), INTERVAL 1 QUARTER)); -- 查询今年的数据 select * from daily where year(CURDATE()) - year(createtime) = 28 ; -- 查询第几月的数据 select * from daily where month(createtime) = 8 ; -- 查询某年某月某日的数据 select * from daily where date_format(createtime,'%Y-%m-%d')='2017-07-07'; -- 查询制定时间段内的数据（只写到月，会出错） select * from daily where createtime between '1888-5-1 00:00:00' and '2017-9-3 00:00:00'; -- 查询制定时间段内的数据（只写到月，会出错） select * from daily where createtime &gt; '1989-5-1' and createtime &lt; '2017-5-1';","permalink":"https://codermino.github.io/2020/09/20/mysql%E6%9F%A5%E8%AF%A2%E6%9F%90%E6%97%B6%E9%97%B4%E8%8C%83%E5%9B%B4%E7%9A%84%E6%95%B0%E6%8D%AE/","photos":[]},{"tags":[{"name":"vue路由调转传递参数","slug":"vue路由调转传递参数","permalink":"https://codermino.github.io/tags/vue%E8%B7%AF%E7%94%B1%E8%B0%83%E8%BD%AC%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0/"}],"title":"vue路由调转传递参数","date":"2020/09/15","text":"第一种方式todetail(id) &#123; this.$router.push(&#123; path: &#96;&#x2F;detail&#x2F;$&#123;id&#125;&#96;, &#125;) &#125; &#x2F;&#x2F; 第一种方式传参 &#123; path: &#39;&#x2F;detail&#x2F;:id&#39;, name: &#39;detail&#39;, meta:&#123; title:&#39;新闻详情&#39; &#125;, component: () &#x3D;&gt; import(&#x2F;* webpackChunkName: &quot;about&quot; *&#x2F; &#39;@&#x2F;components&#x2F;detail&#x2F;detail.vue&#39;) &#125; 接收 &#x2F;&#x2F; this.id &#x3D; this.$route.params.id; 第二种方式&#x2F;&#x2F;第二种方式 todetail(id)&#123; this.$router.push(&#123; name: &#39;detail&#39;, params: &#123; id: id &#125; &#125;) &#125; &#x2F;&#x2F;第二种方式 &#123; path: &#39;&#x2F;detail&#39;, name: &#39;detail&#39;, meta:&#123; title:&#39;新闻详情&#39; &#125;, component: () &#x3D;&gt; import(&#x2F;* webpackChunkName: &quot;about&quot; *&#x2F; &#39;@&#x2F;components&#x2F;detail&#x2F;detail.vue&#39;) &#125; 接收 &#x2F;&#x2F; this.id &#x3D; this.$route.params.id; 第三种方式&#x2F;&#x2F;第三种方式 todetail(id)&#123; this.$router.push(&#123; path: &#39;&#x2F;detail&#39;, query: &#123; id: id &#125; &#125;) &#125; &#123; path: &#39;&#x2F;detail&#39;, name: &#39;detail&#39;, meta:&#123; title:&#39;新闻详情&#39; &#125;, component: () &#x3D;&gt; import(&#x2F;* webpackChunkName: &quot;about&quot; *&#x2F; &#39;@&#x2F;components&#x2F;detail&#x2F;detail.vue&#39;) &#125; &#x2F;&#x2F;接收 this.id &#x3D; this.$route.query.id;","permalink":"https://codermino.github.io/2020/09/15/vue%E8%B7%AF%E7%94%B1%E8%B0%83%E8%BD%AC%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0/","photos":[]},{"tags":[{"name":"vue中引入本地文件的方式","slug":"vue中引入本地文件的方式","permalink":"https://codermino.github.io/tags/vue%E4%B8%AD%E5%BC%95%E5%85%A5%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E5%BC%8F/"}],"title":"vue中引入本地文件的方式","date":"2020/09/13","text":"第一种方式使用import进行引入import detail from &#39;@&#x2F;json&#x2F;learn.json&#39; import data from &#39;@&#x2F;assets&#x2F;data.json&#39; import detail from &#39;..&#x2F;json&#x2F;learn.json&#39; import &#39;..&#x2F;assets&#x2F;js&#x2F;SCIT0039_map&#39; import italydata from &#39;..&#x2F;assets&#x2F;json&#x2F;italy20200301&#39; 第二种使用axios进行引入 npm install axiosimport axios from &#39;axios&#39; Vue.prototype.$http&#x3D;axios this.$http.get(&#39;..&#x2F;..&#x2F;static&#x2F;data.json&#39;).then((response) &#x3D;&gt; &#123; console.log(response); &#125;); &#125;","permalink":"https://codermino.github.io/2020/09/13/vue%E4%B8%AD%E5%BC%95%E5%85%A5%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E5%BC%8F/","photos":[]},{"tags":[{"name":"iview多级抽屉优化","slug":"iview多级抽屉优化","permalink":"https://codermino.github.io/tags/iview%E5%A4%9A%E7%BA%A7%E6%8A%BD%E5%B1%89%E4%BC%98%E5%8C%96/"}],"title":"iview多级抽屉优化","date":"2020/09/13","text":"多级抽屉优化 可能出现的问题: 使用两个mask切换的时候会出现闪动的现象 如果只使用一级抽屉的mask的时候，二级抽屉的closeable的叉号无法点击(层级关系) 如果使用二级抽屉的mask的时候，会出现一级抽屉没有mask(效果不好) 如果不调整二级抽屉和一级抽屉的层级的时候，二级抽屉默认的是会从一级抽屉的上方滑出(效果不好) 解决方案，目前想出两种 共同的改动：将二级抽屉的层级改为比一级抽屉的层级第一级，例如：一级抽屉的层级为1002，二级抽屉的层级为1001 使用一个变量来进行一级抽屉和二级抽屉的mask的显示和隐藏。并且一级抽屉的bcakground-color: transparent 二级抽屉的background-color: rgba(55,55,55,.6) !important; 自定义一个div.mask幕布来进行遮盖，并且自定义幕布的层级比内容区域的层级高。但是比一级抽屉和二级抽屉的层级 低。并且使用定位的方式进行布局和背景颜色设置等。监听自定义幕布的点击事件。来进行抽屉的关闭。 代码&lt;template&gt; &lt;div class&#x3D;&quot;layout&quot; style&#x3D;&quot;height: 100%;&quot;&gt; &lt;Layout&gt; &lt;Header&gt; &lt;Icon type&#x3D;&quot;ios-paper&quot; @click&#x3D;&quot;showDrawer&#x3D;true&quot;&gt;&lt;&#x2F;Icon&gt; &lt;&#x2F;Header&gt; &lt;Layout&gt; &lt;Sider hide-trigger :style&#x3D;&quot;&#123;background: &#39;#fff&#39;&#125;&quot;&gt; &lt;Menu active-name&#x3D;&quot;1-2&quot; theme&#x3D;&quot;light&quot; width&#x3D;&quot;auto&quot; :open-names&#x3D;&quot;[&#39;1&#39;]&quot;&gt; &lt;Submenu name&#x3D;&quot;1&quot;&gt; &lt;template slot&#x3D;&quot;title&quot;&gt; &lt;Icon type&#x3D;&quot;ios-navigate&quot;&gt;&lt;&#x2F;Icon&gt; Item 1 &lt;&#x2F;template&gt; &lt;MenuItem name&#x3D;&quot;1-1&quot;&gt;Option 1&lt;&#x2F;MenuItem&gt; &lt;MenuItem name&#x3D;&quot;1-2&quot;&gt;Option 2&lt;&#x2F;MenuItem&gt; &lt;MenuItem name&#x3D;&quot;1-3&quot;&gt;Option 3&lt;&#x2F;MenuItem&gt; &lt;&#x2F;Submenu&gt; &lt;Submenu name&#x3D;&quot;2&quot;&gt; &lt;template slot&#x3D;&quot;title&quot;&gt; &lt;Icon type&#x3D;&quot;ios-keypad&quot;&gt;&lt;&#x2F;Icon&gt; Item 2 &lt;&#x2F;template&gt; &lt;MenuItem name&#x3D;&quot;2-1&quot;&gt;Option 1&lt;&#x2F;MenuItem&gt; &lt;MenuItem name&#x3D;&quot;2-2&quot;&gt;Option 2&lt;&#x2F;MenuItem&gt; &lt;&#x2F;Submenu&gt; &lt;Submenu name&#x3D;&quot;3&quot;&gt; &lt;template slot&#x3D;&quot;title&quot;&gt; &lt;Icon type&#x3D;&quot;ios-analytics&quot;&gt;&lt;&#x2F;Icon&gt; Item 3 &lt;&#x2F;template&gt; &lt;MenuItem name&#x3D;&quot;3-1&quot;&gt;Option 1&lt;&#x2F;MenuItem&gt; &lt;MenuItem name&#x3D;&quot;3-2&quot;&gt;Option 2&lt;&#x2F;MenuItem&gt; &lt;&#x2F;Submenu&gt; &lt;&#x2F;Menu&gt; &lt;&#x2F;Sider&gt; &lt;!-- 方案一--&gt; &lt;!-- &lt;div class&#x3D;&quot;drawer&quot;&gt;--&gt; &lt;!-- &lt;Drawer :mask-closable&#x3D;&quot;!showSubDrawer&quot; :mask&#x3D;&quot;!showSubDrawer&quot; title&#x3D;&quot;Multi-level drawer&quot; width&#x3D;&quot;256&quot; :closable&#x3D;&quot;false&quot; v-model&#x3D;&quot;showDrawer&quot; placement&#x3D;&quot;left&quot; :transfer&#x3D;&quot;false&quot; :inner&#x3D;&quot;true&quot;&gt;--&gt; &lt;!-- &lt;Button @click&#x3D;&quot;showSubDrawer &#x3D; !showSubDrawer&quot; type&#x3D;&quot;primary&quot;&gt;Two-level Drawer&lt;&#x2F;Button&gt;--&gt; &lt;!-- &lt;&#x2F;Drawer&gt;--&gt; &lt;!-- &lt;div class&#x3D;&quot;subDrawer&quot;&gt;--&gt; &lt;!-- &lt;Drawer @on-close&#x3D;&quot;drawerClose&quot; :mask&#x3D;&quot;showSubDrawer&quot; class&#x3D;&quot;subdrawer-inner&quot; placement&#x3D;&quot;left&quot; title&#x3D;&quot;Two-level Drawer&quot; v-model&#x3D;&quot;showSubDrawer&quot; :transfer&#x3D;&quot;false&quot; :inner&#x3D;&quot;true&quot;&gt;--&gt; &lt;!-- This is two-level drawer.--&gt; &lt;!-- &lt;&#x2F;Drawer&gt;--&gt; &lt;!-- &lt;&#x2F;div&gt;--&gt; &lt;!-- &lt;&#x2F;div&gt;--&gt; &lt;!-- 方案一结束--&gt; &lt;!-- 方案二--&gt; &lt;div class&#x3D;&quot;drawer&quot;&gt; &lt;Drawer :mask&#x3D;&quot;false&quot; title&#x3D;&quot;Multi-level drawer&quot; width&#x3D;&quot;256&quot; :closable&#x3D;&quot;false&quot; v-model&#x3D;&quot;showDrawer&quot; placement&#x3D;&quot;left&quot; :transfer&#x3D;&quot;false&quot; :inner&#x3D;&quot;true&quot;&gt; &lt;Button @click&#x3D;&quot;showSubDrawer &#x3D; !showSubDrawer&quot; type&#x3D;&quot;primary&quot;&gt;Two-level Drawer&lt;&#x2F;Button&gt; &lt;&#x2F;Drawer&gt; &lt;div class&#x3D;&quot;subDrawer&quot;&gt; &lt;Drawer :mask&#x3D;&quot;false&quot; @on-close&#x3D;&quot;drawerClose&quot; class&#x3D;&quot;subdrawer-inner&quot; placement&#x3D;&quot;left&quot; title&#x3D;&quot;Two-level Drawer&quot; v-model&#x3D;&quot;showSubDrawer&quot; :transfer&#x3D;&quot;false&quot; :inner&#x3D;&quot;true&quot;&gt; This is two-level drawer. &lt;&#x2F;Drawer&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div v-show&#x3D;&quot;showDrawer&quot; class&#x3D;&quot;mask&quot; @click&#x3D;&quot;drawerClose&quot;&gt;&lt;&#x2F;div&gt; &lt;!-- 方案二结束--&gt; &lt;Layout :style&#x3D;&quot;&#123;padding: &#39;0 24px 24px&#39;&#125;&quot;&gt; &lt;Breadcrumb :style&#x3D;&quot;&#123;margin: &#39;24px 0&#39;&#125;&quot;&gt; &lt;BreadcrumbItem&gt;Home&lt;&#x2F;BreadcrumbItem&gt; &lt;BreadcrumbItem&gt;Components&lt;&#x2F;BreadcrumbItem&gt; &lt;BreadcrumbItem&gt;Layout&lt;&#x2F;BreadcrumbItem&gt; &lt;&#x2F;Breadcrumb&gt; &lt;Content :style&#x3D;&quot;&#123;padding: &#39;24px&#39;, minHeight: &#39;280px&#39;, background: &#39;#fff&#39;&#125;&quot;&gt; Content &lt;&#x2F;Content&gt; &lt;&#x2F;Layout&gt; &lt;&#x2F;Layout&gt; &lt;&#x2F;Layout&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default &#123; data() &#123; return &#123; showSubDrawer: false, showDrawer: false &#125; &#125;, methods: &#123; drawerClose()&#123; this.showDrawer &#x3D; false this.showSubDrawer &#x3D; false &#125; &#125;, &#125; &lt;&#x2F;script&gt; &lt;style scoped lang&#x3D;&quot;scss&quot;&gt; &#x2F;deep&#x2F; .ivu-layout-has-sider&#123; position: relative; &#125; &#x2F;deep&#x2F; .ivu-layout&#123; height: 100%; &#125; .layout&#123; border: 1px solid #d7dde4; background: #f5f7f9; position: relative; border-radius: 4px; overflow: hidden; &#125; .layout-logo&#123; width: 100px; height: 30px; background: #5b6270; border-radius: 3px; float: left; position: relative; top: 15px; left: 20px; &#125; .layout-nav&#123; width: 420px; margin: 0 20px 0 auto; &#125; &#x2F;*方案一*&#x2F; &#x2F;*.drawer&#123;*&#x2F; &#x2F;* div:first-child&#123;*&#x2F; &#x2F;* &#x2F;deep&#x2F; .ivu-drawer-wrap&#123;*&#x2F; &#x2F;* z-index: 1002;*&#x2F; &#x2F;* &#125;*&#x2F; &#x2F;* &#x2F;deep&#x2F; .ivu-drawer-mask&#123;*&#x2F; &#x2F;* background-color: transparent;*&#x2F; &#x2F;* &#125;*&#x2F; &#x2F;* &#125;*&#x2F; &#x2F;* .subDrawer&#123;*&#x2F; &#x2F;* div:first-child&#123;*&#x2F; &#x2F;* &#x2F;deep&#x2F; .ivu-drawer-wrap&#123;*&#x2F; &#x2F;* z-index: 1001;*&#x2F; &#x2F;* &#125;*&#x2F; &#x2F;* &#x2F;deep&#x2F; .ivu-drawer-mask&#123;*&#x2F; &#x2F;* background-color: rgba(55,55,55,.6) !important;*&#x2F; &#x2F;* &#125;*&#x2F; &#x2F;* &#125;*&#x2F; &#x2F;* &#125;*&#x2F; &#x2F;*&#125;*&#x2F; &#x2F;*方案二*&#x2F; &#x2F;*&#x2F;deep&#x2F; .ivu-menu&#123;*&#x2F; &#x2F;* z-index: 9;*&#x2F; &#x2F;*&#125; *&#x2F; .drawer&#123; div:first-child&#123; &#x2F;deep&#x2F; .ivu-drawer-wrap&#123; z-index: 1002; &#125; &#125; .subDrawer&#123; div:first-child&#123; &#x2F;deep&#x2F; .ivu-drawer-wrap&#123; z-index: 1001; &#125; &#125; &#125; &#125; .mask&#123; position: absolute; top: 0; right: 0; left: 0; bottom: 0; z-index: 1000; background-color: rgba(55,55,55,.6); &#125; .subdrawer-inner&#123; &#x2F;deep&#x2F; .ivu-drawer&#123; margin-left: 256px; &#125; &#125; &lt;&#x2F;style&gt;","permalink":"https://codermino.github.io/2020/09/13/iview%E5%A4%9A%E7%BA%A7%E6%8A%BD%E5%B1%89%E4%BC%98%E5%8C%96/","photos":[]},{"tags":[{"name":"iview可编辑表格","slug":"iview可编辑表格","permalink":"https://codermino.github.io/tags/iview%E5%8F%AF%E7%BC%96%E8%BE%91%E8%A1%A8%E6%A0%BC/"}],"title":"iview可编辑表格","date":"2020/09/13","text":"Demo1点击按钮进行编辑和保存&lt;template&gt; &lt;i-table border :columns&#x3D;&quot;columns2&quot; :data&#x3D;&quot;data3&quot;&gt;&lt;&#x2F;i-table&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default &#123; data () &#123; return &#123; columns2: [ &#123; title: &#39;Name&#39;, key: &#39;name&#39;, render: (h, params) &#x3D;&gt; &#123; if (params.row.$isEdit) &#123; return h(&#39;input&#39;, &#123; domProps: &#123; value: params.row.name &#125;, on: &#123; input: function (event) &#123; params.row.name &#x3D; event.target.value &#125; &#125; &#125;); &#125; else &#123; return h(&#39;div&#39;, params.row.name); &#125; &#125; &#125;, &#123; title: &#39;Age&#39;, key: &#39;age&#39;, render: (h, params) &#x3D;&gt; &#123; if (params.row.$isEdit) &#123; return h(&#39;input&#39;, &#123; domProps: &#123; value: params.row.age &#125;, on: &#123; input: function (event) &#123; params.row.age &#x3D; event.target.value &#125; &#125; &#125;); &#125; else &#123; return h(&#39;div&#39;, params.row.age); &#125; &#125; &#125;, &#123; title: &#39;Address&#39;, key: &#39;address&#39; &#125;, &#123; title: &#39;Action&#39;, key: &#39;action&#39;, render: (h, params) &#x3D;&gt; &#123; return h(&#39;Button&#39;, &#123; props: &#123; type: &#39;primary&#39;, size: &#39;small&#39; &#125;, on: &#123; click: () &#x3D;&gt; &#123; if (params.row.$isEdit) &#123; this.handleSave(params.row) &#125; else &#123; this.handleEdit(params.row) &#125; &#125; &#125; &#125;, params.row.$isEdit ? &#39;保存&#39; : &#39;编辑&#39;) &#125; &#125; ], data3: [ &#123; name: &#39;哈哈&#39;, age: 18, address: &#39;上海&#39;, $isEdit: false &#125;, &#123; name: &#39;啦啦&#39;, age: 24, address: &#39;北京&#39;, $isEdit: false &#125; ] &#125; &#125;, methods: &#123; handleEdit (row) &#123; this.$set(row, &#39;$isEdit&#39;, true) &#125;, handleSave (row) &#123; this.$set(row, &#39;$isEdit&#39;, false) &#125; &#125; &#125; &lt;&#x2F;script&gt; Demo2点击单元格编辑自动聚焦和可选择表格&lt;template&gt; &lt;i-table border :columns&#x3D;&quot;columns2&quot; :data&#x3D;&quot;data3&quot;&gt;&lt;&#x2F;i-table&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default &#123; data () &#123; return &#123; columns2: [ &#123; type: &#39;selection&#39;, width: 60, align: &#39;center&#39; &#125;, &#123; title: &#39;姓名&#39;, key: &#39;name&#39;, render: (h, params) &#x3D;&gt; &#123; let create &#x3D; this.$createElement let dom &#x3D; create(&#39;Input&#39;, &#123; ref: params.row.id+&#39;_name&#39;, props: &#123; type: &quot;text&quot;, value: params.row.name &#125;, on: &#123; &quot;on-blur&quot;: event &#x3D;&gt; &#123; params.row.name &#x3D; event.target.value; this.$set(params.row, &#39;$isEdit&#39;, false); &#125;, &#125; &#125;) let dom2 &#x3D; create(&#39;div&#39;, &#123; on: &#123; click: (e) &#x3D;&gt; &#123; this.$set(params.row, &#39;$isEdit&#39;, true); this.$nextTick( () &#x3D;&gt;&#123; this.$refs[params.row.id+&#39;_name&#39;].focus() &#125; ) &#125;, &#125; &#125;,params.row.name) if (params.row.$isEdit)&#123; return dom &#125; else&#123;return dom2&#125; &#125; &#125;, &#123; title: &#39;Age&#39;, key: &#39;age&#39;, render: (h, params) &#x3D;&gt; &#123; let create &#x3D; this.$createElement let dom &#x3D; create(&#39;Input&#39;, &#123; ref: params.row.id+&#39;_age&#39;, props: &#123; type: &quot;text&quot;, value: params.row.age &#125;, on: &#123; &quot;on-blur&quot;: event &#x3D;&gt; &#123; params.row.age &#x3D; event.target.value; this.$set(params.row, &#39;$isEdit&#39;, false); &#125;, &#125; &#125;) let dom2 &#x3D; create(&#39;div&#39;, &#123; on: &#123; click: (e) &#x3D;&gt; &#123; this.$set(params.row, &#39;$isEdit&#39;, true); this.$nextTick( () &#x3D;&gt;&#123; this.$refs[params.row.id+&#39;_age&#39;].focus() &#125; ) &#125;, &#125; &#125;,params.row.age) if (params.row.$isEdit)&#123; return dom &#125; else&#123;return dom2&#125; &#125; &#125;, &#123; title: &#39;Action&#39;, key: &#39;action&#39;, render: (h, params) &#x3D;&gt; &#123; return h(&#39;Button&#39;, &#123; props: &#123; type: &#39;primary&#39;, size: &#39;small&#39; &#125;, on: &#123; click: () &#x3D;&gt; &#123; if (params.row.$isEdit) &#123; this.handleSave(params.row) &#125; else &#123; this.handleEdit(params.row) &#125; &#125; &#125; &#125;, params.row.$isEdit ? &#39;保存&#39; : &#39;编辑&#39;) &#125; &#125; ], data3: [ &#123; id:1, name: &#39;王小明&#39;, age: 18, address: &#39;北京市朝阳区芍药居&#39;, date: &#39;2016-10-03&#39;, $isEdit: false &#125;, &#123; id:2, name: &#39;张小刚&#39;, age: 25, address: &#39;北京市海淀区西二旗&#39;, date: &#39;2016-10-01&#39;, $isEdit: false &#125;, &#123; id:3, name: &#39;李小红&#39;, age: 30, address: &#39;上海市浦东新区世纪大道&#39;, date: &#39;2016-10-02&#39;, $isEdit: false &#125;, &#123; id:4, name: &#39;周小伟&#39;, age: 26, address: &#39;深圳市南山区深南大道&#39;, date: &#39;2016-10-04&#39;, $isEdit: false &#125; ] &#125; &#125;, methods: &#123; handleEdit (row) &#123; this.$set(row, &#39;$isEdit&#39;, true) &#125;, handleSave (row) &#123; this.$set(row, &#39;$isEdit&#39;, false) &#125; &#125; &#125; &lt;&#x2F;script&gt; Demo3功能同Demo2，无操作按钮&lt;template&gt; &lt;i-table border :columns&#x3D;&quot;columns2&quot; :data&#x3D;&quot;data3&quot;&gt;&lt;&#x2F;i-table&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default &#123; data () &#123; return &#123; columns2: [ &#123; type: &#39;selection&#39;, width: 60, align: &#39;center&#39; &#125;, &#123; title: &#39;姓名&#39;, key: &#39;name&#39;, render: (h, params) &#x3D;&gt; &#123; let create &#x3D; this.$createElement let dom &#x3D; create(&#39;Input&#39;, &#123; ref: params.row.id+&#39;_name&#39;, props: &#123; type: &quot;text&quot;, value: params.row.name &#125;, on: &#123; &quot;on-blur&quot;: event &#x3D;&gt; &#123; params.row.name &#x3D; event.target.value; this.$set(params.row, &#39;$isEdit&#39;, false); &#125;, &#125; &#125;) let dom2 &#x3D; create(&#39;div&#39;, &#123; on: &#123; click: (e) &#x3D;&gt; &#123; this.$set(params.row, &#39;$isEdit&#39;, true); this.$nextTick( () &#x3D;&gt;&#123; this.$refs[params.row.id+&#39;_name&#39;].focus() &#125; ) &#125;, &#125; &#125;,params.row.name) if (params.row.$isEdit)&#123; return dom &#125; else&#123;return dom2&#125; &#125; &#125;, &#123; title: &#39;Age&#39;, key: &#39;age&#39;, render: (h, params) &#x3D;&gt; &#123; let create &#x3D; this.$createElement let dom &#x3D; create(&#39;Input&#39;, &#123; ref: params.row.id+&#39;_age&#39;, props: &#123; type: &quot;text&quot;, value: params.row.age &#125;, on: &#123; &quot;on-blur&quot;: event &#x3D;&gt; &#123; params.row.age &#x3D; event.target.value; this.$set(params.row, &#39;$isEdit&#39;, false); &#125;, &#125; &#125;) let dom2 &#x3D; create(&#39;div&#39;, &#123; on: &#123; click: (e) &#x3D;&gt; &#123; this.$set(params.row, &#39;$isEdit&#39;, true); this.$nextTick( () &#x3D;&gt;&#123; this.$refs[params.row.id+&#39;_age&#39;].focus() &#125; ) &#125;, &#125; &#125;,params.row.age) if (params.row.$isEdit)&#123; return dom &#125; else&#123;return dom2&#125; &#125; &#125; ], data3: [ &#123; id:1, name: &#39;王小明&#39;, age: 18, address: &#39;北京市朝阳区芍药居&#39;, date: &#39;2016-10-03&#39;, $isEdit: false &#125;, &#123; id:2, name: &#39;张小刚&#39;, age: 25, address: &#39;北京市海淀区西二旗&#39;, date: &#39;2016-10-01&#39;, $isEdit: false &#125;, &#123; id:3, name: &#39;李小红&#39;, age: 30, address: &#39;上海市浦东新区世纪大道&#39;, date: &#39;2016-10-02&#39;, $isEdit: false &#125;, &#123; id:4, name: &#39;周小伟&#39;, age: 26, address: &#39;深圳市南山区深南大道&#39;, date: &#39;2016-10-04&#39;, $isEdit: false &#125; ] &#125; &#125;, methods: &#123; handleEdit (row) &#123; this.$set(row, &#39;$isEdit&#39;, true) &#125;, handleSave (row) &#123; this.$set(row, &#39;$isEdit&#39;, false) &#125; &#125; &#125; &lt;&#x2F;script&gt; Demo4更改ref设置方式&lt;template&gt; &lt;i-table border :columns&#x3D;&quot;columns2&quot; :data&#x3D;&quot;data3&quot;&gt;&lt;&#x2F;i-table&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default &#123; data () &#123; return &#123; columns2: [ &#123; type: &#39;selection&#39;, width: 60, align: &#39;center&#39; &#125;, &#123; title: &#39;姓名&#39;, key: &#39;name&#39;, render: (h, params) &#x3D;&gt; &#123; let create &#x3D; this.$createElement let dom1 &#x3D; create(&#39;Input&#39;, &#123; ref: params.row[Object.keys(params.row)[Object.keys(params.row).length-2]]+&#39;_name&#39;, props: &#123; type: &quot;text&quot;, value: params.row.name &#125;, on: &#123; &quot;on-blur&quot;: event &#x3D;&gt; &#123; params.row.name &#x3D; event.target.value; this.$set(params.row, &#39;$isEdit&#39;, false); &#125;, &#125; &#125;) let dom2 &#x3D; create(&#39;div&#39;, &#123; on: &#123; click: (e) &#x3D;&gt; &#123; this.$set(params.row, &#39;$isEdit&#39;, true); this.$nextTick( () &#x3D;&gt;&#123; this.$refs[params.row[Object.keys(params.row)[Object.keys(params.row).length-2]]+&#39;_name&#39;].focus() &#125; ) &#125;, &#125; &#125;,params.row.name) if (params.row.$isEdit)&#123; return dom1 &#125; else&#123;return dom2&#125; &#125; &#125;, &#123; title: &#39;Age&#39;, key: &#39;age&#39;, render: (h, params) &#x3D;&gt; &#123; let create &#x3D; this.$createElement let dom3 &#x3D; create(&#39;Input&#39;, &#123; ref: params.row[Object.keys(params.row)[Object.keys(params.row).length-2]]+&#39;_age&#39;, props: &#123; type: &quot;text&quot;, value: params.row.age &#125;, on: &#123; &quot;on-blur&quot;: event &#x3D;&gt; &#123; params.row.age &#x3D; event.target.value; this.$set(params.row, &#39;$isEdit&#39;, false); &#125;, &#125; &#125;) let dom4 &#x3D; create(&#39;div&#39;, &#123; on: &#123; click: (e) &#x3D;&gt; &#123; this.$set(params.row, &#39;$isEdit&#39;, true); this.$nextTick( () &#x3D;&gt;&#123; this.$refs[params.row[Object.keys(params.row)[Object.keys(params.row).length-2]]+&#39;_age&#39;].focus() &#125; ) &#125;, &#125; &#125;,params.row.age) if (params.row.$isEdit)&#123; return dom3 &#125; else&#123;return dom4&#125; &#125; &#125; ], data3: [ &#123; name: &#39;王小明&#39;, age: 18, $isEdit: false &#125;, &#123; name: &#39;张小刚&#39;, age: 25, $isEdit: false &#125;, &#123; name: &#39;李小红&#39;, age: 30, $isEdit: false &#125;, &#123; name: &#39;周小伟&#39;, age: 26, $isEdit: false &#125; ] &#125; &#125;, methods: &#123; handleEdit (row) &#123; this.$set(row, &#39;$isEdit&#39;, true) &#125;, handleSave (row) &#123; this.$set(row, &#39;$isEdit&#39;, false) &#125; &#125; &#125; &lt;&#x2F;script&gt; Demo5增加回车事件&lt;template&gt; &lt;div&gt; &lt;i-table border :columns&#x3D;&quot;columns2&quot; :data&#x3D;&quot;data3&quot;&gt;&lt;&#x2F;i-table&gt; &lt;Divider orientation&#x3D;&quot;left&quot;&gt;Left Text&lt;&#x2F;Divider&gt; &#123;&#123;data3&#125;&#125; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default &#123; data () &#123; return &#123; columns2: [ &#123; type: &#39;selection&#39;, width: 60, align: &#39;center&#39; &#125;, &#123; title: &#39;姓名&#39;, key: &#39;name&#39;, render: (h, params) &#x3D;&gt; &#123; let create &#x3D; this.$createElement; let dom1 &#x3D; create(&#39;Input&#39;, &#123; ref: params.row[Object.keys(params.row)[Object.keys(params.row).length-2]]+&#39;_name&#39;, props: &#123; type: &quot;text&quot;, value: params.row.name, placeholder:&#39;请输入姓名&#39; &#125;, on: &#123; &quot;on-blur&quot;: event &#x3D;&gt; &#123; params.row.name &#x3D; event.target.value; this.data3[params.index].name &#x3D; event.target.value; this.$set(params.row, &#39;$isEdit&#39;, false); &#125;, &quot;on-enter&quot;:event&#x3D;&gt;&#123; params.row.name &#x3D; event.target.value; this.data3[params.index].name &#x3D; event.target.value; this.$set(params.row, &#39;$isEdit&#39;, false); &#125; &#125; &#125;) let dom2 &#x3D; create(&#39;div&#39;, &#123; on: &#123; click: (e) &#x3D;&gt; &#123; this.$set(params.row, &#39;$isEdit&#39;, true); this.$nextTick( () &#x3D;&gt;&#123; this.$refs[params.row[Object.keys(params.row)[Object.keys(params.row).length-2]]+&#39;_name&#39;].focus() &#125; ) &#125;, &#125; &#125;,params.row.name) if (params.row.$isEdit)&#123; return dom1 &#125; else&#123;return dom2&#125; &#125; &#125;, &#123; title: &#39;Age&#39;, key: &#39;age&#39;, render: (h, params) &#x3D;&gt; &#123; let create &#x3D; this.$createElement let dom3 &#x3D; create(&#39;Input&#39;, &#123; ref: params.row[Object.keys(params.row)[Object.keys(params.row).length-2]]+&#39;_age&#39;, props: &#123; type: &quot;text&quot;, value: params.row.age, placeholder:&#39;请输入年龄&#39; &#125;, on: &#123; &quot;on-blur&quot;: event &#x3D;&gt; &#123; params.row.age &#x3D; event.target.value; this.data3[params.index].age &#x3D; event.target.value; this.$set(params.row, &#39;$isEdit&#39;, false); &#125;, &quot;on-enter&quot;:event&#x3D;&gt;&#123; params.row.name &#x3D; event.target.value; this.data3[params.index].age &#x3D; event.target.value; this.$set(params.row, &#39;$isEdit&#39;, false); &#125; &#125; &#125;) let dom4 &#x3D; create(&#39;div&#39;, &#123; on: &#123; click: (e) &#x3D;&gt; &#123; this.$set(params.row, &#39;$isEdit&#39;, true); this.$nextTick( () &#x3D;&gt;&#123; this.$refs[params.row[Object.keys(params.row)[Object.keys(params.row).length-2]]+&#39;_age&#39;].focus() &#125; ) &#125;, &#125; &#125;,params.row.age) if (params.row.$isEdit)&#123; return dom3 &#125; else&#123;return dom4&#125; &#125; &#125;, &#123; title: &#39;Age&#39;, key: &#39;age&#39; &#125; ], data3: [ &#123; name: &#39;王小明&#39;, age: 18, address:&#39;123&#39;, $isEdit: false &#125;, &#123; name: &#39;张小刚&#39;, age: 25, address:&#39;123&#39;, $isEdit: false &#125;, &#123; name: &#39;李小红&#39;, age: 30, address:&#39;123&#39;, $isEdit: false &#125;, &#123; name: &#39;周小伟&#39;, age: 26, $isEdit: false, address:&#39;123&#39; &#125; ] &#125; &#125;, methods: &#123; handleEdit (row) &#123; this.$set(row, &#39;$isEdit&#39;, true) &#125;, handleSave (row) &#123; this.$set(row, &#39;$isEdit&#39;, false) &#125; &#125; &#125; &lt;&#x2F;script&gt; Demo6&lt;template&gt; &lt;i-table border :columns&#x3D;&quot;columns2&quot; :data&#x3D;&quot;data3&quot;&gt;&lt;&#x2F;i-table&gt; &lt;Divider &#x2F;&gt; &#123;&#123;data3&#125;&#125; &lt;Divider &#x2F;&gt; &lt;Button @click&#x3D;&quot;submit&quot;&gt; 提交 &lt;&#x2F;Button&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default &#123; data () &#123; return &#123; columns2: [ &#123; type: &#39;selection&#39;, width: 60, align: &#39;center&#39; &#125;, &#123; width: 80, type: &#39;index&#39;, title: &#39;序号&#39;, align: &#39;center&#39; &#125;, &#123; title: &#39;Name&#39;, key: &#39;name&#39;, align: &#39;center&#39;, render: (h, params) &#x3D;&gt; &#123; if (params.row.$isEdit) &#123; return h(&#39;Input&#39;, &#123; props: &#123; value: params.row.name &#125;, on: &#123; input: (event)&#x3D;&gt; &#123; params.row.name &#x3D; event &#125; &#125; &#125;); &#125; else &#123; return h(&#39;div&#39;, params.row.name); &#125; &#125; &#125;, &#123; title: &#39;Age&#39;, key: &#39;age&#39;, align: &#39;center&#39;, render: (h, params) &#x3D;&gt; &#123; if (params.row.$isEdit) &#123; return h(&#39;Input&#39;, &#123; props: &#123; value: params.row.age &#125;, on: &#123; input: (event)&#x3D;&gt; &#123; params.row.age &#x3D; event &#125; &#125; &#125;); &#125; else &#123; return h(&#39;div&#39;, params.row.age); &#125; &#125; &#125;, &#123; title: &#39;Address&#39;, key: &#39;address&#39;, align: &#39;center&#39; &#125;, &#123; title: &#39;操作&#39;, key: &#39;action&#39;, align: &#39;center&#39;, render: (h, params) &#x3D;&gt; &#123; return h(&#39;Button&#39;, &#123; props: &#123; type: &#39;primary&#39;, size: &#39;small&#39;, type: params.row.$isEdit ? &#39;success&#39; : &#39;primary&#39;, &#125;, on: &#123; click: () &#x3D;&gt; &#123; if (params.row.$isEdit) &#123; this.handleSave(params.row,params.index) &#125; else &#123; this.handleEdit(params.row) &#125; &#125; &#125; &#125;, params.row.$isEdit ? &#39;保存&#39; : &#39;编辑&#39;) &#125; &#125; ], data3: [ &#123; name: &#39;哈哈&#39;, age: 18, address: &#39;上海&#39;, $isEdit: false &#125;, &#123; name: &#39;&#39;, age: 24, address: &#39;北京&#39;, $isEdit: false &#125; ], data4: [ &#123; name: &#39;哈哈&#39;, age: 18, address: &#39;上海&#39;, $isEdit: false &#125;, &#123; name: &#39;&#39;, age: 24, address: &#39;北京&#39;, $isEdit: false &#125; ] &#125; &#125;, methods: &#123; handleEdit (row) &#123; this.$set(row, &#39;$isEdit&#39;, true) &#125;, handleSave (row, index) &#123; this.$set(row, &#39;$isEdit&#39;, false) this.$set(this.data4, index, row) &#125;, submit()&#123; console.log(this.data4) &#125; &#125; &#125; &lt;&#x2F;script&gt; Demo7&lt;template&gt; &lt;i-table border :columns&#x3D;&quot;columns2&quot; :data&#x3D;&quot;data3&quot;&gt;&lt;&#x2F;i-table&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default &#123; data () &#123; return &#123; columns2: [ &#123; type: &#39;selection&#39;, width: 60, align: &#39;center&#39; &#125;, &#123; width: 80, type: &#39;index&#39;, title: &#39;序号&#39;, align: &#39;center&#39; &#125;, &#123; title: &#39;Name&#39;, key: &#39;name&#39;, align: &#39;center&#39;, render: (h, params) &#x3D;&gt; &#123; if (params.row.$isEdit) &#123; return h(&#39;Input&#39;, &#123; props: &#123; value: params.row.name &#125;, on: &#123; input: function (event) &#123; params.row.name &#x3D; event.target.value &#125; &#125; &#125;); &#125; else &#123; return h(&#39;div&#39;, params.row.name); &#125; &#125; &#125;, &#123; title: &#39;Age&#39;, key: &#39;age&#39;, align: &#39;center&#39;, render: (h, params) &#x3D;&gt; &#123; if (params.row.$isEdit) &#123; return h(&#39;Input&#39;, &#123; props: &#123; value: params.row.age &#125;, on: &#123; input: function (event) &#123; params.row.age &#x3D; event.target.value &#125; &#125; &#125;); &#125; else &#123; return h(&#39;div&#39;, params.row.age); &#125; &#125; &#125;, &#123; title: &#39;Address&#39;, key: &#39;address&#39;, align: &#39;center&#39;, render: (h, params) &#x3D;&gt; &#123; return h(&#39;a&#39;, &#123; domProps: &#123; text: params.row.address &#125;, on: &#123; click: (event)&#x3D;&gt; &#123; this.clickAddress(params.row) &#125; &#125; &#125;); &#125; &#125;, &#123; title: &#39;操作&#39;, key: &#39;action&#39;, align: &#39;center&#39;, width: 80, render: (h, params) &#x3D;&gt; &#123; return h(&#39;Icon&#39;, &#123; props: &#123; type: params.row.$isEdit ? &#39;ios-checkmark&#39; : &#39;md-add&#39;, size: 48 &#125;, on: &#123; click: () &#x3D;&gt; &#123; if (params.row.$isEdit) &#123; this.handleSave(params.row) &#125; else &#123; this.handleEdit(params.row) &#125; &#125; &#125; &#125;) &#125; &#125; ], data3: [ &#123; name: &#39;哈哈&#39;, age: 18, address: &#39;上海&#39;, $isEdit: false &#125;, &#123; name: &#39;&#39;, age: 24, address: &#39;北京&#39;, $isEdit: false &#125; ] &#125; &#125;, methods: &#123; handleEdit (row) &#123; this.$set(row, &#39;$isEdit&#39;, true) &#125;, handleSave (row) &#123; this.$set(row, &#39;$isEdit&#39;, false) &#125;, clickAddress(row)&#123; console.log(row); &#125; &#125; &#125; &lt;&#x2F;script&gt; Demo8&lt;template&gt; &lt;div style&#x3D;&quot;width: 600px;margin: 0 auto;&quot;&gt; &lt;i-table border :columns&#x3D;&quot;columns2&quot; :data&#x3D;&quot;data3&quot;&gt;&lt;&#x2F;i-table&gt; &lt;Divider &#x2F;&gt; &#123;&#123;data3&#125;&#125; &lt;Divider &#x2F;&gt; &lt;Button @click&#x3D;&quot;submit&quot;&gt; 提交 &lt;&#x2F;Button&gt; &lt;Divider &#x2F;&gt; &#123;&#123;data4&#125;&#125; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default &#123; data () &#123; return &#123; columns2: [ &#123; type: &#39;selection&#39;, width: 60, align: &#39;center&#39; &#125;, &#123; width: 80, type: &#39;index&#39;, title: &#39;序号&#39;, align: &#39;center&#39; &#125;, &#123; title: &#39;Name&#39;, key: &#39;name&#39;, align: &#39;center&#39;, render: (h, params) &#x3D;&gt; &#123; if (params.row.$isEdit) &#123; return h(&#39;Input&#39;, &#123; props: &#123; value: params.row.name &#125;, on: &#123; input: (event)&#x3D;&gt; &#123; params.row.name &#x3D; event &#125; &#125; &#125;); &#125; else &#123; return h(&#39;div&#39;, params.row.name); &#125; &#125; &#125;, &#123; title: &#39;Age&#39;, key: &#39;age&#39;, align: &#39;center&#39;, render: (h, params) &#x3D;&gt; &#123; if (params.row.$isEdit) &#123; return h(&#39;Input&#39;, &#123; props: &#123; value: params.row.age &#125;, on: &#123; input: (event)&#x3D;&gt; &#123; params.row.age &#x3D; event &#125; &#125; &#125;); &#125; else &#123; return h(&#39;div&#39;, params.row.age); &#125; &#125; &#125;, &#123; title: &#39;Address&#39;, key: &#39;address&#39;, align: &#39;center&#39; &#125;, &#123; title: &#39;操作&#39;, key: &#39;action&#39;, align: &#39;center&#39;, render: (h, params) &#x3D;&gt; &#123; let children &#x3D; []; children.push(this.iconRender(h, params)) children.push(this.buttonRender(h, params)) return h(&#39;div&#39;, children); &#125; &#125; ], data3: [ &#123; name: &#39;哈哈&#39;, age: 18, address: &#39;上海&#39;, $isEdit: false &#125;, &#123; name: &#39;&#39;, age: 24, address: &#39;北京&#39;, $isEdit: false &#125; ], data4: [ &#123; name: &#39;哈哈&#39;, age: 18, address: &#39;上海&#39;, $isEdit: false &#125;, &#123; name: &#39;&#39;, age: 24, address: &#39;北京&#39;, $isEdit: false &#125; ] &#125; &#125;, methods: &#123; iconRender(h,params)&#123; return h(&#39;Icon&#39;, &#123; props: &#123; custom: params.row.$isEdit ? &#39;iconfont icon-save1&#39; : &#39;iconfont icon-edit&#39;, &#125;, style:&#123; cursor:&#39;pointer&#39; &#125;, on: &#123; click: () &#x3D;&gt; &#123; if (params.row.$isEdit) &#123; this.handleSave(params.row,params.index) &#125; else &#123; this.handleEdit(params.row) &#125; &#125; &#125; &#125;) &#125;, buttonRender(h,params)&#123; return h(&#39;Button&#39;, &#123; props: &#123; size: &#39;small&#39;, type: params.row.$isEdit ? &#39;success&#39; : &#39;primary&#39;, &#125;, on: &#123; click: () &#x3D;&gt; &#123; if (params.row.$isEdit) &#123; this.handleSave(params.row,params.index) &#125; else &#123; this.handleEdit(params.row) &#125; &#125; &#125; &#125;, params.row.$isEdit ? &#39;保存&#39; : &#39;编辑&#39;) &#125;, handleEdit (row) &#123; this.$set(row, &#39;$isEdit&#39;, true) &#125;, handleSave (row, index) &#123; this.$set(row, &#39;$isEdit&#39;, false) this.$set(this.data4, index, row) &#125;, submit()&#123; console.log(this.data4) &#125; &#125; &#125; &lt;&#x2F;script&gt; &lt;!--&lt;template&gt;--&gt; &lt;!-- &lt;div style&#x3D;&quot;width: 600px;margin: 0 auto;&quot;&gt;--&gt; &lt;!-- &lt;i-table border :columns&#x3D;&quot;columns2&quot; :data&#x3D;&quot;data3&quot;&gt;&lt;&#x2F;i-table&gt;--&gt; &lt;!-- &lt;Divider &#x2F;&gt;--&gt; &lt;!-- &#123;&#123;data3&#125;&#125;--&gt; &lt;!-- &lt;Divider &#x2F;&gt;--&gt; &lt;!-- &lt;Button @click&#x3D;&quot;submit&quot;&gt;--&gt; &lt;!-- 提交--&gt; &lt;!-- &lt;&#x2F;Button&gt;--&gt; &lt;!-- &lt;Divider &#x2F;&gt;--&gt; &lt;!-- &#123;&#123;data4&#125;&#125;--&gt; &lt;!-- &lt;&#x2F;div&gt;--&gt; &lt;!--&lt;&#x2F;template&gt;--&gt; &lt;!--&lt;script&gt;--&gt; &lt;!--export default &#123;--&gt; &lt;!-- data () &#123;--&gt; &lt;!-- return &#123;--&gt; &lt;!-- columns2: [--&gt; &lt;!-- &#123;--&gt; &lt;!-- type: &#39;selection&#39;,--&gt; &lt;!-- width: 60,--&gt; &lt;!-- align: &#39;center&#39;--&gt; &lt;!-- &#125;,--&gt; &lt;!-- &#123;--&gt; &lt;!-- width: 80,--&gt; &lt;!-- type: &#39;index&#39;,--&gt; &lt;!-- title: &#39;序号&#39;,--&gt; &lt;!-- align: &#39;center&#39;--&gt; &lt;!-- &#125;,--&gt; &lt;!-- &#123;--&gt; &lt;!-- title: &#39;Name&#39;,--&gt; &lt;!-- key: &#39;name&#39;,--&gt; &lt;!-- align: &#39;center&#39;,--&gt; &lt;!-- render: (h, params) &#x3D;&gt; &#123;--&gt; &lt;!-- if (params.row.$isEdit) &#123;--&gt; &lt;!-- return h(&#39;Input&#39;, &#123;--&gt; &lt;!-- props: &#123;--&gt; &lt;!-- value: params.row.name--&gt; &lt;!-- &#125;,--&gt; &lt;!-- on: &#123;--&gt; &lt;!-- input: (event)&#x3D;&gt; &#123;--&gt; &lt;!-- params.row.name &#x3D; event--&gt; &lt;!-- &#125;--&gt; &lt;!-- &#125;--&gt; &lt;!-- &#125;);--&gt; &lt;!-- &#125; else &#123;--&gt; &lt;!-- return h(&#39;div&#39;, params.row.name);--&gt; &lt;!-- &#125;--&gt; &lt;!-- &#125;--&gt; &lt;!-- &#125;,--&gt; &lt;!-- &#123;--&gt; &lt;!-- title: &#39;Age&#39;,--&gt; &lt;!-- key: &#39;age&#39;,--&gt; &lt;!-- align: &#39;center&#39;,--&gt; &lt;!-- render: (h, params) &#x3D;&gt; &#123;--&gt; &lt;!-- if (params.row.$isEdit) &#123;--&gt; &lt;!-- return h(&#39;Input&#39;, &#123;--&gt; &lt;!-- props: &#123;--&gt; &lt;!-- value: params.row.age--&gt; &lt;!-- &#125;,--&gt; &lt;!-- on: &#123;--&gt; &lt;!-- input: (event)&#x3D;&gt; &#123;--&gt; &lt;!-- params.row.age &#x3D; event--&gt; &lt;!-- &#125;--&gt; &lt;!-- &#125;--&gt; &lt;!-- &#125;);--&gt; &lt;!-- &#125; else &#123;--&gt; &lt;!-- return h(&#39;div&#39;, params.row.age);--&gt; &lt;!-- &#125;--&gt; &lt;!-- &#125;--&gt; &lt;!-- &#125;,--&gt; &lt;!-- &#123;--&gt; &lt;!-- title: &#39;Address&#39;,--&gt; &lt;!-- key: &#39;address&#39;,--&gt; &lt;!-- align: &#39;center&#39;--&gt; &lt;!-- &#125;,--&gt; &lt;!-- &#123;--&gt; &lt;!-- title: &#39;操作&#39;,--&gt; &lt;!-- key: &#39;action&#39;,--&gt; &lt;!-- align: &#39;center&#39;,--&gt; &lt;!-- render: (h, params) &#x3D;&gt; &#123;--&gt; &lt;!-- return h(&#39;Button&#39;, &#123;--&gt; &lt;!-- props: &#123;--&gt; &lt;!-- size: &#39;small&#39;,--&gt; &lt;!-- type: params.row.$isEdit ? &#39;success&#39; : &#39;primary&#39;,--&gt; &lt;!-- &#125;,--&gt; &lt;!-- on: &#123;--&gt; &lt;!-- click: () &#x3D;&gt; &#123;--&gt; &lt;!-- if (params.row.$isEdit) &#123;--&gt; &lt;!-- this.handleSave(params.row,params.index)--&gt; &lt;!-- &#125; else &#123;--&gt; &lt;!-- this.handleEdit(params.row)--&gt; &lt;!-- &#125;--&gt; &lt;!-- &#125;--&gt; &lt;!-- &#125;--&gt; &lt;!-- &#125;, params.row.$isEdit ? &#39;保存&#39; : &#39;编辑&#39;)--&gt; &lt;!-- &#125;--&gt; &lt;!-- &#125;--&gt; &lt;!-- ],--&gt; &lt;!-- data3: [--&gt; &lt;!-- &#123;--&gt; &lt;!-- name: &#39;哈哈&#39;,--&gt; &lt;!-- age: 18,--&gt; &lt;!-- address: &#39;上海&#39;,--&gt; &lt;!-- $isEdit: false--&gt; &lt;!-- &#125;,--&gt; &lt;!-- &#123;--&gt; &lt;!-- name: &#39;&#39;,--&gt; &lt;!-- age: 24,--&gt; &lt;!-- address: &#39;北京&#39;,--&gt; &lt;!-- $isEdit: false--&gt; &lt;!-- &#125;--&gt; &lt;!-- ],--&gt; &lt;!-- data4: [--&gt; &lt;!-- &#123;--&gt; &lt;!-- name: &#39;哈哈&#39;,--&gt; &lt;!-- age: 18,--&gt; &lt;!-- address: &#39;上海&#39;,--&gt; &lt;!-- $isEdit: false--&gt; &lt;!-- &#125;,--&gt; &lt;!-- &#123;--&gt; &lt;!-- name: &#39;&#39;,--&gt; &lt;!-- age: 24,--&gt; &lt;!-- address: &#39;北京&#39;,--&gt; &lt;!-- $isEdit: false--&gt; &lt;!-- &#125;--&gt; &lt;!-- ]--&gt; &lt;!-- &#125;--&gt; &lt;!-- &#125;,--&gt; &lt;!-- methods: &#123;--&gt; &lt;!-- handleEdit (row) &#123;--&gt; &lt;!-- this.$set(row, &#39;$isEdit&#39;, true)--&gt; &lt;!-- &#125;,--&gt; &lt;!-- handleSave (row, index) &#123;--&gt; &lt;!-- this.$set(row, &#39;$isEdit&#39;, false)--&gt; &lt;!-- this.$set(this.data4, index, row)--&gt; &lt;!-- &#125;,--&gt; &lt;!-- submit()&#123;--&gt; &lt;!-- console.log(this.data4)--&gt; &lt;!-- &#125;--&gt; &lt;!-- &#125;--&gt; &lt;!--&#125;--&gt; &lt;!--&lt;&#x2F;script&gt;--&gt; &lt;!--&lt;template&gt;--&gt; &lt;!-- &lt;div style&#x3D;&quot;width: 600px;margin: 0 auto&quot;&gt;--&gt; &lt;!-- &lt;i-table border :columns&#x3D;&quot;columns2&quot; :data&#x3D;&quot;data3&quot;&gt;&lt;&#x2F;i-table&gt;--&gt; &lt;!-- &lt;Divider orientation&#x3D;&quot;left&quot;&gt;Left Text&lt;&#x2F;Divider&gt;--&gt; &lt;!-- &#123;&#123;data3&#125;&#125;--&gt; &lt;!-- &lt;Divider orientation&#x3D;&quot;left&quot;&gt;Left Text&lt;&#x2F;Divider&gt;--&gt; &lt;!-- &#123;&#123;data4&#125;&#125;--&gt; &lt;!-- &lt;&#x2F;div&gt;--&gt; &lt;!--&lt;&#x2F;template&gt;--&gt; &lt;!--&lt;script&gt;--&gt; &lt;!--export default &#123;--&gt; &lt;!-- data () &#123;--&gt; &lt;!-- return &#123;--&gt; &lt;!-- columns2: [--&gt; &lt;!-- &#123;--&gt; &lt;!-- title: &#39;姓名&#39;,--&gt; &lt;!-- key: &#39;name&#39;,--&gt; &lt;!-- render: (h, params) &#x3D;&gt; &#123;--&gt; &lt;!-- let create &#x3D; this.$createElement;--&gt; &lt;!-- let dom1 &#x3D; create(&#39;Input&#39;, &#123;--&gt; &lt;!-- ref: params.row[Object.keys(params.row)[Object.keys(params.row).length-2]]+&#39;_name&#39;,--&gt; &lt;!-- props: &#123;--&gt; &lt;!-- type: &quot;text&quot;,--&gt; &lt;!-- value: params.row.name,--&gt; &lt;!-- placeholder:&#39;请输入姓名&#39;--&gt; &lt;!-- &#125;,--&gt; &lt;!-- on: &#123;--&gt; &lt;!-- &quot;on-blur&quot;: event &#x3D;&gt; &#123;--&gt; &lt;!-- this.blur &#x3D; this.lastIndex !&#x3D;&#x3D; params.index;--&gt; &lt;!-- if (this.firstClick)&#123;--&gt; &lt;!-- this.blur&#x3D;true--&gt; &lt;!-- this.firstClick&#x3D;false--&gt; &lt;!-- &#125;--&gt; &lt;!-- console.log(&#39;name&#39;,this.blur);--&gt; &lt;!-- if (this.blur)&#123;--&gt; &lt;!-- this.$set(params.row, &#39;$isEdit&#39;, false);--&gt; &lt;!-- this.lastIndex&#x3D;params.index--&gt; &lt;!-- &#125;--&gt; &lt;!-- params.row.name &#x3D; event.target.value;--&gt; &lt;!-- this.data4[params.index].name &#x3D; event.target.value;--&gt; &lt;!-- &#125;--&gt; &lt;!-- &#125;--&gt; &lt;!-- &#125;)--&gt; &lt;!-- let dom2 &#x3D; create(&#39;div&#39;, &#123;--&gt; &lt;!-- on: &#123;--&gt; &lt;!-- click: (e) &#x3D;&gt; &#123;--&gt; &lt;!-- console.log(&#39;name&#39;,this.lastIndex, params.index)--&gt; &lt;!-- if (params.index &#x3D;&#x3D;&#x3D; this.lastIndex)&#123;--&gt; &lt;!-- this.blur&#x3D;false--&gt; &lt;!-- &#125;--&gt; &lt;!-- if (this.lastIndex&#x3D;&#x3D;&#x3D;-1)&#123;--&gt; &lt;!-- this.lastIndex &#x3D; params.index--&gt; &lt;!-- &#125;--&gt; &lt;!-- this.$set(params.row, &#39;$isEdit&#39;, true);--&gt; &lt;!-- this.$nextTick( () &#x3D;&gt;&#123;--&gt; &lt;!-- this.$refs[params.row[Object.keys(params.row)[Object.keys(params.row).length-2]]+&#39;_name&#39;].focus()--&gt; &lt;!-- &#125;)--&gt; &lt;!-- &#125;,--&gt; &lt;!-- &#125; &#125;,params.row.name)--&gt; &lt;!-- if (params.row.$isEdit)&#123;--&gt; &lt;!-- return dom1--&gt; &lt;!-- &#125;--&gt; &lt;!-- else&#123;return dom2&#125;--&gt; &lt;!-- &#125;--&gt; &lt;!-- &#125;,--&gt; &lt;!-- &#123;--&gt; &lt;!-- title: &#39;Age&#39;,--&gt; &lt;!-- key: &#39;age&#39;,--&gt; &lt;!-- render: (h, params) &#x3D;&gt; &#123;--&gt; &lt;!-- let create &#x3D; this.$createElement--&gt; &lt;!-- let dom3 &#x3D; create(&#39;Input&#39;, &#123;--&gt; &lt;!-- ref: params.row[Object.keys(params.row)[Object.keys(params.row).length-2]]+&#39;_age&#39;,--&gt; &lt;!-- props: &#123;--&gt; &lt;!-- type: &quot;text&quot;,--&gt; &lt;!-- value: params.row.age,--&gt; &lt;!-- placeholder:&#39;请输入年龄&#39;--&gt; &lt;!-- &#125;,--&gt; &lt;!-- on: &#123;--&gt; &lt;!-- &quot;on-blur&quot;: event &#x3D;&gt; &#123;--&gt; &lt;!-- this.blur &#x3D; this.lastIndex !&#x3D;&#x3D; params.index;--&gt; &lt;!-- if (this.firstClick)&#123;--&gt; &lt;!-- this.blur&#x3D;true--&gt; &lt;!-- this.firstClick&#x3D;false--&gt; &lt;!-- &#125;--&gt; &lt;!-- console.log(&#39;age&#39;,this.blur);--&gt; &lt;!-- if (this.blur)&#123;--&gt; &lt;!-- this.$set(params.row, &#39;$isEdit&#39;, false);--&gt; &lt;!-- this.lastIndex&#x3D;params.index--&gt; &lt;!-- &#125;--&gt; &lt;!-- params.row.age &#x3D; event.target.value;--&gt; &lt;!-- this.data4[params.index].age &#x3D; event.target.value;--&gt; &lt;!-- &#125;--&gt; &lt;!-- &#125;--&gt; &lt;!-- &#125;)--&gt; &lt;!-- let dom4 &#x3D; create(&#39;div&#39;, &#123;--&gt; &lt;!-- on: &#123;--&gt; &lt;!-- click: (e) &#x3D;&gt; &#123;--&gt; &lt;!-- console.log(&#39;age&#39;,this.lastIndex, params.index)--&gt; &lt;!-- if (params.index &#x3D;&#x3D;&#x3D; this.lastIndex)&#123;--&gt; &lt;!-- this.blur&#x3D;false--&gt; &lt;!-- &#125;--&gt; &lt;!-- if (this.lastIndex&#x3D;&#x3D;&#x3D;-1)&#123;--&gt; &lt;!-- this.lastIndex &#x3D; params.index--&gt; &lt;!-- &#125;--&gt; &lt;!-- this.$set(params.row, &#39;$isEdit&#39;, true);--&gt; &lt;!-- this.$nextTick( () &#x3D;&gt;&#123;--&gt; &lt;!-- this.$refs[params.row[Object.keys(params.row)[Object.keys(params.row).length-2]]+&#39;_age&#39;].focus()--&gt; &lt;!-- &#125; )--&gt; &lt;!-- &#125;,--&gt; &lt;!-- &#125; &#125;,params.row.age)--&gt; &lt;!-- if (params.row.$isEdit)&#123;--&gt; &lt;!-- return dom3--&gt; &lt;!-- &#125;--&gt; &lt;!-- else&#123;return dom4&#125;--&gt; &lt;!-- &#125;--&gt; &lt;!-- &#125;--&gt; &lt;!-- ],--&gt; &lt;!-- data3: [--&gt; &lt;!-- &#123;--&gt; &lt;!-- name: &#39;王小明&#39;,--&gt; &lt;!-- age: &#39;18&#39;,--&gt; &lt;!-- address:&#39;123&#39;,--&gt; &lt;!-- $isEdit: false--&gt; &lt;!-- &#125;,--&gt; &lt;!-- &#123;--&gt; &lt;!-- name: &#39;张小刚&#39;,--&gt; &lt;!-- age: &#39;25&#39;,--&gt; &lt;!-- address:&#39;123&#39;,--&gt; &lt;!-- $isEdit: false--&gt; &lt;!-- &#125;,--&gt; &lt;!-- &#123;--&gt; &lt;!-- name: &#39;李小红&#39;,--&gt; &lt;!-- age: &#39;30&#39;,--&gt; &lt;!-- address:&#39;123&#39;,--&gt; &lt;!-- $isEdit: false--&gt; &lt;!-- &#125;,--&gt; &lt;!-- &#123;--&gt; &lt;!-- name: &#39;周小伟&#39;,--&gt; &lt;!-- age: &#39;26&#39;,--&gt; &lt;!-- $isEdit: false,--&gt; &lt;!-- address:&#39;123&#39;--&gt; &lt;!-- &#125;--&gt; &lt;!-- ],--&gt; &lt;!-- data4: [--&gt; &lt;!-- &#123;--&gt; &lt;!-- name: &#39;王小明&#39;,--&gt; &lt;!-- age: &#39;18&#39;,--&gt; &lt;!-- address:&#39;123&#39;,--&gt; &lt;!-- $isEdit: false--&gt; &lt;!-- &#125;,--&gt; &lt;!-- &#123;--&gt; &lt;!-- name: &#39;张小刚&#39;,--&gt; &lt;!-- age: &#39;25&#39;,--&gt; &lt;!-- address:&#39;123&#39;,--&gt; &lt;!-- $isEdit: false--&gt; &lt;!-- &#125;,--&gt; &lt;!-- &#123;--&gt; &lt;!-- name: &#39;李小红&#39;,--&gt; &lt;!-- age: &#39;30&#39;,--&gt; &lt;!-- address:&#39;123&#39;,--&gt; &lt;!-- $isEdit: false--&gt; &lt;!-- &#125;,--&gt; &lt;!-- &#123;--&gt; &lt;!-- name: &#39;周小伟&#39;,--&gt; &lt;!-- age: &#39;26&#39;,--&gt; &lt;!-- $isEdit: false,--&gt; &lt;!-- address:&#39;123&#39;--&gt; &lt;!-- &#125;--&gt; &lt;!-- ],--&gt; &lt;!-- blur:true,--&gt; &lt;!-- lastIndex:-1,--&gt; &lt;!-- firstClick:true--&gt; &lt;!-- &#125;--&gt; &lt;!-- &#125;,--&gt; &lt;!-- methods: &#123;--&gt; &lt;!-- handleEdit (row) &#123;--&gt; &lt;!-- this.$set(row, &#39;$isEdit&#39;, true)--&gt; &lt;!-- &#125;,--&gt; &lt;!-- handleSave (row) &#123;--&gt; &lt;!-- this.$set(row, &#39;$isEdit&#39;, false)--&gt; &lt;!-- &#125;--&gt; &lt;!-- &#125;--&gt; &lt;!--&#125;--&gt; &lt;!--&lt;&#x2F;script&gt;--&gt;","permalink":"https://codermino.github.io/2020/09/13/iview%E5%8F%AF%E7%BC%96%E8%BE%91%E8%A1%A8%E6%A0%BC/","photos":[]},{"tags":[{"name":"better-scroll的使用","slug":"better-scroll的使用","permalink":"https://codermino.github.io/tags/better-scroll%E7%9A%84%E4%BD%BF%E7%94%A8/"}],"title":"better-scroll的使用","date":"2020/09/06","text":"滚动原理 绿色部分为 wrapper，也就是父容器，它会有固定的高度。 黄色部分为 content，它是父容器的第一个子元素，它的高度会随着内容的大小而撑高。 那么，当 content 的高度不超过父容器的高度，是不能滚动的，而它一旦超过了父容器的高度， 我们就可以滚动内容区了。横向滚动的原理一致就是将固定高度改为固定宽度。（这里就不啰嗦了） 纵向滚动&lt;template&gt; &lt;div class&#x3D;&quot;wrapper&quot; ref&#x3D;&quot;wrapper&quot;&gt; &lt;ul&gt; &lt;li v-for&#x3D;&quot;item in 8&quot;&gt;&#123;&#123;item&#125;&#125;&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; import BScroll from &#39;better-scroll&#39;; export default &#123; mounted() &#123; this.$nextTick(() &#x3D;&gt; &#123; this.scroll &#x3D; new BScroll(this.$refs.wrapper); &#125;); &#125; &#125;; &lt;&#x2F;script&gt; &lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt; .wrapper&#123; overflow:hidden; height:100vh; &#125; ul li&#123; height:400px; &#125; &lt;&#x2F;style&gt; 这是一个Vue BetterScroll纵向滚动demo,这里需要注意的有两点。 只能有一层父级div，也就是容器 父级div要设置溢出隐藏，并且固定高度 横向滚动横向滚动，相比纵向滚动需要动态的去获取滚动区的宽度，直接上代码。 &lt;template&gt; &lt;div class&#x3D;&quot;tab&quot; ref&#x3D;&quot;tab&quot;&gt; &lt;ul class&#x3D;&quot;tab_content&quot; ref&#x3D;&quot;tabWrapper&quot;&gt; &lt;li class&#x3D;&quot;tab_item&quot; v-for&#x3D;&quot;item in itemList&quot; ref&#x3D;&quot;tabitem&quot;&gt; &#123;&#123;item.title&#125;&#125; &lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; import BScroll from &#39;better-scroll&#39;; export default &#123; data() &#123; return&#123; itemList:[ &#123; &#39;title&#39;:&#39;关注&#39; &#125;, &#123; &#39;title&#39;:&#39;推荐&#39; &#125;, &#123; &#39;title&#39;:&#39;深圳&#39; &#125;, &#123; &#39;title&#39;:&#39;视频&#39; &#125;, &#123; &#39;title&#39;:&#39;音乐&#39; &#125;, &#123; &#39;title&#39;:&#39;热点&#39; &#125;, &#123; &#39;title&#39;:&#39;新时代&#39; &#125;, &#123; &#39;title&#39;:&#39;娱乐&#39; &#125;, &#123; &#39;title&#39;:&#39;头条号&#39; &#125;, &#123; &#39;title&#39;:&#39;问答&#39; &#125;, &#123; &#39;title&#39;:&#39;图片&#39; &#125;, &#123; &#39;title&#39;:&#39;科技&#39; &#125;, &#123; &#39;title&#39;:&#39;体育&#39; &#125;, &#123; &#39;title&#39;:&#39;财经&#39; &#125;, &#123; &#39;title&#39;:&#39;军事&#39; &#125;, &#123; &#39;title&#39;:&#39;国际&#39; &#125; ] &#125; &#125;, created() &#123; this.$nextTick(() &#x3D;&gt; &#123; this.InitTabScroll(); &#125;); &#125;, methods:&#123; InitTabScroll()&#123; let width&#x3D;0 for (let i &#x3D; 0; i &lt;this.itemList.length; i++) &#123; width+&#x3D;this.$refs.tabitem[0].getBoundingClientRect().width; &#x2F;&#x2F;getBoundingClientRect() 返回元素的大小及其相对于视口的位置 &#125; this.$refs.tabWrapper.style.width&#x3D;width+&#39;px&#39; this.$nextTick(()&#x3D;&gt;&#123; if (!this.scroll) &#123; this.scroll&#x3D;new BScroll(this.$refs.tab, &#123; startX:0, click:true, scrollX:true, scrollY:false, eventPassthrough:&#39;vertical&#39; &#125;); &#125;else&#123; this.scroll.refresh() &#125; &#125;); &#125; &#125; &#125;; &lt;&#x2F;script&gt; &lt;style lang&#x3D;&quot;scss&quot; scoped&gt; .tab&#123; width: 100vw; overflow: hidden; padding:5px; .tab_content&#123; line-height: 2rem; display: flex; .tab_item&#123; flex: 0 0 60px; width:60px; &#125; &#125; &#125; &lt;&#x2F;style&gt; 横向滚动需要注意。 只能有一层父级div，也就是容器 父容器要设置溢出隐藏并固定宽度 动态获取滚动区的宽度 无法滚动的原因一、 DOM层级关系 &lt;div class&#x3D;&quot;wrapper&quot;&gt; &lt;div class&#x3D;&quot;content&quot;&gt; content... &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; wrapper里面不能存在多个同级div，如果你这样写： &lt;div class&#x3D;&quot;classifyTitle&quot; ref&#x3D;&quot;wrapper&quot;&gt; &lt;div class&#x3D;&quot;&quot;&gt; ss &lt;&#x2F;div&gt; &lt;ul&gt; &lt;li v-for&#x3D;&quot;(item,index) in classifyData.products&quot;&gt; &lt;router-link :to&#x3D;&quot;&#123;name:&#39;详情&#39;&#125;&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;&#x2F;router-link&gt; &lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;&#x2F;div&gt; 那么ul中的元素将不能滚动 二、content是否被成功添加滚动相关style &lt;div class&#x3D;&quot;classifyTitle&quot; ref&#x3D;&quot;wrapper&quot;&gt; &lt;ul&gt; &lt;li v-for&#x3D;&quot;(item,index) in classifyData.products&quot;&gt; &lt;router-link :to&#x3D;&quot;&#123;name:&#39;详情&#39;&#125;&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;&#x2F;router-link&gt; &lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;&#x2F;div&gt; 审查元素可以看到：这样即添加成功的 三、wrapper 与 content 高度问题只有content的高度大于wrapper高度时候，才可以滚动。如何看？ this.$nextTick(() &#x3D;&gt; &#123; if (!this.scroll) &#123; this.scroll &#x3D; new BScroll(this.$refs.wrapper, &#123;&#125;) console.log(this.scroll) &#125; &#125;) F12就可以看到打印结果： 以上就是可以滚动的情况，wrapperHeight(616) &lt; scrollHeight(750)，hasVerticalScroll为true； 那如果这些数据不对，检查是否dom没有更新完就初始化BScroll了，要等dom更新完才能初始化 四、wrapper样式.wrapper元素上要给定位 position: absolute; left: 0; top: 0; overflow: hidden; 封装better-scroll&lt;template&gt; &lt;div ref&#x3D;&quot;wrapper&quot; :class&#x3D;&quot;&#123;wrapper:hasClass,wrapper2:!hasClass&#125;&quot;&gt; &lt;div class&#x3D;&quot;content&quot;&gt; &lt;slot&gt;&lt;&#x2F;slot&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; import BScroll from &#39;better-scroll&#39; export default &#123; name: &quot;Scroll&quot;, props:&#123; &#x2F;&#x2F; 当默认值是一个对象或者是数组的时候，default必须是一个函数 probeType:&#123; type:Number, default:0 &#125;, pullUpLoad:&#123; type:Boolean, default:false &#125;, hasClass:&#123; type:Boolean, default:false &#125; &#125;, data()&#123; return&#123; scroll:null &#125; &#125;, mounted() &#123; this.$nextTick(()&#x3D;&gt;&#123; this.scroll&#x3D;new BScroll(this.$refs.wrapper,&#123; click:true, probeType:this.probeType, pullUpLoad:this.pullUpLoad &#125;); &#x2F;&#x2F; console.log(this.scroll); &#x2F;&#x2F; new BScroll().on() &#x2F;&#x2F; 监听滚动事件 if(this.probeType&#x3D;&#x3D;&#x3D;2||this.probeType&#x3D;&#x3D;&#x3D;3)&#123; this.scroll.on(&#39;scroll&#39;,(position)&#x3D;&gt;&#123; &#x2F;&#x2F; console.log(position); &#x2F;&#x2F; 将scroll滚动的位置传递出去，因为真正使用的地方不是在这个组件中使用 this.$emit(&#39;scroll&#39;,position); &#125;); &#125; &#x2F;&#x2F; 监听上拉事件 if(this.pullUpLoad)&#123; this.scroll.on(&#39;pullingUp&#39;,()&#x3D;&gt;&#123; &#x2F;&#x2F; console.log(&#39;上拉&#39;); this.$emit(&#39;pullingUp&#39;); &#125;) &#125; &#125;) &#125;, methods:&#123; scrollTo(x,y,time&#x3D;300)&#123; this.scroll&amp;&amp;this.scroll.scrollTo(x,y,time); &#125;, finishPullUp()&#123; this.scroll&amp;&amp;this.scroll.finishPullUp(); &#125;, refresh()&#123; &#x2F;&#x2F; console.log(&#39;图片加载&#39;); this.scroll&amp;&amp;this.scroll.refresh(); &#125;, getScrollY()&#123; &#x2F;&#x2F; return this.scroll&amp;&amp;this.scroll.y; return this.scroll?this.scroll.y:0; &#125; &#125; &#125; &lt;&#x2F;script&gt; &#x2F;&#x2F;一定要给wrapper一个滚动区域的高度并且overflow:hidden &lt;style scoped lang&#x3D;&quot;scss&quot;&gt; .wrapper&#123; width: 100%; overflow: hidden; margin-top: 44px+35px; height: calc(100vh - 44px - 40px); &#125; .wrapper2&#123; width: 100%; overflow: hidden; margin-top: 44px; height: calc(100vh - 44px); &#125; &lt;&#x2F;style&gt; Demo1&lt;!-- 内容区域--&gt; &lt;scroll ref&#x3D;&quot;scroll&quot; :probe-type&#x3D;&quot;3&quot; :pull-up-load&#x3D;&quot;true&quot; @scroll&#x3D;&quot;contentScroll&quot; @pullingUp&#x3D;&quot;loadMore&quot; :hasClass&#x3D;&quot;true&quot;&gt; &lt;content-com :datalist&#x3D;&quot;datalist&quot;&gt;&lt;&#x2F;content-com&gt; &lt;&#x2F;scroll&gt; &#x2F;&#x2F;相关methods loadMore()&#123; debounce(() &#x3D;&gt; &#123; this.addData(); &#125;,1000); &#125;, addData() &#123; this.showMask &#x3D; true; this.urlTime -&#x3D; 86400; this.getData(); this.$nextTick(()&#x3D;&gt;&#123; setTimeout(()&#x3D;&gt;&#123; this.showMask &#x3D; false; &#125;,2000); this.$refs.scroll.finishPullUp(); &#125;) &#125;, contentScroll(position)&#123; &#x2F;&#x2F; 1.判断backTop是否显示 this.isShowBackTop&#x3D; (-position.y)&gt;1000; &#125;, &#x2F;&#x2F;contentCom组件内容 &lt;template&gt; &lt;div class&#x3D;&quot;container&quot;&gt; &lt;div class&#x3D;&quot;u-f-ajc&quot; v-for&#x3D;&quot;(item,index) in datalist&quot; :key&#x3D;&quot;index&quot; style&#x3D;&quot;border-bottom: 1px solid #ccc;padding: 5px 0&quot;&gt; &lt;div class&#x3D;&quot;left u-f2&quot;&gt; &lt;img class&#x3D;&quot;u-f-noshrink&quot; :src&#x3D;&quot;item.thumb&quot; alt&#x3D;&quot;&quot; style&#x3D;&quot;height: 50px;width: 100%;margin-left: 3px&quot;&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;right&quot; style&#x3D;&quot;margin-left: 5px;flex: 7;&quot; @click&#x3D;&quot;toDetail(item)&quot;&gt; &lt;div class&#x3D;&quot;right-top&quot; style&#x3D;&quot;padding-bottom: 10px;font-weight: 700;font-size: 17px;&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;right-bottom u-f u-f-liangduan&quot; style&#x3D;&quot;font-size: 13px;color: #bcbcbc;&quot;&gt; &lt;div class&#x3D;&quot;time u-f-ajc&quot;&gt; &#123;&#123;item.ctime|timeFormat&#125;&#125; &lt;div v-limit&#x3D;&quot;3&quot; v-for&#x3D;&quot;(item2,index2) in item.labels_show&quot; :key&#x3D;&quot;index2&quot; style&#x3D;&quot;padding-left: 3px&quot;&gt;&#123;&#123;item2&#125;&#125;&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;icon&quot; style&#x3D;&quot;font-size: 13px;color: #bcbcbc;padding-right: 10px&quot;&gt; &gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default &#123; name: &quot;contentCom&quot;, props: &#123; datalist: &#123; type: Array, default: [] &#125;, &#125;, methods: &#123; toDetail(item) &#123; this.$router.push(&#123; name: &#39;detail&#39;, params: &#123; item &#125; &#125;) &#125; &#125;, &#125; &lt;&#x2F;script&gt; Demo2&#x2F;&#x2F;滚动内容区域 &lt;scroll ref&#x3D;&quot;scroll&quot; :probe-type&#x3D;&quot;3&quot; :pull-up-load&#x3D;&quot;true&quot;&gt; &lt;div class&#x3D;&quot;container&quot; style&#x3D;&quot;padding: 0 3%;&quot;&gt; &lt;div class&#x3D;&quot;content&quot; v-if&#x3D;&quot;hot_list.length&amp;&amp;cmntlist.length&quot;&gt; &lt;detail-content :item&#x3D;&quot;item&quot;&gt;&lt;&#x2F;detail-content&gt; &lt;&#x2F;div&gt; &lt;comment :cmntlist&#x3D;&quot;hot_list&quot; title&#x3D;&quot;最热评论&quot; v-if&#x3D;&quot;hot_list.length&amp;&amp;cmntlist.length&quot;&gt;&lt;&#x2F;comment&gt; &lt;comment :cmntlist&#x3D;&quot;cmntlist&quot; title&#x3D;&quot;最新评论&quot; v-if&#x3D;&quot;hot_list.length&amp;&amp;cmntlist.length&quot;&gt;&lt;&#x2F;comment&gt; &lt;&#x2F;div&gt; &lt;&#x2F;scroll&gt; &#x2F;&#x2F;在组件中有图片，如果图片没有加载完，那么图片加载之后将会有部分内容区域无法滚动 &lt;template v-if&#x3D;&quot;item.thumbs&quot;&gt; &lt;img :src&#x3D;&quot;item.thumbs[0]&quot; alt&#x3D;&quot;&quot; class&#x3D;&quot;u-f-jc&quot; style&#x3D;&quot;width: 100%;padding-bottom: 10px&quot; @load&#x3D;&quot;imgLoad&quot;&gt; &lt;&#x2F;template&gt; &#x2F;&#x2F;添加@load方法 methods: &#123; imgLoad() &#123; this.$parent.scroll.refresh(); &#125; &#125;,","permalink":"https://codermino.github.io/2020/09/06/better-scroll%E7%9A%84%E4%BD%BF%E7%94%A8/","photos":[]},{"tags":[{"name":"vue自定义属性","slug":"vue自定义属性","permalink":"https://codermino.github.io/tags/vue%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7/"}],"title":"vue自定义属性","date":"2020/09/04","text":"标签元素&lt;div id&#x3D;&quot;test&quot;&gt; &lt;button :data-num&#x3D;&quot;num&quot; ref&#x3D;&quot;dataNum&quot; @click&#x3D;&quot;getsum($event)&quot;&gt;点我&lt;&#x2F;button&gt; &lt;&#x2F;div&gt; js部分data()&#123; return&#123; num : 100 &#125; &#125;, methods: &#123; &#x2F;&#x2F;获取 getsum: function(e) &#123; console.log(e); &#x2F;&#x2F; 自定义属性绑定的元素 console.log(e.target); &#x2F;&#x2F; 自定义元素绑定的元素的dataset console.log(e.target.dataset); console.log(e.target.dataset.num); &#x2F;&#x2F;方法一：操作DOM console.log(this.$refs.dataNum.dataset.num); &#x2F;&#x2F;100 &#x2F;&#x2F;方法二：通过e.target.getAttribute console.log(e.target.getAttribute(&#39;data-num&#39;));&#x2F;&#x2F;100 &#125; &#125;","permalink":"https://codermino.github.io/2020/09/04/vue%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7/","photos":[]},{"tags":[{"name":"vue自定义指令","slug":"vue自定义指令","permalink":"https://codermino.github.io/tags/vue%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/"}],"title":"vue自定义指令","date":"2020/09/03","text":"注册自定义指令Vue自定义指令和组件一样存在着全局注册和局部注册两种方式。 先来看看注册全局指令的方式，通过 Vue.directive( id, [definition] ) 方式注册全局指令， 第一个参数为自定义指令名称（指令名称不需要加 v- 前缀，默认是自动加上前缀的，使用指令的时候一定要加上前缀）， 第二个参数可以是对象数据，也可以是一个指令函数。 &lt;div id&#x3D;&quot;app&quot; class&#x3D;&quot;demo&quot;&gt; &lt;!-- 全局注册 --&gt; &lt;input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;我是全局自定义指令&quot; v-focus&gt; &lt;&#x2F;div&gt; &lt;script&gt; Vue.directive(&quot;focus&quot;, &#123; inserted: function(el)&#123; el.focus(); &#125; &#125;) new Vue(&#123; el: &quot;#app&quot; &#125;) &lt;&#x2F;script&gt; 这个简单案例当中，我们通过注册一个 v-focus 指令，实现了在页面加载完成之后自动让输入框获取到焦点的小功能。其中 inserted 是自定义指令的钩子函数，后面的内容会详细讲解。 全局注册好了，那么再来看看如何注册局部自定义指令，通过在Vue实例中添加 directives 对象数据注册局部自定义指令。 &lt;div id&#x3D;&quot;app&quot; class&#x3D;&quot;demo&quot;&gt; &lt;!-- 局部注册 --&gt; &lt;input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;我是局部自定义指令&quot; v-focus2&gt; &lt;&#x2F;div&gt; &lt;script&gt; new Vue(&#123; el: &quot;#app&quot;, directives: &#123; focus2: &#123; inserted: function(el)&#123; el.focus(); &#125; &#125; &#125; &#125;) &lt;&#x2F;script&gt; 钩子函数一个指令定义对象可以提供如下几个钩子函数 (均为可选)： bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置 inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。 update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变， 也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 。 componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。 unbind：只调用一次，指令与元素解绑时调用。 假设这样的看一个场景：当你在阅览某网站的图片时，可能会由于图片资源比较大而加载缓慢，需要消耗一小段时间来呈现到眼前，这个体验肯定是不太友好的（就像网站切换页面，有时候会加载资源比较慢，为了给用户较好的体验，一般都会先出一个正在加载的友好提示页面），所以这个案例的功能就是在图片资源还没加载出来时，先显示默认背景图，当图片资源真正加载出来了之后，再把真实图片放置到对应的位置上并显示出来。 &lt;div id&#x3D;&quot;app2&quot; class&#x3D;&quot;demo&quot;&gt; &lt;div v-for&#x3D;&quot;item in imageList&quot;&gt; &lt;img src&#x3D;&quot;..&#x2F;assets&#x2F;image&#x2F;bg.png&quot; alt&#x3D;&quot;默认图&quot; v-image&#x3D;&quot;item.url&quot;&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;script&gt; Vue.directive(&quot;image&quot;, &#123; inserted: function(el, binding) &#123; &#x2F;&#x2F;为了真实体现效果，用了延时操作 setTimeout(function()&#123; el.setAttribute(&quot;src&quot;, binding.value); &#125;, Math.random() * 1200) &#125; &#125;) new Vue(&#123; el: &quot;#app2&quot;, data: &#123; imageList: [ &#123; url: &quot;http:&#x2F;&#x2F;consumer-img.huawei.com&#x2F;content&#x2F;dam&#x2F;huawei-cbg-site&#x2F;greate-china&#x2F;cn&#x2F;mkt&#x2F;homepage&#x2F;section4&#x2F;home-s4-p10-plus.jpg&quot; &#125;, &#123; url: &quot;http:&#x2F;&#x2F;consumer-img.huawei.com&#x2F;content&#x2F;dam&#x2F;huawei-cbg-site&#x2F;greate-china&#x2F;cn&#x2F;mkt&#x2F;homepage&#x2F;section4&#x2F;home-s4-watch2-pro-banner.jpg&quot; &#125;, &#123; url: &quot;http:&#x2F;&#x2F;consumer-img.huawei.com&#x2F;content&#x2F;dam&#x2F;huawei-cbg-site&#x2F;en&#x2F;mkt&#x2F;homepage&#x2F;section4&#x2F;home-s4-matebook-x.jpg&quot; &#125; ] &#125; &#125;) &lt;&#x2F;script&gt; 钩子区别update 和 componentUpdated 共同点：组件更新都会调用，update在componentUpdated之前 不同点： update 组件更新前的状态 componentUpdated 组件更新后的状态 场景：点击事件，div的内容追加 ！； update(el, binding,vnode,oldVnode)&#123; console.log(el.innerHTML); &#x2F;&#x2F; &lt;div&gt;！&lt;&#x2F;div&gt; &#125; componentUpdated(el, binding,vnode,oldVnode)&#123; console.log(el.innerHTML); &#x2F;&#x2F; &#x2F;&#x2F;&lt;div&gt;！！&lt;&#x2F;div&gt; &#125; &#x2F;&#x2F; 注意： 区别是div里面的！数量 bind 和 inserted 共同点： dom插入都会调用，bind在inserted之前 不同点： bind 时父节点为 null inserted 时父节点存在。 bind是在dom树绘制前调用，inserted在dom树绘制后调用 bind: function (el) &#123; console.log(el.parentNode) &#x2F;&#x2F; null console.log(&#39;bind&#39;) &#125;, inserted: function (el) &#123; console.log(el.parentNode) &#x2F;&#x2F; &lt;div class&#x3D;&quot;directive-box&quot;&gt;...&lt;&#x2F;div&gt; console.log(&#39;inserted&#39;) &#125; Demo&lt;template&gt; &lt;div&gt; 首页 &lt;input v-for&#x3D;&quot;item in list&quot; :key&#x3D;&quot;item&quot; v-test&#x3D;&quot;item&quot; type&#x3D;&quot;text&quot;&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default &#123; name:&#39;demo&#39;, data() &#123; return &#123; list:[1,2] &#125; &#125;, mounted()&#123; setTimeout(()&#x3D;&gt;&#123; console.log(&#39;-----------------------------------splice的分割线------------------------------------------&#39;) this.list.splice(1,1) &#125;,2000) setTimeout(()&#x3D;&gt;&#123; console.log(&#39;----------------------------------------push的分割线---------------------------------------------&#39;) this.list.push(2) &#125;,3000) &#125;, directives:&#123; test:&#123; &#x2F;&#x2F; 只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 bind(el,bingding,vnode,oldVnode)&#123; console.log(&#39;bing&#39;,el,bingding,vnode,oldVnode) &#125;, &#x2F;&#x2F; inserted 被绑定元素插入父节点时调用（仅保证父节点存在，但不一定已被插入文档中） inserted(el,bingding,vnode,oldVnode)&#123; console.log(&#39;inserted&#39;,el,bingding,vnode,oldVnode) &#125;, &#x2F;&#x2F; update 所在组件的VNode更新时调用，但是可能发生在其子VNode更新之前。指令的值可能发生了改变，也可能没有。 update(el,bingding,vnode,oldVnode)&#123; console.log(&#39;update&#39;,el,bingding,vnode,oldVnode) &#125;, &#x2F;&#x2F; 指令所在组件的VNode及其子VNode全部更新后调用 componentUpdated(el,bingding,vnode,oldVnode)&#123; console.log(&#39;componentUpdated&#39;,el,bingding,vnode,oldVnode) &#125;, &#x2F;&#x2F; 只调用一次，指令与元素解绑时调用 unbind(el,bingding,vnode,oldVnode)&#123; console.log(&#39;unbind&#39;,el,bingding,vnode,oldVnode) &#125; &#125; &#125; &#125; &lt;&#x2F;script&gt; tip 注意： 自定义指令的钩子里面没有vue实例，this指向undefined； 总结1 初始化先执行bing钩子函数，被绑定元素插入父节点时调用inserted钩子函数2 节点移除后会执行update和componentUpdate钩子函数，然后执行解绑的钩子函数unbind3 有节点插入会先执行节点的更新和节点更新完毕的钩子函数，然后执行绑定和inserted 钩子函数","permalink":"https://codermino.github.io/2020/09/03/vue%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/","photos":[]},{"tags":[{"name":"vue修改网站标题title的三种方法","slug":"vue修改网站标题title的三种方法","permalink":"https://codermino.github.io/tags/vue%E4%BF%AE%E6%94%B9%E7%BD%91%E7%AB%99%E6%A0%87%E9%A2%98title%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/"}],"title":"vue修改网站标题title的三种方法","date":"2020/09/03","text":"方法一调用Vue.directive() main.js里面添加一个全局指令Vue.directive(&#39;title&#39;, &#123; inserted: function (el, binding) &#123; &#x2F;&#x2F; el是自定义属性绑定的元素 document.title &#x3D; el.dataset.title &#125; &#125;) 调用的组件里面，随便找一个div加入，v-title data-title=”你的标题”&lt;template&gt; &lt;div v-title data-title&#x3D;&quot;标题&quot;&gt; ...... &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; 方法二利用路由的导航守卫beforeEach在每次页面跳转前更改对应的title router中给每个路由加上meta属性&#123; path: &#39;&#x2F;login&#39;, name: &#39;login&#39;, component(resolve) &#123; require([&#39;.&#x2F;views&#x2F;login.vue&#39;], resolve) &#125;, meta: &#123; title: &#39;登录页&#39;, keepAlive: true, &#x2F;&#x2F; 需要被缓存 &#125; &#125; 在main.js里面加上导航守卫router.beforeEach((to, from, next) &#x3D;&gt; &#123; &#x2F;&#x2F;路由发生改变时,触发 window.document.title &#x3D; to.meta.title &#x3D;&#x3D; undefined ? &#39;默认标题&#39; : to.meta.title if (to.meta.requireAuth) &#123; let token &#x3D; Cookies.get(&#39;access_token&#39;); let anonymous &#x3D; Cookies.get(&#39;user_name&#39;); if (token) &#123; next(&#123; path: &#39;&#x2F;login&#39;, query: &#123; redirect: to.fullPath &#125; &#125;) &#125; &#125; next(); &#125;) 方法三使用插件 安装插件 npm install vue-wechat-title –save 引入插件，main.js中importimport VueWechatTitle from &#39;vue-wechat-title&#39; Vue.use(VueWechatTitle) 路由配置文件router.js里面配置的页面标题routers: [&#123; path: &#39;&#x2F;&#39;, name: &#39;index&#39;, component: Index, meta: &#123; title: &#39;title&#39; &#125; &#125;] app.vue里面添加指令v-wechat-title即可 &lt;!-- 任意元素中加 v-wechat-title 指令 建议将标题放在 route 对应meta对象的定义中 --&gt;&lt;div v-wechat-title&#x3D;&quot;$route.meta.title&quot;&gt;&lt;&#x2F;div&gt; &lt;!--或者--&gt; &lt;router-view v-wechat-title&#x3D;&quot;$route.meta.title&quot;&gt;&lt;&#x2F;router-view&gt; &#x2F;&#x2F;来自官方npm页面","permalink":"https://codermino.github.io/2020/09/03/vue%E4%BF%AE%E6%94%B9%E7%BD%91%E7%AB%99%E6%A0%87%E9%A2%98title%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/","photos":[]},{"tags":[{"name":"keepalive的使用","slug":"keepalive的使用","permalink":"https://codermino.github.io/tags/keepalive%E7%9A%84%E4%BD%BF%E7%94%A8/"}],"title":"keepalive的使用","date":"2020/09/03","text":"Vue中keep-alive的深入理解和使用什么是keep-alive?在平常开发中，有部分组件没有必要多次初始化，这时，我们需要将组件进行持久化，使组件的状态维持不变， 在下一次展示时，也不会进行重新初始化组件。 也就是说，kee-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染 。 也就是所谓的组件缓存 基本用法&#x2F;&#x2F;被keep-alive包含的组件会被缓存 &lt;keep-alive&gt; &lt;component &#x2F;&gt; &lt;&#x2F;keep-alive&gt; 被keep-alive包含的组件不会被再次初始化，也就意味着不会重走生命周期函数但是有时候是希望我们缓存的组件可以能够再次进行渲染，这时Vue为我们解决了这个问题被包含在 keep-alive 中创建的组件，会多出两个生命周期的钩子: activated 与 deactivated： activated 当 keep-alive 包含的组件再次渲染的时候触发 deactivated 当 keep-alive 包含的组件销毁的时候触发 keep-alive是一个抽象的组件，缓存的组件不会被mounted,为此提供activated和deactivated钩子函数在2.1.0 版本后keep-alive新加入了两个属性: include(包含的组件缓存生效) 与exclude(排除的组件不缓存，优先级大于include) 。 参数理解keep-alive可以接收3个属性做为参数进行匹配对应的组件进行缓存: include包含的组件(可以为字符串，数组，以及正则表达式,只有匹配的组件会被缓存) exclude排除的组件(以为字符串，数组，以及正则表达式,任何匹配的组件都不会被缓存) max缓存组件的最大值(类型为字符或者数字,可以控制缓存组件的个数) 注：当使用正则表达式或者数组时，一定要使用v-bind代码示例: &#x2F;&#x2F; 只缓存组件name为a或者b的组件 &lt;keep-alive include&#x3D;&quot;a,b&quot;&gt; &lt;component &#x2F;&gt; &lt;&#x2F;keep-alive&gt; &#x2F;&#x2F; 组件name为c的组件不缓存(可以保留它的状态或避免重新渲染) &lt;keep-alive exclude&#x3D;&quot;c&quot;&gt; &lt;component &#x2F;&gt; &lt;&#x2F;keep-alive&gt; &#x2F;&#x2F; 如果同时使用include,exclude,那么exclude优先于include， 下面的例子只缓存a组件 &lt;keep-alive include&#x3D;&quot;a,b&quot; exclude&#x3D;&quot;b&quot;&gt; &lt;component &#x2F;&gt; &lt;&#x2F;keep-alive&gt; &#x2F;&#x2F; 如果缓存的组件超过了max设定的值5，那么将删除第一个缓存的组件 &lt;keep-alive exclude&#x3D;&quot;c&quot; max&#x3D;&quot;5&quot;&gt; &lt;component &#x2F;&gt; &lt;&#x2F;keep-alive&gt; 配合router使用router-view也是一个组件，如果直接被包在keepalive里面，那么所有路径匹配到的视图组件都会被缓存，如下： &lt;keep-alive&gt; &lt;router-view&gt; &lt;!-- 所有路径匹配到的视图组件都会被缓存！ --&gt; &lt;&#x2F;router-view&gt; &lt;&#x2F;keep-alive&gt; 如果只想要router-view里面的某个组件被缓存，怎么办？ 使用 include/exclude 使用 meta 属性 1.使用 include (exclude例子类似) &#x2F;&#x2F;只有路径匹配到的 name 为 a 组件会被缓存 &lt;keep-alive include&#x3D;&quot;a&quot;&gt; &lt;router-view&gt;&lt;&#x2F;router-view&gt; &lt;&#x2F;keep-alive&gt; 2.使用 meta 属性 &#x2F;&#x2F; routes 配置 export default [ &#123; path: &#39;&#x2F;&#39;, name: &#39;home&#39;, component: Home, meta: &#123; keepAlive: true &#x2F;&#x2F; 需要被缓存 &#125; &#125;, &#123; path: &#39;&#x2F;profile&#39;, name: &#39;profile&#39;, component: Profile, meta: &#123; keepAlive: false &#x2F;&#x2F; 不需要被缓存 &#125; &#125; ] &lt;keep-alive&gt; &lt;router-view v-if&#x3D;&quot;$route.meta.keepAlive&quot;&gt; &lt;!-- 这里是会被缓存的视图组件，比如 Home！ --&gt; &lt;&#x2F;router-view&gt; &lt;&#x2F;keep-alive&gt; &lt;router-view v-if&#x3D;&quot;!$route.meta.keepAlive&quot;&gt; &lt;!-- 这里是不会被缓存的视图组件，比如 Profile！ --&gt; &lt;&#x2F;router-view&gt; 防坑指南 keep-alive 先匹配被包含组件的 name 字段，如果 name 不可用，则匹配当前组件 components 配置中的注册名称。 keep-alive 不会在函数式组件中正常工作，因为它们没有缓存实例。 当匹配条件同时在 include 与 exclude 存在时，以 exclude 优先级最高(当前vue 2.4.2 version)。比如：包含于排除同时匹配到了组件A，那组件A不会被缓存。 包含在 keep-alive 中，但符合 exclude ，不会调用activated和 deactivated。","permalink":"https://codermino.github.io/2020/09/03/keepalive%E7%9A%84%E4%BD%BF%E7%94%A8/","photos":[]},{"tags":[{"name":"js传递多个参数","slug":"js传递多个参数","permalink":"https://codermino.github.io/tags/js%E4%BC%A0%E9%80%92%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0/"}],"title":"js传递多个参数","date":"2020/08/25","text":"在es6之前，一半使用arguments作为不定数参数传输的参数获取途径function abc() &#123; let len = arguments.length; for(let j = 0; j &lt;len ; j++) &#123; console.log(arguments[i]); &#125; &#125; abc(1,2,3); 在es6中可以用…来命名不定数参数名，这样比之前版本比可以起一个更有意义的参数名需要注意的是不定参数只能是最后一个参数，且一个函数定义中只能有一个不定参数 function abc1(...vars) &#123; let len = vars.length; for(let j = 0; j &lt;len ; j++) &#123; console.log(vars[i]); &#125; &#125; function abc2(name,...vars) &#123; let len = vars.length; for(let j = 0; j &lt;len ; j++) &#123; console.log(name); console.log(vars[i]); &#125; &#125; abc1(1,2,3); abc2('zhangsan',1,2,3,4);","permalink":"https://codermino.github.io/2020/08/25/js%E4%BC%A0%E9%80%92%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0/","photos":[]},{"tags":[{"name":"Math.max.apply和Math.max的区别","slug":"Math-max-apply和Math-max的区别","permalink":"https://codermino.github.io/tags/Math-max-apply%E5%92%8CMath-max%E7%9A%84%E5%8C%BA%E5%88%AB/"}],"title":"Math.max.apply和Math.max的区别","date":"2020/08/24","text":"Javascript中的Math.max方法可以求出给定参数中最大的数。Math.max('1','2','3.1','3.2') //3.2 Math.min(1,0,-1) //-1 但如果是数组，就不能这样调用了。此时就用到了apply方法： apply 方法 (Function) (JavaScript) //调用函数，并用指定对象替换函数的 this 值，同时用指定数组替换函数的参数。 apply([thisObj[,argArray]]) //thisObj //可选。 要用作 this 对象的对象。 //argArray //可选。 要传递到函数的一组参数。 巧妙地使数组也可以调用Math.max和Math.min。 Math.max.apply(null, ['1','2','3.1','3.2']) // 3.2 Math.min.apply(null, [1,0,-1]) // -1 Math.min.apply(Math, [1,0,-1])","permalink":"https://codermino.github.io/2020/08/24/Math-max-apply%E5%92%8CMath-max%E7%9A%84%E5%8C%BA%E5%88%AB/","photos":[]},{"tags":[{"name":"created和mounted中请求数据区别","slug":"created和mounted中请求数据区别","permalink":"https://codermino.github.io/tags/created%E5%92%8Cmounted%E4%B8%AD%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%88%AB/"}],"title":"created和mounted中请求数据区别","date":"2020/08/24","text":"JavaScript 的 EventLoop 。 vue 生命周期钩子函数中的异步操作会放在事件队列中，也就是说不会在这个钩子函数中执行。 所以在 created 和 mounted 中请求异步数据是一样的，两者都不会立即进行数据更新，所以不会导致虚拟 DOM 的重载， 更不会影响到真实视图。 vue 生命周期钩子函数中异步数据的赋值，是不会在该钩子函数中执行的，而是在一遍流程结束后，才会处理其中的异步操作。 所以本阶段不会触发数据更新，也不会触发虚拟 DOM 重新载入，更不存在找不到 DOM 元素渲染。 例子const app = new Vue(&#123; el: '#app', data: &#123; num: 0 &#125;, async created() &#123; console.log('created') this.num = await this.getData('created') console.log('获取异步数据结束') console.timeEnd('created获取异步数据完成时长') &#125;, beforeMount() &#123; console.log('beforeMounted') &#125;, async mounted() &#123; console.log('mounted') this.num = await this.getData('mounted') console.log('获取异步数据结束') console.timeEnd('mounted获取异步数据完成时长') &#125;, updated() &#123; console.log('updated') &#125;, methods: &#123; // 模拟异步请求 getData(lifecycle) &#123; console.log(`$&#123;lifecycle&#125;开始获取异步数据`) if (lifecycle === 'created') &#123; console.time('created获取异步数据完成时长') &#125; else &#123; console.time('mounted获取异步数据完成时长') &#125; const genRandomNum = (min, max) =&gt; (Math.random() * (max - min + 1) | 0) + min return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve(genRandomNum(100, 3000)) &#125;, 2000) &#125;) &#125; &#125;, &#125;) 以上代码运行结果如下图所示，可以看到，在 created 和 mounted 中请求异步数据， 都不会立即触发数据的更新，并且在这两个生命周期中获取异步数据更新的时长可以说是几乎一致的。 vue 生命周期的钩子函数中的异步操作，都会在一遍流程走完之后，才会进行数据赋值操作，触发 update ， 此外 DOM 的更新也是异步的，监听数据变化时，启动一个队列，进行视图更新。 在 created 或 mounted 钩子函数中请求数据都是可以的。 在 vue ssr 中，vue 的生命周期中没有 mounted 这个钩子函数，所以 ssr 中无法在 mounted 获取异步数据。 宏任务之后是微任务，微任务过后是布局渲染，此时再执行请求后的回调并完成赋值。created 和 mounted 的区别就出现了，这样相比，created 中请求比 mounted 更快一点。 也要考虑业务场景，需要 DOM 触发的请求，放在 created 中去，怎么放都请求不到。","permalink":"https://codermino.github.io/2020/08/24/created%E5%92%8Cmounted%E4%B8%AD%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%88%AB/","photos":[]},{"tags":[{"name":"localstorage和sessionstorage区别","slug":"localstorage和sessionstorage区别","permalink":"https://codermino.github.io/tags/localstorage%E5%92%8Csessionstorage%E5%8C%BA%E5%88%AB/"}],"title":"localstorage和sessionstorage区别","date":"2020/08/24","text":"概述localStorage和sessionStorage一样都是用来存储客户端临时信息的对象。 他们均只能存储字符串类型的对象（虽然规范中可以存储其他原生类型的对象，但是目前为止没有浏览器对其进行实现）。 localStorage生命周期是永久，这意味着除非用户主动在浏览器上清除localStorage信息，否则这些信息将永远存在。 sessionStorage生命周期为当前窗口或标签页，一旦窗口或标签页被永久关闭了，那么所有通过sessionStorage存储的数据也就被清空了。 sessionStoragesessionStorage 是HTML5新增的一个会话存储对象,用于临时保存同一窗口(或标签页)的数据, 在关闭窗口或标签页之后将会删除这些数据。 使用 setItem 存储 value用途：将 value 存储到 key 字段 用法：.setItem( key, value) 代码示例： sessionStorage.setItem(\"key\", \"value\"); localStorage.setItem(\"site\", \"js8.in\"); getItem 获取 value 用途：获取指定 key 本地存储的值 用法： .getItem(key) 代码示例： var value = sessionStorage.getItem(\"key\"); var site = localStorage.getItem(\"site\"); //滚动时保存滚动位置 $(window).scroll(function()&#123; if($(document).scrollTop()!=0)&#123; sessionStorage.setItem(\"offsetTop\", $(window).scrollTop());//保存滚动位置 &#125; &#125;); //onload时，取出并滚动到上次保存位置 window.onload = function() &#123; var _offset = sessionStorage.getItem(\"offsetTop\"); $(document).scrollTop(offsetTop); &#125;; localStorage不同浏览器无法共享localStorage或sessionStorage中的信息。 相同浏览器的不同页面间可以共享相同的 localStorage（页面属于相同域名和端口）， 但是不同页面或标签页间无法共享sessionStorage的信息。这里需要注意的是，页面及标 签页仅指顶级窗口， 如果一个标签页包含多个iframe标签且他们属于同源页面，那么他们之间是可以共享sessionStorage的。 同源的判断规则：www.test.com www.test.com （不同源，因为协议不同） my.test.com（不同源，因为主机名不同） www.test.com:8080（不同源，因为端口不同） localStorage和sessionStorage使用时使用相同的API： localStorage.setItem(\"key\",\"value\"); //以“key”为名称存储一个值“value” localStorage.getItem(\"key\"); //获取名称为“key”的值 枚举localStorage的方法： for(var i=0;i&lt;localStorage.length;i++)&#123; var name = localStorage.key(i); var value = localStorage.getItem(name); &#125; 删除localStorage中存储信息的方法： localStorage.removeItem(\"key\"); //删除名称为“key”的信息。 localStorage.clear(); //清空localStorage中所有信息 例如： localStorage.key = JSON.stringify(&#123;value1:\"value1\"&#125;); localStorage.key.value1='a'; // 无效 这里是无法对实际存储的值产生作用的，下面的写法也不可以： localStorage.getItem(\"key\").value1=\"a\"; localStorage 中的键值对总是以字符串的形式存储。这意味着数值类型、复杂数据类型会自动转化为字符串类型。","permalink":"https://codermino.github.io/2020/08/24/localstorage%E5%92%8Csessionstorage%E5%8C%BA%E5%88%AB/","photos":[]},{"tags":[{"name":"客户端渲染和服务端渲染","slug":"客户端渲染和服务端渲染","permalink":"https://codermino.github.io/tags/%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93/"}],"title":"客户端渲染和服务端渲染","date":"2020/08/21","text":"服务端渲染 vs 客户端渲染服务端渲染服务端在返回 html 之前，在特定的区域，符号里用数据填充，再给客户端，客户端只负责解析 HTML 。 服务端渲染也被称为 fat-server, thin-client 模式 客户端渲染html 仅仅作为静态文件，客户端端在请求时， 服务端不做任何处理，直接以原文件的形式返回给客户端客户端， 然后根据 html 上的 JavaScript，生成 DOM 插入 html。 客户端渲染也被称为 fat-client, thin-server 模式 异同 渲染本质一样，都是字符串拼接，将数据渲染进一些固定格式的html代码中形成最终的html展示在用户页面上。 拼接字符串必然引起性能的消耗。服务端渲染性能消耗在服务端，当用户量比较多时，缓存部分数据以避免过多数据重复渲染。客户端渲染，如当下火热的 spa 框架，Angular、React、Vue，在首次渲染时，大多是将原 html 中的数据标记（如 ）替换。客户端渲染较难的一点是数据更新以后，页面响应式更新时如何节省资源，直接 DOM 的读写，是很消耗性能的。Vue 2.0 + 有 Vnode，进行 diff 后，渲染到页面上。 利弊","permalink":"https://codermino.github.io/2020/08/21/%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93/","photos":[]},{"tags":[{"name":"win10快捷键","slug":"win10快捷键","permalink":"https://codermino.github.io/tags/win10%E5%BF%AB%E6%8D%B7%E9%94%AE/"}],"title":"win10快捷键","date":"2020/08/19","text":"切换窗口：Alt + Tab； 任务视图：Win + Tab(松开键盘界面不会消失)； 创建新的虚拟桌面：Win + Ctrl + D； 关闭当前虚拟桌面：Win + Ctrl + F4 切换虚拟桌面：Win + Ctrl + 左/右； Win快捷键组合快捷键大全(Win7/8以及Win10通用) Win + ←：最大化窗口到左侧的屏幕上 Win + →：最大化窗口到右侧的屏幕上 Win+ ↑：最大化窗口 Win+ ↓：最小化窗口 Win+ SHIFT +↑：垂直拉伸窗口，宽度不变 Win+ SHIFT +↓：垂直缩小窗口，宽度不变 Win+SHIFT+←：将活动窗口移至左侧显示器 Win+SHIFT+→：将活动窗口移至右侧显示器 Win+ Home：最小化所有窗口，第二次键击恢复窗口 Win + R 打开运行对话框 Win + I 快速打开Win10设置 Win+ P：演示设置 Win+ 数字键：打开或切换位于任务栏指定位置的程序 Win+B：光标移至通知区域 Win+Break：显示“系统属性”对话框 Win+D：显示桌面，第二次键击恢复桌面 Win+E：打开我的电脑 Win+G：循环切换侧边栏小工具 Win+L：锁住电脑或切换用户 Win+M：最小化所有窗口 Win+Shift+M：在桌面恢复所有最小化窗口 Win+T：切换任务栏上的程序 Win+Alt+回车：打开Windows媒体中心 Win+U：打开轻松访问中心 Win+F1：打开Windows帮助和支持 Win+N：插件新笔记(OneNote) Win+S：打开屏幕截图工具(OneNote) Win+Q：打开Lync，Windows 8搜索功能移除了该快捷键 Win+A：接受所有来电 (在microsoft Lync中) Win+X：拒绝来电(在microsoft Lync中)，如果Windows移动中心存在，该快捷键不起作用 Win+减号：缩小(放大镜) Win+加号：放大(放大镜) Win+Esc：关闭放大镜 Win+空格键：切换输入语言和键盘布局 Win键 + O 开启或关闭屏幕方向锁定 Win键 + V 在屏幕上的通知中循环切换 Win+，：临时查看桌面 Win+Shift+V：反向切换系统通知信息 Win+回车：打开“讲述人” Win+Shift+.：将应用移至左侧 Win+.：将应用移至右侧 Win+C：打开Charms栏(提供设置、设备、共享和搜索等选项) Win+K：打开连接显示屏 Win+H：打开共享栏 Win+W：打开“设置搜索”应用 Win+F：打开“文件搜索”应用 Win + Ctrl + F 搜索计算机(如果已连接到网络) Win+Z：打开“应用栏” Win+Tab：循环切换应用 Win+Shift+Tab：反向循环切换应用 Win+Ctrl+Tab：循环切换应用，切换时手动选择应用 Win+/：恢复默认输入法 Win+J：显示之前操作的应用 Win+X：快捷菜单 Win + 数字键 “启动锁定到任务栏中的由该数字所表示位置处的程序 Win + Pause 显示“系统属性”对话框 Win + Shift + 加号(+) 打开放大镜并放大桌面 Win + Shift + 减号(-) 打开放大镜并缩小桌面 Win + Shift + 向上键 将窗口拉伸到屏幕的顶部和底部 Win + Shift + 向左键或向右键 将窗口从一个监视器移动到另一个监视器 Win + Page Up 在多监视器设置中将开始屏幕移动至左监视器 Win + Page Down 在多监视器设置中将开始屏幕移动至右监视器 Win + ‘ 当您将应用程序向一侧对齐时，此热键将切换屏幕上应用程序的中心 Win + . 当您将应用程序向一侧对齐时，此热键会将拆分栏移动至右侧 Win + Shift + . 当您将应用程序向一侧对齐时，此热键会将拆分栏移动至左侧 Win+ Shift + 数字 启动锁定到任务栏中的由该数字所表示位置处的程序的新实例 Win+ Ctrl + 数字 切换到锁定到任务栏中的由该数字所表示位置处的程序的最后一个活动窗口 Win+Alt + 数字 打开锁定到任务栏中的由该数字所表示位置处的程序的跳转列表 (Jump List) Win键 +Ctrl + Tab 通过 Aero Flip 3-D 使用箭头键循环切换任务栏上的程序 Win键 +Ctrl + B 切换到在通知区域中显示消息的程序 Alt+F4 关闭当前窗口，如已经没有任何窗口，则弹出关机对话框 Alt+Enter 显示所选项的属性 Alt+空格键 为活动窗口打开快捷方式菜单 Alt+Esc 以项目打开的顺序循环切换项目 Alt+加下划线的字母 显示相应的菜单 Alt+加下划线的字母 执行菜单命令(或其他有下划线的命令)Alt+向上键在 Win资源管理器中查看上一级文 Alt+F 在文件目录窗口时按下：打开快捷菜单 Ctrl+Esc 打开“开始”菜单 Ctrl 加任意箭头键+空格键 选择窗口中或桌面上的多个单个项目 Ctrl+Alt+Tab 使用箭头键在打开的项目之间切换 Ctrl+鼠标滚轮 更改桌面上的图标大小 Ctrl+F4 关闭活动文档(在允许同时打开多个文档的程序中) Ctrl+Alt+Del 快速打开任务管理器 Ctrl+Shift+Esc 打开任务管理器 Ctrl+A 全选 Ctrl+C(或 Ctrl+Insert) 复制选择的项目 Ctrl+X 剪切选择的项目 Ctrl+V(或 Shift+Insert) 粘贴选择的项目 Ctrl+Z 撤消操作 Ctrl+Y 重新执行某项操作 Delete(或 Ctrl+D) 删除所选项目并将其移动到“回收站” Ctrl+向右键 将光标移动到下一个字词的起始处 Ctrl+向左键 将光标移动到上一个字词的起始处 Ctrl+向下键 将光标移动到下一个段落的起始处 Ctrl+向上键 将光标移动到上一个段落的起始处 Shift 加任意箭头键 在窗口中或桌面上选择多个项目，或者在文档中选择文本 Shift+Delete 不先将所选项目移动到“回收站”而直接将其删除 Shift+F10 显示选定项目的快捷菜单 插入 CD 时按住 Shift 阻止 CD 自动播放 左 Alt+Shift 在启用多种输入语言时切换输入语言 Ctrl+Shift 在启用多个键盘布局时切换键盘布局 右或左 Ctrl+Shift 更改从右到左阅读语言的文本阅读方向 F1 显示帮助 F2 重命名选定项目 F3 搜索文件或文件夹 F4 在 Win资源管理器中显示地址栏列表 F5(或 Ctrl+R) 刷新活动窗口 F6 在窗口中或桌面上循环切换屏幕元素 F10 激活活动程序中的菜单栏 F11 最大化或最小化活动窗口","permalink":"https://codermino.github.io/2020/08/19/win10%E5%BF%AB%E6%8D%B7%E9%94%AE/","photos":[]},{"tags":[{"name":"mongoose操作数组","slug":"mongoose操作数组","permalink":"https://codermino.github.io/tags/mongoose%E6%93%8D%E4%BD%9C%E6%95%B0%E7%BB%84/"}],"title":"mongoose操作数组","date":"2020/08/19","text":"简单查询 模糊查询 指定下标查询 精确查询 半精确查询($all) 半精确查询($in) 范围条件查询 数组内嵌文档查询，模糊查询 数组内嵌文档查询，指定下标查询 数组元素操作符$elemMatch 数组元素操作符$size 数组元素操作符$slice，完整 数组元素操作符$slice，正数 数组元素操作符$slice，负数 $占位符 数组单项改变 数组操作符$push 数组操作符$pull 样本数据：[ &#123; className: '1', name: 'a', detail: &#123;age: 20&#125;, region: ['安徽', '宿州'], score: [ 5, 11 ], box: [ &#123;book: '语文', num: 5, status: 2&#125;, &#123;book: '数学', num: 3, status: 0&#125; ] &#125;, &#123; className: '1', name: 'b', detail: &#123;age: 22&#125;, region: ['宿州', '安徽', '灵璧'], score: [ 14, 6 ], box: [ &#123;book: '英语', num: 8, status: 1&#125;, &#123;book: '地理', num: 2, status: 3&#125; ] &#125;, &#123; className: '2', name: 'c', detail: &#123;age: 24&#125;, region: ['江苏', '苏州'], score: [ 18, 12 ], box: [ &#123;book: '语文', num: 10, status: 5&#125;, &#123;book: '政治', num: 12, status: 1&#125; ] &#125; ] 简单查询// 例：返回《region包含‘安徽’的文档》 var condition = &#123;region: '安徽'&#125; dbs.find(condition, 'region name -_id') // 结果 [ &#123; region: [ '安徽', '宿州' ], name: 'a' &#125;, &#123; region: [ '宿州', '安徽', '灵璧' ], name: 'b' &#125; ] 模糊查询// 例：返回《region数组项包含“州”的文档》 var condition = &#123;region: /州/&#125; dbs.find(condition, 'region name -_id') // 结果 [ &#123; region: [ '安徽', '宿州' ], name: 'a' &#125;, &#123; region: [ '宿州', '安徽', '灵璧' ], name: 'b' &#125;, &#123; region: [ '江苏', '苏州' ], name: 'c' &#125; ] 指定下标查询// 例：返回《region数组下标2数据是“灵璧”的文档》 var condition = &#123;'region.2': '灵璧'&#125; dbs.find(condition, 'region name -_id') // 结果 [ &#123; region: [ '宿州', '安徽', '灵璧' ], name: 'b' &#125; ] 精确查询// 例：返回《region和condition一样的文档，顺序也要相同》 var conditionArr = [ '安徽', '宿州' ] dbs.find(&#123;region: conditionArr&#125;) // 结果 [ &#123; region: [ '安徽', '宿州' ], name: 'a' &#125; ] 半精确查询($all)// 例：返回《region包含所有condition项的文档，不关注顺序》 var conditionArr = [ '安徽', '宿州' ] await dbs.find(&#123;region: &#123;$all: conditionArr&#125;&#125;, 'region name -_id') // 结果 [ &#123; region: [ '安徽', '宿州' ], name: 'a' &#125;, &#123; region: [ '宿州', '安徽', '灵璧' ], name: 'b' &#125; ] 半精确查询($in)// 例：返回《region包含condition中任意项，的文档，不关注顺序》 var conditionArr = [ '灵璧', '苏州' ] dbs.find(&#123;region: &#123;$in: conditionArr&#125;&#125;, 'region name -_id') // 结果 [ &#123; region: [ '宿州', '安徽', '灵璧' ], name: 'b' &#125;, &#123; region: [ '江苏', '苏州' ], name: 'c' &#125; ] 范围条件查询// 例：返回《score数组中包含该类元素的文档：大于13且小于20》(有一个数组项满足就会返回) var condition = &#123;score: &#123; $gt: 13, $lt: 20&#125;&#125; dbs.find(condition, 'score name -_id') // 结果 [ &#123; score: [ 14, 6 ], name: 'b' &#125;, &#123; score: [ 18, 12 ], name: 'c' &#125; ] 数组内嵌文档查询，模糊查询// 例：返回《box数组项中的book属性有包含‘语文’》的文档 var condition = &#123;'box.book': '语文'&#125; dbs.find(condition, 'box name -_id') // 结果 [ &#123; name: 'a', box: [ &#123;book: '语文', num: 5, status: 2&#125;, &#123;book: '数学', num: 3, status: 0&#125; ] &#125;, &#123; name: 'c', box: [ &#123;book: '语文', num: 10, status: 5&#125;, &#123;book: '政治', num: 12, status: 1&#125; ] &#125; ] 数组内嵌文档查询，指定下标查询// 例：返回《book数组下标为1的那项值为‘数学’》的文档 var condition = &#123;'box.1.book': '数学'&#125; dbs.find(condition, 'box name -_id') // 结果 [ &#123; name: 'a', box: [ &#123;book: '语文', num: 5, status: 2&#125;, &#123;book: '数学', num: 3, status: 0&#125; ] &#125; ] 数组元素操作符$elemMatch// 例：返回《box数组项中的num属性大于6》的文档 var condition = &#123;'box': &#123;$elemMatch: &#123;num: &#123;$gt: 6&#125;&#125;&#125;&#125; dbs.find(condition, 'box name -_id') // 结果 [ &#123; name: 'b', box: [ &#123;book: '英语', num: 8, status: 1&#125;, &#123;book: '地理', num: 2, status: 3&#125; ] &#125;, &#123; name: 'c', box: [ &#123;book: '语文', num: 10, status: 5&#125;, &#123;book: '政治', num: 12, status: 1&#125; ] &#125; ] 数组元素操作符$size说明：$size不支持指定范围，而是一个具体的值。此外针对$size，没有相关可用的索引来提高性能 // 例：返回《region数组length等于2》的文档 var condition = &#123;region: &#123;$size: 2&#125;&#125; dbs.find(condition, 'region name -_id') // 结果 [ &#123; region: [ '安徽', '宿州' ], name: 'a' &#125;, &#123; region: [ '江苏', '苏州' ], name: 'c' &#125; ] 数组元素操作符$slice，完整// 例如：返回《region数组的 0-2项（包前不包后）》 dbs.find(&#123;name: 'b'&#125;, &#123;region: &#123;$slice: [0, 2]&#125;, name: 1, _id: -1&#125;) // 结果 [ &#123; region: [ '宿州', '安徽' ], _id: '5eaa6041698d9224dc181ab6', name: 'b' &#125; ] 数组元素操作符$slice，正数// 相当于：[0, 2] dbs.find(&#123;name: 'b'&#125;, &#123;region: &#123;$slice: 2&#125;, name: 1, _id: -1&#125;) // 结果 [ &#123; region: [ '宿州', '安徽' ], _id: '5eaa6041698d9224dc181ab6', name: 'b' &#125; ] 数组元素操作符$slice，负数// 相当于[-2, length] dbs.find(&#123;name: 'b'&#125;, &#123;region: &#123;$slice: -2&#125;, name: 1, _id: -1&#125;) // 结果 [ &#123; region: [ '安徽', '灵璧' ], _id: '5eaa6041698d9224dc181ab6', name: 'b' &#125; ] $占位符请记住，位置$操作符充当更新文档查询中第一个匹配的占位符。 // 例如：返回数组中第一个匹配的数组元素值 dbs.find(&#123;score: &#123; $lte: 6&#125;&#125;, &#123;'score.$': 1, name: 1&#125;) // 结果 [ &#123; _id: '5eaa6041698d9224dc181ab3', score: [ 5 ], name: 'a' &#125;, &#123; _id: '5eaa6041698d9224dc181ab6', score: [ 6 ], name: 'b' &#125; ] 数组单项改变// 例如：修改《box.book值为“语文”的那个数组项，将该项的status值改为100》 dbs.updateOne(&#123;'box.book': '语文'&#125;, &#123;'box.$.status': 100&#125;) // 结果 dbs.findOne(&#123;'box.book': '语文'&#125;, &#123;'box': 1, name: 1&#125;) // ---&gt;&gt; &#123; _id: '5eaa6041698d9224dc181ab3', name: 'a', box: [ &#123; _id: '5eaa6041698d9224dc181ab4', book: '语文', num: 5, status: 100 &#125;, &#123; _id: '5eaa6041698d9224dc181ab5', book: '数学', num: 3, status: 0 &#125; ] &#125; 数组操作符$push// 例如：修改，向name为a的文档的region数组尾部添加一项“中国” dbs.updateOne(&#123;name: 'a'&#125;, &#123;$push: &#123;region: '中国'&#125;&#125;) // 结果 dbs.findOne(&#123;name: 'a'&#125;, &#123;region: 1, name: 1&#125;) // ---&gt;&gt; &#123; region: [ '安徽', '宿州', '中国' ], _id: '5eaa6041698d9224dc181ab3', name: 'a' &#125; 数组操作符$pull// 例如：将name为a的文档的region数组中 '安徽' 删除 dbs.updateOne(&#123;name: 'a'&#125;, &#123;$pull: &#123;region: '安徽'&#125;&#125;) // 结果 dbs.findOne(&#123;name: 'a'&#125;, &#123;region: 1, name: 1&#125;) // ---&gt;&gt; &#123; region: [ '宿州', '中国' ], _id: '5eaa6041698d9224dc181ab3', name: 'a' &#125; $占位符详解一、更新数组中的值看如下students文档中的数据： db.students.insert(&#123;_id:NumberInt(1),grades:[NumberInt(80),NumberInt(85),NumberInt(90)]&#125;) db.students.insert(&#123;_id:NumberInt(2),grades:[NumberInt(88),NumberInt(90),NumberInt(92)]&#125;) db.students.insert(&#123;_id:NumberInt(3),grades:[NumberInt(85),NumberInt(100),NumberInt(90)]&#125;) &#123;\"_id\" : 1,\"grades\" : [ 80, 85, 90]&#125; &#123; \"_id\" : 2,\"grades\" : [ 88, 90, 92 ]&#125; &#123;\"_id\" : 3,\"grades\" : [ 85, 100, 90] 将第一个文档中grade字段中值为80更新为82，如果不知道数组中元素的位置，可以使用位置$操作符。匹配到的第一个符合条件的元素请记住，位置$操作符充当更新文档查询中第一个匹配的占位符。 db.students.update(&#123;_id:1, grades:80&#125;,&#123;$set:&#123;'grades.$':NumberInt(82)&#125;&#125;) 二、使用位置操作符$访问数组中嵌套的字段db.collection.update( &#123; &lt;query selector&gt; &#125;, &#123; &lt;update operator&gt;: &#123; \"array.$.field\" : value &#125; &#125; ) 看如下students文档集合中grades的嵌套文档集合 &#123; _id: 4, grades: [ &#123; grade: 80, mean: 75, std: 8 &#125;, &#123; grade: 85, mean: 90, std: 5 &#125;, &#123; grade: 90, mean: 85, std: 3 &#125; ] &#125; 更新集合文档的嵌套文档的grade值为85的文档的std字段的值为6 db.students.update( &#123; _id: 4, \"grades.grade\": 85 &#125;, &#123; $set: &#123; \"grades.$.std\" : 6 &#125; &#125; ) 三、使用多个字段匹配更新嵌入式文档位置操作符$能够更新第一个匹配的数组元素通过$elemMatch()操作符匹配多个内嵌文档的查询条件考虑如下的students集合文档grades字段是一个嵌套字段的文档 &#123; _id: 4, grades: [ &#123; grade: 80, mean: 75, std: 8 &#125;, &#123; grade: 85, mean: 90, std: 5 &#125;, &#123; grade: 90, mean: 85, std: 3 &#125; ] &#125; 如下语句会更新嵌套文档中的std值为6，条件是文档的主键是4，字段grades的嵌套文档字段grade字段值小于等于90mean字段值大于80 db.students.update( &#123; _id: 4, grades: &#123; $elemMatch: &#123; grade: &#123; $lte: 90 &#125;, mean: &#123; $gt: 80 &#125; &#125; &#125; &#125;, &#123; $set: &#123; \"grades.$.std\" : 6 &#125; &#125; ) 上面的操作语句会更新掉第一个匹配的嵌套文档集合，如下： &#123; _id: 4, grades: [ &#123; grade: 80, mean: 75, std: 8 &#125;, &#123; grade: 85, mean: 90, std: 6 &#125;, &#123; grade: 90, mean: 85, std: 3 &#125; ] &#125;","permalink":"https://codermino.github.io/2020/08/19/mongoose%E6%93%8D%E4%BD%9C%E6%95%B0%E7%BB%84/","photos":[]},{"tags":[{"name":"mongoose操作","slug":"mongoose操作","permalink":"https://codermino.github.io/tags/mongoose%E6%93%8D%E4%BD%9C/"}],"title":"mongoose操作","date":"2020/08/19","text":"mongoose是一个在Node中方便操作mongodb数据库的工具。主要形式是以对象安装：npm install mongoose –save 引入Demo1// 连接数据库 const mongoose =require('mongoose'); mongoose.connect('mongodb://localhost/2020',&#123; useNewUrlParser: true,useUnifiedTopology: true,useCreateIndex:true,useFindAndModify:false &#125;); //连接数据库 const db = mongoose.connection;//数据库的连接对象 db.on('error', console.error.bind(console, 'connection error:')); db.once('open', function() &#123; console.log('db ok') &#125;); Demo2// 本例以《连接本地名为myDB的数据库》为例 // 1.无账号密码： const mongoose = require('mongoose');// 引入mongoose模块 // 连接mongodb。填入mongodb所在服务器地址。和path，path代表了数据库名称 mongoose.connect('mongodb://127.0.0.1:27017/myDB', &#123; useNewUrlParser: true, useCreateIndex: true&#125;, function(err) &#123; if(err) &#123;console.log(err);return;&#125; console.log('数据库连接成功'); &#125;); // ---------------------分割线---------------------- // 2.有账号密码： const mongoose = require('mongoose');// 引入mongoose模块 // 连接mongodb。填入mongodb所在服务器地址。和path，path代表了数据库名称 // 并且地址之前使用@分割，@左面填写账号密码。账号密码之间以:隔开 mongoose.connect('mongodb://eggadmin:123456@localhost:27017/myDB', &#123; useNewUrlParser: true, useCreateIndex: true&#125;, function(err) &#123; if(err) &#123;console.log(err);return;&#125; console.log('数据库连接成功'); &#125;); tip 然后在需要的地方引入对应的文件，即可连接成功 定义模式模式决定了：1.数据库中行的字段。2.通过Mongoose的Api存储这些字段时的限制和验证 // 开始 // 1.获取 Schema模式构造函数 const Schema = mongoose.Schema; // 2.定义模式 let schema = new Schema(&#123; title: &#123; type: String,// 存储行之前，会自动将行内title字段转化成String类型 default: 'baidu.com',// 存储行时如果行内不存在title字段。则使用默认值 &#125;, list: &#123; type: Array, default: '', &#125;, &#125;); 根据模式获取模型模型可以对数据库进行《删/改/查》操作。 // 开始 // 1.获取 model模型构造函数 const model = mongoose.model; // model是构造函数。接受三个参数。 // 模式名：&lt;String&gt;任意取，但不可重复 // 模式对象：&lt;Object&gt; 上面定义的模式 // 要操作的集合的名称：&lt;String&gt; 如没有传入此参数。则默认操作《模式名的复数集合》 // 2.获取模型 // 例：不传入第三个参数 let Col_user = new model('Col_user', schema);// 获取集合实例 // 结果：Col_user模型将默认操作《col_users集合》 // -----------------分割线------------------ // 例：传入第三个参数 let Col_user = new model('Col_user', schema, 'abc');// 获取集合实例 // 结果：Col_user模型将默认操作《abc集合》 Demo1const mongoose=require('mongoose'); const fangjiaSchema = new mongoose.Schema(&#123; xiaoqu_name:&#123;type:String&#125;, position:&#123;type:String&#125;, price:&#123;type:Number&#125;, picture:&#123;type:Array,default:[]&#125;, price_type:&#123;type:Number,default:'0'&#125;, price_rate:&#123;type:String, default:'0%'&#125;, floor_area_ratio:&#123;type:String,default:'暂无数据'&#125;, total_hu:&#123;type:String, default:\"暂无数据\"&#125;, greening_rate:&#123;type:String, default:\"暂无数据\"&#125;, property_type:&#123;type:String, default:\"公寓住宅\"&#125;, developer:&#123;type:String, default:\"暂无数据\"&#125;, property_company:&#123;type:String, default:\"暂无数据\"&#125;, creminal_circle:&#123;type:String, default:\"暂无数据\"&#125;, l_time:&#123;type:String,default:Date.now&#125; &#125;); // 将schema 对象转化为数据模型 const Fangjia = mongoose.model('fangjia', fangjiaSchema);//该数据对象和集合关联('集合名',schema对象) module.exports=Fangjia; 增加const newUser = &#123; username, mail, password: hash &#125;; const result = await User.insertMany(newUser); 修改const result = await User.findOneAndUpdate(&#123; $and: [ &#123; username &#125;, &#123; mail &#125; ] &#125;,&#123;password:newpassword&#125;,&#123;new:true&#125;); 删除const result = await Data.findByIdAndDelete(&#123;_id: id&#125;); 查找// find // 接受两个参数(常用的是两个。其实还有一个options。但是基本用不到) // 参数1：query &lt;Object&gt; // 参数2：callback &lt;Function&gt; // 参数1：err &lt;Object&gt; 默认为null，报错时将变成Object // 参数2：docs &lt;Array&gt;装着《所有符合条件的行》的数组 // 例如，这里将查询《abc集合》中name为zs且年龄大于20的所有行,且不返回age字段，并以height排序 Data.find(&#123;name: 'zs', age: &#123;$gt: 20&#125;&#125;, &#123;age:0&#125;, &#123;$sort: &#123;height: -1, _id: -1&#125;&#125;, function(err, docs)&#123; if(err)&#123;console.log(err);return;&#125; console.log(docs, '查询结果的，数组'); &#125;) // ---------------------分割线--------------------- // findOne和find类似。但是只返回符合条件的第一个行。docs仍然是数组 获取符合条件的文档的数量const count = await Data.estimatedDocumentCount(); 修饰符/数据验证// 索引将增加《以该字段》为查询条件的————查询速度 // 1.用作任意类型的修饰符： let UserSchema = mongoose.Schema(&#123; abc: &#123; required: true,// 表示这个数据必须传入 set(params) &#123;// 自定义修饰符set， // ......做一些处理或者判断。 return new_params // 返回出被处理过后的params &#125; &#125;, // 下面三个为索引类型 uid: &#123; unique: true // 为uid字段创建不可以重复的唯一索引，从此以后uid不会出现重复 &#125;, age:&#123; index: true // 为age字段创建普通索引 &#125;, title: &#123; sparse: true // 为title属性创建稀疏索引 &#125; &#125;) // 2.用作String类型的修饰符 let UserSchema = mongoose.Schema(&#123; name: &#123; type: String, // 预定义修饰符，如果增加数据时类型不为String，则转换成String类型 trim: true,// 预定义修饰符，去除值两边空格，此修饰符只作用于type:String类型的数据 lowercase: true,// 预定义修饰符，将值转换为小写，此修饰符只作用于type:String类型的数据 uppercase: true,// 预定义修饰符，将值转换为大写，此修饰符只作用于type:String类型的数据 enum: true,// 枚举类型，要求数据必须满足枚举值 enum:['0','1','2'] match: /正则/, //增加的数据必须符合 match（正则）的规则 maxlength: 20, // 最大长度，length最大20 minlength: 10 // 最小长度，length最小10 &#125; &#125;) // 3.用作Number类型的修饰符： let UserSchema = mongoose.Schema(&#123; age: &#123; max: 110 ,// 用于 Number 类型数据，最大值 min: 1 ,// 用于 Number 类型数据，最小值 &#125; &#125;) // 4.字符串和数字都可以用的 let UserSchema = mongoose.Schema(&#123; equipment: &#123;// 设备信息 type: String,// 必须加这条来指定数据类型，否则报错 enum: ['pc', 'mobile'],// 可取的值。意为：非该数组内包含的值都是不可取的值，都不会通过验证 default: 'mobile' &#125;, &#125;) 操作符// $lt 小于： query = &#123;age: &#123;$lt: 20&#125;&#125; --- age &lt; 20 // $gt 大于： query = &#123;age: &#123;$gt: 20&#125;&#125; --- age &gt; 20 // $eq 等于： query = &#123;age: &#123;$eq: 20&#125;&#125; --- age = 20或者query = &#123;age: 20&#125; // $ne 不等于： query = &#123;age: &#123;$ne: 20&#125;&#125; --- age != 20 // $lte 小于等于 query = &#123;age: &#123;$lte: 20&#125;&#125; --- age &lt;= 20 // $gte 大于等于 query = &#123;age: &#123;$gte: 20&#125;&#125; --- age &gt;= 20 // $or 或 query = &#123;$or: [&#123;name: 'xx'&#125;, &#123;age:&#123;$lt &lt; 20&#125;]&#125; --- (name === 'xx' || age &lt; 20) // 正则 // 例：title中包含服装的 // .find(&#123;title:/服装/) // 例：title中以服装开头 // .find(&#123;title:/^服装/) // $inc 用来操作数字(用来增加指定字段的数量) 在update函数第二个参数中可以这样写，&#123;$inc:&#123;\"price\": +20&#125;&#125; ---- 在原price基础上增加20 // 关于$set操作符------------------------------------------------------------ // $set 在update类函数中，用来声明本次update是更新数据。而不是直接覆盖所有数据 // 例子：MongoDB原生语法：将name是zhangsan的数据的age改为15 // db.集合名.update(&#123;name:'zhangsan'&#125;,&#123;$set:&#123;age:15&#125;&#125;) // 例子：MongoDB原生语法：将name是zhangsan的那整条数据直接替换为&#123;age:15&#125; // db.集合名.update(&#123;name:'zhangsan'&#125;,&#123;age:15&#125;) // 说明：其实Mongoose的update类函数不再需要显式标明$set也可以只更新，不覆盖。写了也不会有影响。 // 但MongoDB必须显示使用$set操作符。否则将直接覆盖 聚合管道(高级查询) $project指定返回的列，也就是指定返回哪些字段 $match指定返回符合条件的字段 $group分组和统计 $limit指定只返回最多多少条数据 $skip跳过多少条数据 $lookup表关联查询 $sort排序，指定以什么字段排序，并指定正反序 细节 // 1. // 如果只有一个操作符，则可以单独使用对象包裹 // 例如： myModel.aggregate(&#123;$project:&#123;_id:false&#125;&#125;) // --------------分割线---------- // 如果多个操作符，则必须必须使用数组包裹 // 例如： myModel.aggregate([&#123;$project:&#123;_id:false&#125;&#125;,&#123;$limit:2&#125;]) // 2. // aggregate参数数组中的管道顺序会影响最终结果 // 3.sort字段的排序，尽量使用双(或以上)字段来排序。否则在分页时很容易会出现重复数据 $project// 指定返回的列，也就是指定返回哪些字段 // 例如：目标：查询order表数据，并且返回的行中字段。只有order_id/name/age三个 let Order = mongoose.model('Order',UserSchema,'order'); Order.aggregate([ &#123;$project:&#123;order_id:1, name: 1, age: 1&#125;&#125; ],function(err,docs)&#123; if(err) &#123;console.log(err);return&#125; console.log(docs);// 返回最终查询到的数据 &#125;) $match// 指定返回符合条件的字段 // 例如：目标：查询order表数据，并且只返回all_price值大于等于90的行 let Order = mongoose.model('Order',UserSchema,'order'); Order.aggregate([ &#123;$match: &#123;\"all_price\": &#123;$gte:90&#125;&#125;&#125; ],function(err,docs)&#123; if(err) &#123;console.log(err);return&#125; console.log(docs);// 返回最终查询到的数据 &#125;) $group// 分组和统计 // 例如：目标：查询order表数据，并以name字段分组，且统计每个组中的age之和 // 样本数据： // &#123; \"name\" : \"a\", \"age\" : 22 &#125; // &#123; \"name\" : \"a\", \"age\" : 22 &#125; // &#123; \"name\" : \"a\", \"age\" : 22 &#125; // &#123; \"name\" : \"b\", \"age\" : 22 &#125; // &#123; \"name\" : \"a\", \"age\" : 22 &#125; // &#123; \"name\" : \"b\", \"age\" : 22 &#125; // &#123; \"name\" : \"c\", \"age\" : 22 &#125; // &#123; \"name\" : \"c\", \"age\" : 22 &#125; // &#123; \"name\" : \"b\", \"age\" : 23 &#125; let Order = mongoose.model('Order',UserSchema,'order'); Oorder.aggregate([ &#123;$group: &#123;_id: \"$name\", my_num: &#123;$sum: \"$age\"&#125;&#125;&#125; ],function(err,docs)&#123; if(err) &#123;console.log(err);return&#125; console.log(docs);// 返回最终查询到的数据 &#125;) // docs返回数据： // &#123; \"_id\" : \"b\", \"my_num\" : 67 &#125; // &#123; \"_id\" : \"c\", \"my_num\" : 44 &#125; // &#123; \"_id\" : \"a\", \"my_num\" : 88 &#125; $limit// 指定只返回最多多少条数据 // 例如：目标：查询order表数据，并最多只返回2条数据 let Order = mongoose.model('Order',UserSchema,'order'); Order.aggregate([ &#123;$limit: 2&#125; ],function(err,docs)&#123; if(err) &#123;console.log(err);return&#125; console.log(docs);// 返回最终查询到的数据 &#125;) $skip// 跳过多少条数据 // 例如：目标：查询order表数据，并跳过前三条数据，只返回除了前三条以外的所有数据。 let Order = mongoose.model('Order',UserSchema,'order'); Order.aggregate([ &#123;$skip: 3&#125; ],function(err,docs)&#123; if(err) &#123;console.log(err);return&#125; console.log(docs);// 返回最终查询到的数据 &#125;) $lookup// 表关联查询 // 例如：将col表和test表关联，以《col表中uid字段》和《test表中ab字段》相关联。将test被关联的行，放到col表的myList数组中 let Col = mongoose.model('Col',UserSchema,'col'); // col表数据： // &#123;name:'zs',age:'20',uid:1&#125; // &#123;name:'li',age:'20',uid:2&#125; // &#123;name:'wa',age:'20',uid:1&#125; // &#123;name:'xh',age:'20',uid:3&#125; // test表数据： // &#123;u:'fd',price:'20',ab:1&#125; // &#123;u:'afd',price:'20',ab:2&#125; // &#123;u:'yt',price:'30',ab:2&#125; // 执行操作 Col.aggregate([ &#123; $lookup: &#123; from: 'test', // 这里意味和test集合关联 localField: 'uid',// 这里意为用col表中的uid字段和test表中的id字段关联。 foreignField: 'ab', as: 'myList' // 这里意为，将返回的最终数据，放在一个数组中。并且给该数组key设置为myList &#125; &#125; ], function(err, docs)&#123; if(err) &#123;console.log(err);return&#125; console.log(docs);// 返回最终查询到的数据 &#125;); // 返回结果，将test表中《ab值》和《col表中uid值》相同的test表数据放到col表的myList数组中 // [ // &#123; // \"_id\": ObjectId(\"5d3c603d8cbf5184d6763b4c\"), // \"name\": \"zs\", // \"age\": \"20\", // \"uid\": 1, // \"myList\": [ // &#123; // \"_id\": ObjectId(\"5d3c62888cbf5184d6763b53\"), // \"u\": \"fd\", // \"price\": \"20\", // \"ab\": 1 // &#125; // ] // &#125;, // &#123; // \"_id\": ObjectId(\"5d3c603d8cbf5184d6763b4d\"), // \"name\": \"li\", // \"age\": \"20\", // \"uid\": 2, // \"myList\": [ // &#123; // \"_id\": ObjectId(\"5d3c62888cbf5184d6763b54\"), // \"u\": \"afd\", // \"price\": \"20\", // \"ab\": 2 // &#125;, // &#123; // \"_id\": ObjectId(\"5d3c62888cbf5184d6763b55\"), // \"u\": \"yt\", // \"price\": \"30\", // \"ab\": 2 // &#125; // ] // &#125;, // &#123; // \"_id\": ObjectId(\"5d3c603d8cbf5184d6763b4e\"), // \"name\": \"wa\", // \"age\": \"20\", // \"uid\": 1, // \"myList\": [ // &#123; // \"_id\": ObjectId(\"5d3c62888cbf5184d6763b53\"), // \"u\": \"fd\", // \"price\": \"20\", // \"ab\": 1 // &#125; // ] // &#125;, // &#123; // \"_id\": ObjectId(\"5d3c603d8cbf5184d6763b4f\"), // \"name\": \"xh\", // \"age\": \"20\", // \"uid\": 3, // \"myList\": [] // &#125; // ] $sort// 排序，指定以什么字段排序，并指定正反序 let Order = mongoose.model('Order',UserSchema,'order'); // 样本数据： // &#123; \"name\" : \"a\", \"age\" : 36 &#125; // &#123; \"name\" : \"b\", \"age\" : 18 &#125; // &#123; \"name\" : \"c\", \"age\" : 22 &#125; // &#123; \"name\" : \"d\", \"age\" : 15 &#125; Order.aggregate([ &#123;$sort: &#123;\"age\": -1, _id: -1&#125;&#125;;// 注意，无论以什么排序，最好用双字段进行排序。防止查询出重复数据 ],function(err,doc)&#123; if(err) &#123;console.log(err);return&#125; console.log(doc);// 返回最终查询到的数据 &#125;); // -1结果是倒序： // &#123; \"name\" : \"a\", \"age\" : 36 &#125; // &#123; \"name\" : \"c\", \"age\" : 22 &#125; // &#123; \"name\" : \"b\", \"age\" : 18 &#125; // &#123; \"name\" : \"d\", \"age\" : 15 &#125; // 1则结果为正序。 小结用aggregate写一个分页 // node中分页接口 async function getList(request, response, next) &#123; let &#123;page = 1, size = 8, category_type = '', condition = ''&#125; = request.body; let reg = new RegExp(condition, 'gi'); let match = &#123;category_type: category_type, $or:[&#123;title: reg&#125;]&#125;; userModel.countDocuments(match, function (err, count) &#123; size = size &gt; 30 ? 30 : parseInt(size); size = size &lt; 8 ? 8 : parseInt(size); let maxPage = Math.ceil(count / size); page = page &gt; maxPage ? maxPage : parseInt(page); page = page - 1; page = page &lt; 0 ? 0 : parseInt(page); // 注意管道顺序，会影响结果 dbs.aggregate([ &#123;$match: match&#125;, &#123;$sort: &#123; href: -1, _id: 1&#125;&#125;, &#123;$project: &#123;href: false&#125;&#125;, &#123;$skip: page * size * 1&#125;, &#123;$limit: size * 1 &#125; ],function(err,doc)&#123; if(err) &#123;console.log(err);return&#125; return response.json(&#123;status: 1, msg: '数据获取成功', data: &#123;page: page+1, size, maxPage, condition, list: doc&#125;&#125;); &#125;); &#125;) &#125; 分页exports.getpagination = async function (req, res) &#123; const pageSize = parseInt(req.query.pageSize) || 5; const currentPage = parseInt(req.query.currentPage) || 1; let keyword =req.query.keyword || ''; let reg=new RegExp(keyword); const sorttype = req.query.sort; let sort = &#123;&#125;; if (sorttype)&#123; const isDesc = sorttype === '升序' ? 1 : -1; sort = &#123;'price':isDesc&#125;; //排序（按价格倒序） &#125; const condition = &#123; $or:[&#123;xiaoqu_name:&#123;$regex:reg&#125;&#125;,&#123;position:&#123;$regex:reg&#125;&#125;,&#123;creminal_circle:&#123;$regex:reg&#125;&#125;] &#125;; const skipnum = (currentPage - 1) * pageSize; //跳过数 const count = await Data.estimatedDocumentCount(); if (sorttype)&#123; const result = await Data.find(condition).skip(skipnum).limit(pageSize).sort(sort).exec(); res.send(&#123;code:200,msg:'查询ok',info:&#123;list:result,count,allpage:Math.ceil(count/pageSize)&#125;&#125;) &#125; else&#123; const result = await Data.find(condition).skip(skipnum).limit(pageSize).sort(&#123;_id:-1&#125;).exec(); res.send(&#123;code:200,msg:'查询ok',info:&#123;list:result,count,allpage:Math.ceil(count/pageSize)&#125;&#125;) &#125; &#125;;","permalink":"https://codermino.github.io/2020/08/19/mongoose%E6%93%8D%E4%BD%9C/","photos":[]},{"tags":[{"name":"scss语法","slug":"scss语法","permalink":"https://codermino.github.io/tags/scss%E8%AF%AD%E6%B3%95/"}],"title":"scss语法","date":"2020/08/19","text":"嵌套/*1.直接嵌套*/ .box &#123; font-size:25px; .per &#123; color:#f60; &#125; &amp;&gt;.abc &#123; background-color: #666; &#125; &#125; /*1结果*/ .box &#123; font-size:25px; &#125; .box .per &#123; color:#f60; &#125; .box&gt;.abc &#123; background-color: #666; &#125; // -----------------------------分割线---------------------- /* 2. 使用font@at-root */ .box &#123; font-size:25px; @at-root&#123; .per &#123; color:#f60; &#125; &amp;&gt;.abc &#123; background-color: #666; &#125; &#125; &#125; // 2结果 .box &#123; font-size:25px; &#125; .per &#123; color:#f60; &#125; .box&gt;.abc &#123; background-color: #666; &#125; 变量关键字(以$开头)： $ 变量名： 自定义 赋值符号： : 变量值： css样式值 // 声明变量 $myFontSize: 50px; // 使用 div &#123; width: $myFontSize; &#125; // 编译结果 div &#123; width: 50px; &#125; 混合宏@mixin关键字： @mixin 名称： 自定义 // 1.不带参数 // 声明一个混合宏@mixin @mixin myBorderRadius&#123; -webkit-border-radius:5px; border-radius:5px; &#125; // 使用 .box &#123; @include myBorderRadisu; &#125; // 1编译结果 .box &#123; -webkit-border-radius:5px; border-radius:5px &#125; // 2. // 声明一个带有参数的宏： @mixin 宏名称($abc,$w,$h)&#123; // ————此处可以设置默认值$abc:5px; -webkit-border-radius:$abc; border-radius:$abc; margin-top: -($h) / 2; // ———— 可以使用运算 margin-left: -($w) / 2; // ———— 可以使用运算 &#125; // 如果参数过多可以使用： ... @mixin box-shadow($shadows...)&#123; @if length($shadows) &gt;= 1 &#123; // —— 如果参数的length大于1 -webkit-box-shadow: $shadows; box-shadow: $shadows; &#125; @else &#123; $shadow: 0 0 2px rgba(#000,.25); -webkit-box-shadow: $shadow; box-shadow: $shadow; &#125; &#125; @extend继承// 例如 .box &#123; color:#f60; &#125; // .per类名继承.box类名 .per &#123; font-size:16px; @extend .box; &#125; // 编译结果 .box,.per &#123; color:#f60; &#125; .per &#123; font-size:16px; &#125; %占位符关键字： % // 声明一个占位符空间 %mt5 &#123; margin-top: 5px; &#125; // 用@extend使用占位符 .btn &#123; font-size:25px; @extend %mt5; &#125; .per &#123; @extend %mt5; &#125; // 编译结果 .btn,.per &#123; margin-top: 5px; &#125; .btn &#123; font-size:25px; &#125; 在vue中使用SCSS在vue中安装： npm install node-sass sass-loader –save-devnpm安装sass时的注意： 1 __ 如果安装过慢。 切换npm源，可大幅度提升速度 npm install -g mirror-config-china --registry=http://registry.npm.taobao.org 2 __如果安装完毕依赖后。项目编译错误。 则将package.json中将sass-loader的版本改为7.3.1，官方解释为版本过高导致的编译错误，并重新npm i \"sass-loader\": \"^7.3.1\", 使用// 将style标签上添加属性 lang=\"scss\" &lt;style lang=\"scss\" scoped&gt; @import \"../../../../static/css/common.scss\"; div &#123; width: 120px; .abc &#123; font-size: 16px; &#125; &#125; &lt;/style&gt; 在webstorm中使用SCSS在webstorm中配置自动编译： 英文版：依次点开 file--&gt;&gt;Settings--&gt;&gt;tool--&gt;&gt;File--Watchers--&gt;&gt;右上角加号--&gt;&gt;scss 中文版：依次点开 文件--&gt;&gt;设置--&gt;&gt;工具--&gt;&gt;File--Watchers--&gt;&gt;右上角加号--&gt;&gt;scss 配置： 更改Programs输入框内容： 改成ruby地址中的bin目录内的scss.bat的路径，如果安装ruby 时没有更改安装路径则默认地址如下： C:\\Ruby26-x64\\bin\\sass.bat 复制本条地址替换 --&gt;&gt;点击应用--&gt;&gt;点击确认 《完成》 下次使用webstorm编写scss文件时。将自动在同级目录下实时生成同名的.css文件","permalink":"https://codermino.github.io/2020/08/19/scss%E8%AF%AD%E6%B3%95/","photos":[]},{"tags":[{"name":"冷门且有用的css","slug":"冷门且有用的css","permalink":"https://codermino.github.io/tags/%E5%86%B7%E9%97%A8%E4%B8%94%E6%9C%89%E7%94%A8%E7%9A%84css/"}],"title":"冷门且有用的css","date":"2020/08/18","text":"多选按钮自定义背景色input[type=checkbox]&#123; box-sizing: border-box; padding: 0; margin: 0; cursor: pointer; position: relative; width: 20px; height: 20px; font-size: 12px; overflow: visible; &amp;:after&#123; box-sizing: border-box; padding: 0; margin: 0; width: calc(100% + 2px); height: calc(100% + 2px); color: transparent; position: absolute; top: calc(50% - 1px); left: calc(50% - 1px); font-size: 12px; line-height: 20px; font-weight: bold; transform: translateX(calc(-50% + 1px)) translateY(calc(-50% + 1px)); background-color: #1F253D; text-align: center; content: \" \"; border-radius: 4px; &#125; &amp;:checked::after&#123; content: \"✓\"; color: #fff; &#125; &#125; 更改“自动联想的input”样式input[type=text], input[type=password], input[type=number] &#123; /* 字体色 */ &amp;:-internal-autofill-previewed, &amp;:-internal-autofill-selected &#123; -webkit-text-fill-color: #fff; &#125; /* 背景色 */ &amp;:-webkit-autofill &#123; box-shadow: 0 0 0px 1000px #2d3a4b inset !important; &#125; &#125; 隐藏，input[type=number]的右面角标input[type='number']&#123; -moz-appearance:textfield; &amp;::-webkit-inner-spin-button, &amp;::-webkit-outer-spin-button &#123; -webkit-appearance: none; margin: 0; &#125; &#125; 设置滚动条样式/* 示例： */ /* 滚动条样式 */ .abc::-webkit-scrollbar &#123; width: 4px; &#125; /* 滑块样式 */ .abc::-webkit-scrollbar-thumb &#123; border-radius: 10px; -webkit-box-shadow: inset 0 0 5px rgba(0,0,0,0.2); background: rgba(0,0,0,0.2); &#125; /* 滑块的轨道样式 */ .abc::-webkit-scrollbar-track &#123; -webkit-box-shadow: inset 0 0 5px rgba(0,0,0,0.2); border-radius: 5px; background: rgba(0,0,0,0.1); &#125; /* ------------------------------------------------------- */ /* 具体含义及其他设置项： */ ::-webkit-scrollbar &#123;&#125; /* 滚动条整体部分 */ ::-webkit-scrollbar-thumb &#123;&#125; /* 滚动条里面的滑块 */ ::-webkit-scrollbar-track &#123;&#125; /* 滑块的轨道 */ ::-webkit-scrollbar-button &#123;&#125; /* 滚动条的轨道的两端按钮 */ /* ------------------------------------------------------- */ /* 他们的关系是: */ // scrollbar包含三个直接子元素： // start-button // track // end-button // track包含一个直接子元素： // thumb /* ------------------------------------------------------- */ /* 使用伪类： */ // scrollbar、track、thumb、button都可以使用:hover和active等伪类 /* 例如： */ .abc::-webkit-scrollbar-thumb:hover &#123; background-color: #fff; &#125; /*-------------------------------------------------------*/ /* 常用设置：*/ /* 滚动条样式, 主要作用 可以设置条的宽度(垂直条的宽度)，高度(水平条高度) */ .abc::-webkit-scrollbar &#123; width: 4px; height: 4px; &#125; /* 只设置垂直滚动条样式，可以轨道的宽度，背景色 */ .abc::-webkit-scrollbar:vertical &#123;&#125; /* 只设置水平滚动条样式，可以轨道的高度，背景色 */ .abc::-webkit-scrollbar:horizontal &#123;&#125; /* 滑块样式 */ .abc::-webkit-scrollbar-thumb &#123;&#125; /* 滑块的轨道条样式，只可以控制背景色圆角之类样式，不可以控制宽高 */ .abc::-webkit-scrollbar-track &#123;&#125; /* 设置条两边按钮样式 */ .abc::-webkit-scrollbar-button &#123;&#125; /* 只设置上/左按钮样式 */ .abc::-webkit-scrollbar-button:start &#123;&#125; /* 只设置下/右按钮样式 */ .abc::-webkit-scrollbar-button:end &#123;&#125; /* ------------------------------------------------------- */","permalink":"https://codermino.github.io/2020/08/18/%E5%86%B7%E9%97%A8%E4%B8%94%E6%9C%89%E7%94%A8%E7%9A%84css/","photos":[]},{"tags":[{"name":"js学习笔记Promise","slug":"js学习笔记Promise","permalink":"https://codermino.github.io/tags/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0Promise/"}],"title":"js学习笔记Promise","date":"2020/08/18","text":"Promise构造函数的基础使用Promise对象可以帮我们监听异步任务(函数)的执行结果。并通过两种标记来通知我们任务的状态 举一个简单的小栗子：目标：我们在做一个登录功能。向服务端发起请求。我们需要服务端给我们响应200(yes)或者非200(no)未知：由于网络因素。无法知道什么时候才可以得到回应。(异步任务)已知：无论是yes还是no 当我们接收到响应时，都必须立刻马上使用alert来给用户反馈结果。 代码：// 将登录任务交给Promise管理。并返回Promise实例 pro var pro = new Promise(function (resolve, reject) &#123; $.ajax(&#123; success: function(res) &#123; if(res.status === 200)&#123; // 调用resolve或reject，会告诉标记任务完成。（标记并不会直接终止后续代码。如下面的console.log(111)仍然会执行） // 标记任务完成。并通知Promise实例立即执行then的第一个回调函数 resolve('yes'); console.log(111); &#125;else &#123; // 标记任务完成。并通知Promise实例立即执行catch的回调函数，或者then的第二个回调函数 reject('no') &#125; &#125;, error: function(err)&#123; // 标记任务完成。并通知Promise实例立即执行catch的回调函数，或者then的第二个回调函数 reject('错误'); &#125; &#125;) &#125;); // pro是Promise实例。它会在任务标记完成时执行then或者catch // 具体执行then还是catch。取决于 是通过resolve标记还是reject标记 var pro2 = pro.then(function (p) &#123; // 如果任务调用了resolve，则执行这里代码 // 形参p接收resolve传来的值 alert('登录成功'); &#125;).catch(function (e) &#123; // 如果任务调用了reject，则执行这里代码 // 形参e接收reject传来的值 alert('登录失败，请重试'); if (e === '错误')&#123; console.log('代码可能写错了。或者网路错误'); &#125; &#125;) // -----------------分割线---------------------- // 实例调用then和catch，也是有返回值的。返回值仍然是一个Promise所构造的对象。所以依然可以调用then // 比如上面我们用pro2接受了这种对象 pro2.then(function()&#123; // 这里的代码仍然会执行。可以理解为回调函数 &#125;);// pro2.then仍然会返回一个Promise对象........... 《《注意！：如果任务调用了reject来标记任务完成。但是实例并没有监听catch。那么代码将会报错》》catch的另一种写法：给then传两个回调函数 pro.then(function () &#123; // 这里，相当于上面的then &#125;, function () &#123; // 这里相当于上面的catch &#125;) Promise构造函数的静态方法 resolve和reject all race resolve和rejectresolve和reject用法一样。这里只拿reject来讲解，他们都是用来直接标记。并返回一个Promise对象 例如： var pro = Promise.reject('一个惊喜'); pro.then(function () &#123; // 由于pro接收到的标记不是resolve，所以这里代码不会执行 &#125;, function (e) &#123; // 由于pro接收到的标记是reject，所以这里会执行 console.log(e === '一个惊喜');// ---&gt;&gt; true &#125;) all // Promise.all接收一个参数：&lt;Array&gt; 这个数组中元素都必须是Promise实例。 // Promise.all会在数组中所有实例都标记了resolve时。并执行then，且then回调的参数是所有resolve所传的值组成的数组 // 如果有任何一个实例标记了reject，则执行catch，且catch回调的参数是reject返回传来的参数。同时不再接受标记(意思是then // 和catch只有一个会执行。且只执行一次) // 简介：必须全部resolve才能执行then。否则执行catch。then回调形参接收数组，该数组是所有resolve值集合。catch是reject传来的值 var pro1 = new Promise(function (res, rej) &#123; setTimeout(function () &#123; if (Math.random() &gt; 0.5)&#123; res(111111); &#125;else &#123; rej(1); &#125; &#125;, 100); &#125;); var pro2 = new Promise(function (res, rej) &#123; setTimeout(function () &#123; if (Math.random() &gt; 0.5)&#123; res(222222); &#125;else &#123; rej(2); &#125; &#125;, 200); &#125;); // 只有接收到标记就开始then或catch。 // 同时不再接收标记(意思是then和catch只有一个会执行。且只执行一次) Promise.all([pro1, pro2]).then(function (data) &#123; console.log('真幸运，你连续两次都中奖了：', data);// [&lt;Number&gt;, &lt;Number&gt;] &#125;).catch(function (e) &#123; console.log('很遗憾，你有至少一次未中奖：', e);// &lt;Number&gt; &#125;) race // Promise.race接收一个参数：&lt;Array&gt; 这个数组中元素都必须是Promise实例。 // Promise.race会接收到第一个标记时执行then或catch。 // 同时不再接受标记(意思是then和catch只有一个会执行。且只执行一次) var pro1 = new Promise(function (res, rej) &#123; setTimeout(function () &#123; if (Math.random() &gt; 0.5)&#123; res(111111); &#125;else &#123; rej(1); &#125; &#125;, 100); &#125;); var pro2 = new Promise(function (res, rej) &#123; setTimeout(function () &#123; if (Math.random() &gt; 0.5)&#123; res(222222); &#125;else &#123; rej(2); &#125; &#125;, 200); &#125;); // 只有接收到标记就开始then或catch。 // 同时不再接收标记(意思是then和catch只有一个会执行。且只执行一次) Promise.race([pro1, pro2]).then(function (data) &#123; console.log('真幸运，你跑的很快。而且中将了：', data); &#125;).catch(function (e) &#123; console.log('虽然你跑的很快，但是并未中奖：', e); &#125;)","permalink":"https://codermino.github.io/2020/08/18/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0Promise/","photos":[]},{"tags":[{"name":"js学习笔记回收机制","slug":"js学习笔记回收机制","permalink":"https://codermino.github.io/tags/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"}],"title":"js学习笔记回收机制","date":"2020/08/18","text":"JS何时回收一个内存满足以下两个条件的《变量》的内存会被回收1.该变量是在局部作用域(函数作用域)内声明，而非全局作用域下声明。2.没有《任何别域下的变量》可以通过间接或直接的方式访问到它。 例1：function f1()&#123; var a = 1; var b = 2 c = 3; return function()&#123; return a &#125; &#125; var x = f1(); // 本次f1执行所产生的执行期上下文中有 // a 变量 // b 变量 // 一个匿名函数function // 在这里f1执行完毕。开始进行垃圾内存检测 // a 可以被 x() 访问到，所以不会被回收 // b没有《任何别域下的变量》可以访问到，会被回收 // 匿名函数function被x访问到。所以不会被回收 // c 相当于在全局window.c上，所以不会被回收 例2：function f1()&#123; var a = 1; return &#123; num: a++ &#125; &#125; var x = f1(); // 本次f1执行所产生的执行期上下文中有 // a 变脸 // 一个对象匿名对象object // a 可以被 x.num 访问到，所以当f1执行完后不会被回收 // 匿名对象被x访问到。所以不会被回收","permalink":"https://codermino.github.io/2020/08/18/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/","photos":[]},{"tags":[{"name":"js学习笔记正则reg","slug":"js学习笔记正则reg","permalink":"https://codermino.github.io/tags/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%AD%A3%E5%88%99reg/"}],"title":"js学习笔记正则reg","date":"2020/08/18","text":"创建正则表达式// 1. 通过构造函数生成。好处是可以支持变量 // 参数1 模式，描述了表达式的模式 // 参数2 修饰符，用于指定全局匹配、区分大小写的匹配和多行匹配 var suffix = 'js'; var reg = new RegExp(`[\\\\w\\\\.]+(?=\\\\.$&#123;suffix&#125;)`, 'igm'); // reg ---&gt;&gt; /[\\w\\.]+(?=\\.js)/gim // 2.字面量，更为简单。但是无法支持变量。 var patt = /[\\w\\.]+(?=\\.js)/gim; // 注意，无论是第一种还是第二种。当需要&lt;模式&gt;匹配&lt;存在特殊含义的字符&gt;时，需要使用转义字符进行转义 var reg1 = new RegExp(\"\\\\w+\"); var reg2 = /\\w+/; // 这里两种得出的表达式等价 修饰符 修饰符 描述 i 执行对大小写不敏感的匹配。 g 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。 m 执行多行匹配。 方括号 修饰符 描述 [abc] 查找方括号之间的任何字符 [^abc] 查找任何不在方括号之间的字符。 [0-9] 查找任何从 0 至 9 的数字。 [a-z] 查找任何从小写 a 到小写 z 的字符。 [A-Z] 查找任何从大写 A 到大写 Z 的字符。 [A-z] 查找任何从大写 A 到小写 z 的字符。 [adgk] 查找给定集合内的任何字符。 [^adgk] 查找给定集合外的任何字符。 (red|blue|green) 查找任何指定的选项。小括号包裹的也叫子表达式，后面在子表达式与$和replace的妙用中会详细讲到 元字符 元字符 描述 . 查找单个字符，除了换行和行结束符。相当于 [^\\r\\n] 只要不包含换行和行结束符。 \\w 查找单词字符。相当于 [0-9A-z_] 。 \\W 查找非单词字符。相当于 [^\\w] 。 \\d 查找数字。相当于 [0-9] 。 \\D 查找非数字字符。相当于 [^\\d] 。 \\s 查找空白字符。相当于 [ \\n\\r\\v\\f ] (注意这里末尾有个空格)。 \\S 查找非空白字符。相当于 [^\\s] 。 \\b 匹配单词边界。 \\B 匹配非单词边界。 \\0 查找 NUL 字符。 \\n 查找换行符。 \\f 查找换页符。 \\r 查找回车符。 查找制表符。 \\v 查找垂直制表符。 \\xxx 查找以八进制数 xxx 规定的字符。 \\xdd 查找以十六进制数 dd 规定的字符。 \\uxxxx 查找以十六进制数 xxxx 规定的 Unicode 字符。 量词 量词 描述 n+ 匹配任何包含至少一个 n 的字符串。 n* 匹配任何包含零个或多个 n 的字符串。 n? 匹配任何包含零个或一个 n 的字符串。（取消贪婪匹配） n{X} 匹配包含 X 个 n 的序列的字符串。 n{X,Y} 匹配包含 X 至 Y 个 n 的序列的字符串。例如： /^\\w{5,8}$/ 字符串必须是单词字符。且是5-8位。 n{X,} 匹配包含至少 X 个 n 的序列的字符串。 n$ 匹配任何结尾为 n 的字符串。 ^n 匹配任何开头为 n 的字符串。 ?=n 匹配任何其后紧接指定字符串 n 的字符串。 ?!n 匹配任何其后没有紧接指定字符串 n 的字符串。 RegExp对象的方法 方法 描述 compile 编译正则表达式。 exec 检索字符串中指定的值。返回找到的值，并确定其位置。返回值为类数组 test 检索字符串中指定的值。返回 true 或 false。 支持正则表达式的字符串方法 方法 描述 search 检索与正则表达式相匹配的值。会自动忽略g修饰符 match 找到一个或多个正则表达式的匹配。返回数组 replace 替换与正则表达式匹配的子串。如正则表达式无g修饰符。则只替换找到的第一个符合条件的字符串 split 把字符串分割为字符串数组。 exec没有g修饰符，reg.lastIndex无变化，示例 var str = 'a12a12'; var reg = /[a-z]/; console.log(reg.exec(str), reg.lastIndex);// [\"a\", index: 0, input: \"a12a12\", groups: undefined] console.log(reg.exec(str), reg.lastIndex);// [\"a\", index: 0, input: \"a12a12\", groups: undefined] // ...一直打印相同的值 有g修饰符，reg.lastIndex变化，示例 var str = 'a12a12'; var reg = /[a-z]/g; console.log(reg.exec(str), reg.lastIndex);// [\"a\", index: 0, input: \"a12a12\", groups: undefined] 1 console.log(reg.exec(str), reg.lastIndex);// [\"a\", index: 3, input: \"a12a12\", groups: undefined] 4 console.log(reg.exec(str), reg.lastIndex);// null 0 console.log(reg.exec(str), reg.lastIndex);// [\"a\", index: 0, input: \"a12a12\", groups: undefined] 1 console.log(reg.exec(str), reg.lastIndex);// [\"a\", index: 3, input: \"a12a12\", groups: undefined] 4 console.log(reg.exec(str), reg.lastIndex);// null 0 // ...循环上面结果 // 结论 // 值会更改。且reg.lastIndex显示：《下次匹配&lt;a12a12&gt;字符串时的起始下标》，index属性则记录了当前匹配结果在字符串中的起始下标 // 就是说。不会对已经匹配过的字符重复匹配。除非匹配到字符串尽头以至于从头开始了 test没有g修饰符，reg.lastIndex无变化，示例 var str = 'a12a12'; var reg = //; console.log(reg.test(str), reg.lastIndex);// true 0 console.log(reg.test(str), reg.lastIndex);// true 0 // ...一直打印相同的值 有g修饰符，reg.lastIndex变化，示例 var str = 'a12a12'; var reg = /[a-z]/g; console.log(reg.test(str), reg.lastIndex);// true 1 console.log(reg.test(str), reg.lastIndex);// true 4 console.log(reg.test(str), reg.lastIndex);// false 0 console.log(reg.test(str), reg.lastIndex);// true 1 console.log(reg.test(str), reg.lastIndex);// true 4 console.log(reg.test(str), reg.lastIndex);// false 0 // ...循环上面结果 // 结论 // 值会更改。且reg.lastIndex显示：《下次匹配&lt;a12a12&gt;字符串时的起始下标》 // 就是说。不会对已经匹配过的字符重复匹配。除非匹配到字符串尽头以至于从头开始了 search// 返回《第一个符合正则的字符串下标》，不会对reg.lastIndex造成影响 var str = '12a12'; var reg = /[a-z]/g;// 这里g修饰符会被忽略 console.log(str.search(reg), reg.lastIndex);// 2 0 match没有g修饰符，返回值类数组，且类数组内只有第一个符合条件的字符换 // 返回《类数组》，且类数组内只有第一个符合条件的字符换，不会对reg.lastIndex造成影响 var str = 'a12a12'; var reg = /[a-z]/; console.log(str.match(reg), reg.lastIndex);// [\"a\", index: 0, input: \"a12a12\", groups: undefined] 0 有g修饰符，返回数组，数组内包含字符串中所有符合正则的字符串 // 返回《数组》，数组内包含字符串中所有符合正则的字符串，不会对reg.lastIndex造成影响 var str = 'a12a12'; var reg = /[a-z]/g; console.log(str.match(reg), reg.lastIndex);// [\"a\", \"a\"] 0 replace没有g修饰符，只替换第一个 // 只替换第一个符合正则的字符串 var str = 'a12a12'; var reg = /[a-z]/; console.log(str.replace(reg, '='));// =12a12 有g修饰符。替换所有符合正则的字符串 // 替换所有符合正则的字符串 var str = 'a12a12'; var reg = /[a-z]/g; console.log(str.replace(reg, '='));// =12=12 split// 将符合正则的字符串当作数组中的逗号分隔，返回分割后的数组 var str = 'a12a12'; var reg = /[a-z]/g;// 此处忽略g修饰符 console.log(str.split(reg));// [\"\", \"12\", \"12\"] 子表达式与$和replace的妙用正则中的小括号不仅仅可以将局部正则变的独立。还可以变成子表达式，享有子表达的特有api。 被()包裹的正则表达式。被称为正则子表达式。正则子表达式的值可以在replace第二个参数中用$1、$2….来接收结果 例子1：当《replace的第二个参数》是函数时，在此函数中使用// 子1 子2 var reg = /b(\\w\\d)(\\d)/g; var str = \"abc19k\"; str.replace(reg,function($, $1, $2)&#123; console.log($, ' $');// 代表整个正则表达式匹配的值 console.log($1, ' $1');// 第一个子表达式匹配的值 console.log($2, ' $2');// 第二个子表达式匹配的值 &#125;); // console.log所打印结果如下 // bc19 $ // c1 $1 // 9 $2 例子2：当《replace的第二个参数》是字符串时，在此字符串中使用// 子1 子2 var reg = /b(\\w\\d)(\\d)/g; var str = \"abc19k\"; // 此处$1是第一个子表达式结果----&gt;&gt; c1 // $2则是第二个子表达式结果 -----&gt;&gt; 9 // 单纯的$只是一个字符串，且也是一个特殊的转义字符 console.log(str.replace(reg, \"$2\"));// ---&gt;&gt; a9k // -------------分割线----------- // 如果想要将结果替换成$字符，那么需要用$来转义，而不是\\ // 错误转义用 \\ console.log(str.replace(reg, \"\\$2\"));// ---&gt;&gt; a9k 失败了，函数仍然将$2理解为一个特殊值 // 正确转义用 $ 以暴制暴 console.log(str.replace(reg, \"$$2\"));// ---&gt;&gt; a$2k 转义成功 例子3：在正则中使用var str = 'aaabbbccccccccaaa'; // 这里 \\1 代表第一个子表达式所匹配的《结果》，(如果有第二个子表达式的话，\\2则代表第二个子表达式的匹配结果....) var reg = /(\\w)\\1*/g; console.log(str.replace(reg, '$1'));// abca 经典示例从后往前数，每三位添加一个 . // 例如将 1234567 变成 1.234.567 var str = '1234567'; var reg = /(?=(\\B)(\\d&#123;3&#125;)+$)/g; console.log(str.replace(reg, '.'));// ---&gt;&gt;&gt; 1.234.567 排除某类字符： // 匹配《不包含 aaa，bbb，c2》的字符串 var reg = /^((?!aaa|bbb|c2).)*$/g; // 例如： var str1 = 'aaqwer'; console.log(reg.test(str1));// true str1不包含 aaa var str2 = 'qwc2er'; console.log(reg.test(str2));// false str2包含了c2 将驼峰单词变成连字符单词 var str = 'theFirstName'; var reg = /([A-Z])/g; str.replace(reg, function($)&#123; return '-'+$.toLowerCase() &#125;);// ---&gt;&gt;&gt; \"the-first-name\" 将连字符单词变成驼峰单词 var str = 'the-first-name'; var reg = /-(\\w)/g; str.replace(reg, function($, $1)&#123; return $1.toUpperCase(); &#125;);// ---&gt;&gt;&gt; \"theFirstName\"","permalink":"https://codermino.github.io/2020/08/18/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%AD%A3%E5%88%99reg/","photos":[]},{"tags":[{"name":"js学习笔记数组array","slug":"js学习笔记数组array","permalink":"https://codermino.github.io/tags/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B0%E7%BB%84array/"}],"title":"js学习笔记数组array","date":"2020/08/18","text":"创建数组// 1 var arr1 = new Array();// ---&gt;&gt; [] // 2 var arr2 = new Array(0);// ----&gt;&gt; [] // 3 var arr3 = new Array(2);// ----&gt;&gt; [empty, empty];// 初始长度为2的空内容数组 // 4 var arr4 = new Array(1,2);// ----&gt;&gt; [1,2];// 初始就包含元素1和2的数组 // 5 字面量直接定义，！推荐 var arr = [];// ----&gt;&gt; [] // 或初始就有元素 var arr = [1, 2];// ----&gt;&gt; [1, 2]; 数组遍历// 现有变量： var arr = [1,2,3]; var len = arr.length; // 通用遍历方法示例1 --- 《for》 for(var i = 0; i &lt; len; i++)&#123; console.log(arr[i]); &#125; // 通用遍历方法示例2 --- 《while》 while(len &gt;= 0)&#123; console.log(arr[len]); len--; &#125; // ...for in 或者for of以及forEach或者别的语义的filter和map等也可以遍历。不多赘述。写法一样 数组方法* pop 删除并返回数组的最后一个元素 * push 向数组的末尾添加一个或更多元素，并返回新数组的长度 * shift 删除并返回数组的第一个元素 * unshift 向数组的开头添加一个或更多元素，并返回新的长度 * concat 拼接数组，返回全新数组。 * splice 剪切并添加新元素，返回被剪切的元素集合 * join 将数组转成字符串，每个元素间用参数分隔 * toString 将数组转成字符串，元素间用逗号隔开 * sort 排序数组，参数可以是自定义的函数 * filter 过滤数组， 返回符合条件的数组 * forEach 遍历数组，无返回值 * map 修改数组，返回新结果数组 * reduce 将数组值按照某种自定义的规则汇总 * includes 检查数组是否存在某元素。返回true或false * some 检测数组中是否至少存在一个指定元素。如存在则终止并返回true，否则false * every 检测数组所有元素是否都符合指定条件（通过函数提供），如出现一个不符合，则返回false * find 参数为函数，返回满足条件的第一个数据，并终止查找 * findIndex 参数为函数，满足条件的第一个数据的下标，并终止查找 * reverse 将数组倒置 * fill 填充数组 * copyWithin 从数组的指定位置拷贝元素到数组的另一个指定位置中 pop// 删除并返回数组的最后一个元素 var arr = [1, 5, 6]; console.log(arr.pop());// 6 console.log(arr);// [1, 5] push// 向数组的末尾添加一个或更多元素，并返回新数组的长度 var arr = [1, 5]; console.log(arr.push(6));// 3 console.log(arr);// [1, 5, 6] shift// 删除并返回数组的第一个元素 var arr = [1, 5, 6]; console.log(arr.shift());// 1 console.log(arr);// [5, 6] unshift// 向数组的开头添加一个或更多元素，并返回新的长度 var arr = [5, 6]; console.log(arr.unshift(1));// 3 console.log(arr);// [1, 5, 6] concat// 拼接数组，返回全新数组。参数可以是元素，也可是数组 // 1参数为元素 var arr = [1, 5]; console.log(arr.concat(6, 8));// [1, 5, 6, 8] console.log(arr);// [1, 5] // 2参数为数组， var arr = [1, 5]; console.log(arr.concat([6, [8, 9]]));// [1, 5, 6, [8, 9]]; console.log(arr);// [1, 5] splice// 剪切并添加新元素，返回被剪切的元素集合 var arr = [1, 5, 6, 7, 8]; console.log(arr.splice(1,2,\"abc\"));// [5, 6] console.log(arr);// [1, \"abc\", 7, 8] join// 将数组转成字符串，每个元素间用参数分隔 var arr = [1, 5]; console.log(arr.join);// \"1,5\" console.log(arr);// [1, 5] toString// 将数组转成字符串，元素间用逗号隔开 var arr = [1, 5]; console.log(arr.toString);// \"1,5\" console.log(arr);// [1, 5] sort// 将数组排序 // 1排序数字数组 var arr = [5,9,3]; console.log(arr.sort());// [3, 5, 9] console.log(arr);// [3, 5, 9] // 2排序字符串数组，根据unicode码排序。 var arr = ['bd','ba','c', 'a']; console.log(arr.sort());// [\"a\", \"ba\", \"bd\", \"c\"] // 3排序复杂数组，参数为自定义的函数。函数内部接收两个参数 ，代表前一个元素和后一个元素。函数的返回值是正或负数，决定了元素的前后位置 var arr = [&#123;age: 20&#125;, &#123;age: 16&#125;, &#123;age: 18&#125;]; console.log(arr.sort(function(a,b)&#123; return a.age-b.age &#125;));// [&#123;age: 16&#125;, &#123;age: 18&#125;, &#123;age: 20&#125;]; filter// 过滤数组， 返回符合条件的数组 // 例如，筛选出数组中，age大于18的元素集合 var arr = [&#123;age: 20&#125;, &#123;age: 16&#125;, &#123;age: 18&#125;, &#123;age: 17&#125;]; console.log(arr.filter(function(prop, index ,arr)&#123; return prop.age&gt;17 &#125;));// [&#123;age: 20&#125;, &#123;age: 18&#125;] console.log(arr);// 未变 forEach// 遍历数组，参数为函数，函数有三个参数，分别是值,下标,源数组 var arr = [&#123;age: 20&#125;, &#123;age: 16&#125;]; console.log(arr.forEach(function(prop, index ,arr)&#123; // prop---&gt;&gt;当前元素 // index---&gt;&gt;当前元素的下标 // arr---&gt;&gt;源数组的引用 // 此处可以更改数组当前项内容。但如果执行了return会提前终止遍历 console.log(prop, index, arr); &#125;));// 无返回值---&gt;&gt;undefined map// 更改数组 var arr = [&#123;age: 20&#125;, &#123;age: 16&#125;] console.log(arr.map(function(prop, index, arr)&#123; prop.age+=1; return prop; &#125;));// [&#123;age: 21&#125;, &#123;age: 17&#125; console.log(arr);// [&#123;age: 21&#125;, &#123;age: 17&#125; reduce// reduce接受两个参数。第一个参数是规则函数，第二个是规则运行时的初始值initivalValue，reduce会返回规则最终汇总的结果 // 如果没有传入initivalValue参数，则reduce会将数组的第一个元素当作initivalValue // 例1，做一个简单的累加器 var arr = [1, 5]; var initivalValue = 0; var num = arr.reduce(function(x, y)&#123; return x+y; &#125;, initivalValue ); console.log(num);// 6 如果initivalValue值为5，则num最终值为11 // 例2，计算value总和以及age总和。 var arr1 = [ &#123;value: 1, age: '30'&#125;, &#123;value: '5', age: 20&#125; ] var ZH = arr1.reduce(function(pre, next)&#123; var value = parseFloat(pre.value)+parseFloat(next.value); var age = parseFloat(pre.age)+parseFloat(next.age); return &#123;value: value, age: age&#125; &#125;, &#123;value: '0', age: 0&#125;); console.log(ZH);// ---&gt;&gt; &#123;value: 6, age: 50&#125; // 提示：与reduce类似的还有一个叫reduceRight的函数。原理一样。只不过是从后往前开始汇总计算 includes// 检测数组中是否存在某元素,参数1是需要查找的元素。参数2是从下标几开始查找 var arr = [6, 'a', 'b']; arr.includes('a');// true arr.includes('a', 1);// true arr.includes('a', 2);// false some// 检测数组所有元素是否有至少一个符合指定条件，返回true或false，如遇到符合的 则立刻终止查询并返回true // 参数必须是函数 var arr = [6, 'a', 'd']; arr.some(function(prop, index)&#123; // console.log(index);// 当前下标 return prop === 'a' &#125;);// true every// 用于检测数组所有元素是否都符合指定条件，如有一个不满足。则立即终止查询并返回false // 参数必须是函数 var arr = [6, 'a', 'd']; arr.every(function(prop, index)&#123; // console.log(index);// 当前下标 return prop === 'a';// 是否全都是'a' &#125;);// false find// 参数为函数，满足条件的第一个数据，并终止查找 var arr = [&#123;age: 20&#125;, &#123;age: 26&#125;]; arr.find(function(prop, index)&#123; // console.log(index);// 当前下标 return prop.age &gt; 26;// 年龄大于26的第一个元素 &#125;);// ---&gt;&gt;&gt; &#123;age: 26&#125; findIndex// 参数为函数，满足条件的第一个数据，并终止查找 var arr = [&#123;age: 20&#125;, &#123;age: 26&#125;]; arr.findIndex(function(prop, index)&#123; // console.log(index);// 当前下标 return prop.age &gt; 26;// 年龄大于26的第一个元素 &#125;);// ---&gt;&gt;&gt; 1 reverse// 倒置数组 var arr = [1, 5, 6]; console.log(arr.reverse());;;// [6, 5, 1] console.log(arr);// [6, 5, 1] fill// 填充数组 // 参数1，需要用来替换的值 // 参数2，起始下标(包含该下标) // 参数3，截至下标(不包含该下标) // 例1，不传参数2和参数3 var arr = [1, 5, 6, 8]; console.log(arr.fill('a'));// 全部替换 [\"a\", \"a\", \"a\", \"a\"] console.log(arr); [\"a\", \"a\", \"a\", \"a\"] // 例2，传入参数2和3 var arr = [1, 5, 6, 8]; console.log(arr.fill('a',1,3));// [1, \"a\", \"a\", 8] console.log(arr);// [1, \"a\", \"a\", 8] copyWith// 从数组的指定位置拷贝元素到数组的另一个指定位置中 // 参数1，放置的位置下标，包含该下标 // 参数2，复制时的起始下标，复制时包含该下标 // 参数3，复制终止的下标，复制时不包含该下标 var arr = [\"a\", \"b\", \"c\", \"d\", \"e\"]; arr.copyWithin(2, 0, 2);// [\"a\", \"b\", \"a\", \"b\", \"e\"]","permalink":"https://codermino.github.io/2020/08/18/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B0%E7%BB%84array/","photos":[]},{"tags":[{"name":"js学习笔记对象object","slug":"js学习笔记对象object","permalink":"https://codermino.github.io/tags/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%AF%B9%E8%B1%A1object/"}],"title":"js学习笔记对象object","date":"2020/08/18","text":"对象默认特性* 对象的属性是唯一的。定义多个重复属性时，只有最后一个会生效。也就是后来居上覆盖前面的。 * 对象的属性值可以是基础数据类型中任意类型值。 * 对象是引用值。实际上一个对象变量仅代表了一个空间的引用。相当于一个地址。而非数据 对象基本使用1.创建对象// 1通过构造函数创建 var o1 = new Object();// &#123;&#125; // 2通过字面量 var o2 = &#123;&#125;;// &#123;&#125; 2.向对象添加属性var o = &#123;&#125;;// 创建一个对象 o.name = \"xiaoxie\"; console.log(o);// ---&gt;&gt;&gt; &#123;name: \"xiaoxie\"&#125; 3.读取对象属性值var o = &#123;name: 'xiaoxie'&#125;; // 读取o的name属性的值 o.name或o[\"name\"] 4.修改对象属性值var o = &#123;name: 'xx'&#125;; console.log(o);// &#123;name: 'xx'&#125; // 修改name为xiaoxie o.name = \"xiaoxie\"; // 或者 o[\"name\"] = \"xiaoxie\"; console.log(o);// &#123;name: \"xiaoxie\"&#125; 5.删除对象的属性var o = &#123;name: \"xx\"&#125;; console.log(o);// &#123;o&#125; delete o.name;// true console.log(o);// &#123;&#125; 6.对象的遍历var o = &#123;name: 'xiaoxie', sex: '男'&#125;; for (var i in o)&#123; console.log(i);// 属性名 console.log(o[i]);// 属性值 &#125; Object构造函数的一些常用api* is将两个值以《类似===的比较》进行对比。返回值true或false，这个函数神奇的地方是：Object.is(NaN, NaN);//---&gt;&gt;true assign合并别的对象的值到第一个对象中。并且相同属性，将使用别的对象提供的 * defineProperty更改单个属性特性 * defineProperties更改多个属性特性 * getOwnPropertyDescriptor(o ,\"name\")返回o对象的name属性的特性信息 * getOwnPropertyDescriptors(o)返回o对象的所有自由属性的特性信息 * keys(o)返回o自有属性中的可枚举key数组。[\"name\", \"age\"] * getOwnPropertyNames(o)返回o的所有自有属性key数组，包括不可枚举属性 * values(o)返回o自有属性中的可枚举key所对应的值数组[\"xiaoxie\", \"23\"] * entries(o)返回o的可迭代key和value数组----&gt;&gt;&gt;[[\"x\", \"1\"],[\"y\", \"2\"]] * getPrototypeOf(o)获取o对象的原型 * isExtensible(o)检测o对象是否是---&gt;&gt;《可扩展的》(不可扩展意为不可以新增属性)，返回true或false * preventExtensions(o)将o变为不可扩展对象，并返回o对象的引用，此法只针对o，对于o的属性没有影响 * isSealed(o)获取o是否是----&gt;&gt;《不可扩展，且所有自有属性也都是不可配置》，返回true或false * seal(o)将o变为不可扩展对象，且将o的所有自有属性的特性设置为不可配置。并返回对象的引用 * isFreeze(o)获取o是否是----&gt;&gt;《不可扩展，且所有自有属性也都是不可配置和只读》，返回true或false * freeze(o)将o变为不可扩展对象，且将o的所有自有属性的特性设 置为不可配置和只读。但是存取器属性setter依然可以通过 赋值来调用，但是setter函数内的修改属性值的语句不会生效； is// 接受两个参数，比较两个值是否相等，并返回布尔值 Object.is(1, '1');// false Object.is(1, 1);// true Object.is(NaN, NaN);// true 《在这个函数出现以前，NaN是不等于任何值的，包括NaN自身》 assign// 接受多个参数。参数都必须是对象，返回第一个参数的引用。且所有参数中。只有第一个参数的值会被更改 var a = &#123;name: 'a', age: 20&#125;; var b = &#123;name: 'b', sex: 'n'&#125;; var c = &#123;name: 'c', sex: 'hh'&#125;; Object.assign(a, b, c);// ---&gt;&gt;&gt; &#123;name: \"c\", age: 20, sex: \"hh\"&#125; // a ---&gt;&gt; &#123;name: \"c\", age: 20, sex: \"hh\"&#125; // b ---&gt;&gt; &#123;name: \"b\", sex: \"n\"&#125; // c ---&gt;&gt; &#123;name: \"c\", sex: \"hh\"&#125; definePropertyObject.defineProperty(o, propKey, attr) Object.defineProperty不但可以定义属性特性。在定义时也可以修改属性值 Object.defineProperty的attr配置中，关于读取操作。有两种描述符，分别是《数据描述符》和《存取描述符》 // 描述符对象的默认值 // 数据描述符的默认值 &#123; value: \"初始值\", writable: false,// 可写性 enumerable: false,// 可枚举性 configurable: false// 特性的可配置性。为false，表示自此以后不可以修改任何特性 &#125; // 存取描述符的默认值 &#123; get: function()&#123;return '默认值'&#125;, set: undefined,// 可写性 enumerable: false,// 可枚举性 configurable: false// 特性的可配置性。为false，表示自此以后不可以修改任何特性 &#125; // 数据描述符 var o = &#123;name: 'xx'&#125;; Object.defineProperty(o, 'name', &#123; value: 'xiaoxie',// 属性值 writable: true,// 是否可写，意为属性值是覅偶可以更改 enumerable: true,// 是否可以被枚举。true时在for in循环中可以被枚举到 configurable: false// 特性是否可以被修改，false时则不可逆,也就是之后无法再次更改任何特性信息 &#125;) // 存取描述符 var store = &#123;name: 'xx'&#125;; var o = &#123;&#125;; Object.defineProperty(o, 'name', &#123; get: function() &#123;// 定义属性值，读取o.name时执行的函数 return store.name; &#125;, set: function(v) &#123; // 在这里可以搞事情，做一些判断。来决定是否进行赋值更改 store.name = v;// 定义赋值操作。在给o.name赋值时执行的函数。 &#125;, enumerable: true,// 是否可以被枚举。true时在for in循环中可以被枚举到 configurable: false// 特性是否可以被修改，如值是false，则不可逆，也就是之后无法再次更改任何特性信息 &#125;) definePropertiesObject.defineProperties(o, attr) Object.defineProperties允许同时定义多个属性。但是其实并不如defineProperty好用灵活 var o = &#123;&#125;; Object.defineProperties(o, &#123; name: &#123; value: 'xiaoxie' // 这里写着描述符 &#125;, sex: &#123; get: function() &#123;// 定义属性值，读取o.name时执行的函数 return '男'; &#125;, set: function(v) &#123; alert('sex属性不可以更改'); return '此值不可以更改' &#125; // 这里写描述符 &#125; &#125;) console.log(o.name);// \"xiaoxie\" console.log(o.sex);// \"男\" getOwnPropertyDescriptor// 返回o对象的name属性的特性信息, 接受两个参数，分别是对象和它的一个属性名字符串 // 例如： // 先定义一个o对象，并配置属性值 var o = &#123;&#125;; Object.defineProperties(o, &#123; name: &#123; value: 'xiaoxie' // 这里写着描述符 &#125; &#125;) // 返回o对象的name属性的特性信息 Object.getOwnPropertyDescriptor(o, 'name'); //---&gt;&gt;&gt; &#123;value: \"xiaoxie\", writable: false, enumerable: false, configurable: false&#125; getOwnPropertyDescriptors// 返回o对象的所有属性的特性信息, 接收一个参数——对象 // 例如： // 先定义一个o对象，并配置属性值 var o = &#123;&#125;; Object.defineProperties(o, &#123; name: &#123; value: 'xiaoxie' // 这里写着描述符 &#125;, sex: &#123; get: function() &#123;// 定义属性值，读取o.name时执行的函数 return '男'; &#125;, set: function(v) &#123; alert('sex属性不可以更改'); return '此值不可以更改' &#125; // 这里写描述符 &#125; &#125;) // 返回o对象的所有属性的特性信息 Object.getOwnPropertyDescriptors(o); &#123; name: &#123;value: \"xiaoxie\", writable: false, enumerable: false, configurable: false&#125; sex: &#123;enumerable: false, configurable: false, get: ƒ, set: ƒ&#125; &#125; keys// 返回对象的所有自有属性中《可枚举的属性》组成的数组 var o = &#123;&#125;; Object.defineProperties(o, &#123; name: &#123; value: 'xiaoxie', enumerable: true// 设置为可枚举 &#125;, sex: &#123; get: function() &#123; return '男'; &#125;, set: function(v) &#123; &#125;, enumerable: false// 设置为不可枚举 &#125; &#125;) Object.keys(o); //---&gt;&gt;[\"name\"] getOwnPropertyNames// 返回对象的所有自有属性数组。无论是否可枚举 var o = &#123;&#125;; Object.defineProperties(o, &#123; name: &#123; value: 'xiaoxie', enumerable: true// 设置为可枚举 &#125;, sex: &#123; get: function() &#123; return '男'; &#125;, set: function(v) &#123; &#125;, enumerable: false// 设置为不可枚举 &#125; &#125;) Object.getOwnPropertyNames(o);// [\"name\", \"sex\"] values// 返回对象中所有自有属性《可枚举的属性》的值 组成的数组 // 例1 var o = &#123;&#125;; Object.defineProperties(o, &#123; name: &#123; value: 'xiaoxie', enumerable: true// 设置为可枚举 &#125;, sex: &#123; get: function() &#123; return '男'; &#125;, set: function(v) &#123; &#125;, enumerable: false// 设置为不可枚举 &#125; &#125;) Object.values(o);// [\"xiaoxie\"] // 例2 var o = &#123;&#125;; Object.defineProperties(o, &#123; name: &#123; value: 'xiaoxie', enumerable: true// 设置为可枚举 &#125;, sex: &#123; get: function() &#123; return '男'; &#125;, set: function(v) &#123; &#125;, enumerable: true// 设置为可枚举 &#125; &#125;) Object.values(o);// [\"xiaoxie\", \"男\"] entries// 返回对象中所有自有属性《可枚举的属性》的['key', 'value'] 组成的数组 // 例1 var o = &#123;&#125;; Object.defineProperties(o, &#123; name: &#123; value: 'xiaoxie', enumerable: true// 设置为可枚举 &#125;, sex: &#123; get: function() &#123; return '男'; &#125;, set: function(v) &#123; &#125;, enumerable: false// 设置为不可枚举 &#125; &#125;) Object.entries(o);// ----&gt;&gt; [[\"name\", \"xiaoxie\"]] // 例2 var o = &#123;&#125;; Object.defineProperties(o, &#123; name: &#123; value: 'xiaoxie', enumerable: true// 设置为可枚举 &#125;, sex: &#123; get: function() &#123; return '男'; &#125;, set: function(v) &#123; &#125;, enumerable: true// 设置为可枚举 &#125; &#125;) Object.entries(o);// ----&gt;&gt; [[\"name\", \"xiaoxie\"], [\"sex\", \"男\"]] getPrototypeOf// 检测p是否在o的原型链上，此方法是原型上的方法，所以实际上是实例上直接可用的方法 var p = &#123;x:'1'&#125;; var o = Object.create(p); p.isPrototypeOf(o);// ----&gt;&gt; true p在o的原型链中 o.isPrototypeOf(p);// ----&gt;&gt; false o不在p的原型链中 Object.prototype.isPrototypeOf(o);// ----&gt;&gt; true Object.prototype在o的原型链中 isPrototypeOf// 获取对象的原型，接受一个参数——对象 function F()&#123;&#125;; var o = new F(); Object.getPrototypeOf(o)=== F.prototype;// ---&gt;&gt; true Object.getPrototypeOf(o).constructor === F;// ---&gt;&gt; true isExtensible// 检测o对象是否是---&gt;&gt;《可扩展的》(是否可以新增属性)，返回true或false var o = &#123;name: 'o'&#125;; Object.isExtensible(o);// true // 执行添加属性 o.age = 20; console.log(o);// &#123;name:'o', age: 20&#125; preventExtensions// 接受一个参数o对象，将o变为不可扩展对象，并返回o对象的引用，此法只针对o，对于o的属性没有影响 var o = &#123;prop: &#123;name: 'pr'&#125;&#125;; Object.preventExtensions(o);// &#123;prop: &#123;name: \"pr\"&#125;&#125; // 执行添加属性 o.age = 20; console.log(o);// &#123;prop: &#123;name: \"pr\"&#125;&#125; 这里age并没有被添加进o对象 // preventExtensions不会影响到目标对象的属性 // 例如这里给o.prop对象添加属性 o.prop.age = 20; console.log(o);// ----&gt;&gt; &#123;prop: &#123;name: \"pr\", age: 20&#125;&#125; isSealed// 接受一个参数o对象，获取o是否是----&gt;&gt;《不可扩展，且所有自有属性也都是不可配置》，返回true或false // 例1 // 先定义一个对象，并配置属性的configurable var o = &#123;&#125;; Object.defineProperties(o, &#123; name: &#123; value: 'xiaoxie', configurable: false,// 配置性设置为false，表示自此以后不可以修改任何特性 &#125;, sex: &#123; configurable: true,// 配置性设置为true &#125; &#125;) Object.preventExtensions(o);// 接着将其改为不可扩展的，如果没有变成不可扩展。。。下面就不用测试了，肯定false Object.isSealed(o);// false 这里最终结果返回false。因为sex属性特性中configurable是可配置的 // 例2 // 先定义一个对象，并配置属性的configurable var o = &#123;&#125;; Object.defineProperties(o, &#123; name: &#123; value: 'xiaoxie', configurable: false,// 配置性设置为false，表示自此以后不可以修改任何特性 &#125;, sex: &#123; configurable: false,// 配置性设置为false &#125; &#125;) Object.preventExtensions(o);// 接着将其改为不可扩展的，如果没有变成不可扩展。。。下面就不用测试了，肯定false Object.isSealed(o);// true这里最终结果返回true ，因为o对象是不可扩展的。且它的所有自有属性的特性也都是不可配置的 seal// 接受一个参数o对象，将o变为不可扩展对象，且将o的所有自有属性的特性设置为不可配置。并返回对象的引用 // 例如 var o = &#123;name: 'xx',prop: &#123;age: 20&#125;&#125;; Object.isExtensible(o);// --&gt;&gt; true Object.isSealed(o);// --&gt;&gt; false Object.seal(o);// --&gt;&gt; 返回o的引用&#123;name: 'xx',prop: &#123;age: 20&#125;&#125; Object.isExtensible(o);// --&gt;&gt; false Object.isSealed(o);// --&gt;&gt; true // o的自有属性仍然可以《扩展和修改自身属性》的值 o.prop.age = 23;// console.log(o);// --&gt;&gt; &#123;name: 'xx',prop: &#123;age: 23&#125;&#125; o.prop.name = 'son'; console.log(o);// --&gt;&gt; &#123;name: 'xx',prop: &#123;age: 23, name: 'son'&#125;&#125; isFreeze// 接受一个参数o对象，获取o是否是----&gt;&gt;《不可扩展，且所有自有属性也都是不可配置和只读》，返回true或false // 例1 // 先定义一个对象，并配置属性的configurable var o = &#123;&#125;; Object.defineProperties(o, &#123; name: &#123; value: 'xiaoxie', configurable: false, writable: false, //不可写 &#125;, sex: &#123; configurable: false, writable: true, // 可写 &#125; &#125;); Object.seal(o);// 将o变为不可扩展对象，且将o的所有自有属性的特性设置为不可配置。并返回对象的引用 Object.isFrozen(o); Object.isFrozen(o);// ---&gt;&gt; 结果为false // 例2 // 先定义一个对象，并配置属性的configurable var o = &#123;&#125;; Object.defineProperties(o, &#123; name: &#123; value: 'xiaoxie', configurable: false, writable: false, //不可写 &#125;, sex: &#123; configurable: false, writable: false, // 不可写 &#125; &#125;); Object.seal(o);// 将o变为不可扩展对象，且将o的所有自有属性的特性设置为不可配置。并返回对象的引用 Object.isFrozen(o); console.log(Object.isFrozen(o));// ---&gt;&gt; 结果为true freeze// 接受一个参数o对象，将其变成不可扩展。并且自有属性也变成不可配置和只读 // 例如 var o = &#123;name: 'xx',prop: &#123;age: 20&#125;&#125;; Object.isExtensible(o);// --&gt;&gt; true Object.isSealed(o);// --&gt;&gt; false Object.isFrozen(o);// --&gt;&gt; false Object.freeze(o);// --&gt;&gt; 返回o的引用&#123;name: 'xx',prop: &#123;age: 20&#125;&#125; Object.isExtensible(o);// --&gt;&gt; false Object.isSealed(o);// --&gt;&gt; true Object.isFrozen(o);// --&gt;&gt; true // o的自有属性仍然可以《扩展和修改自身属性》的值 o.prop.age = 23;// console.log(o);// --&gt;&gt; &#123;name: 'xx',prop: &#123;age: 23&#125;&#125; o.prop.name = 'son'; console.log(o);// --&gt;&gt; &#123;name: 'xx',prop: &#123;age: 23, name: 'son'&#125;&#125;","permalink":"https://codermino.github.io/2020/08/18/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%AF%B9%E8%B1%A1object/","photos":[]},{"tags":[{"name":"js学习笔记字符串string","slug":"js学习笔记字符串string","permalink":"https://codermino.github.io/tags/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%AD%97%E7%AC%A6%E4%B8%B2string/"}],"title":"js学习笔记字符串string","date":"2020/08/18","text":"创建字符串// 1 var str = new String('abc');// ---&gt;&gt; &#123;0: \"a\", 1: \"b\", 2: \"c\", length: 3&#125; typeof(str);// \"object\" // 2 var str1 = \"abc\";// ----&gt;&gt; \"abc\" typeof(str);// \"string\" console.log(str.__proto__ === str1.__proto__);// true 说明同样继承了相同的原型 console.log(str == str1);// true console.log(str === str1);// false 字符串遍历// 现有变量： var str= \"abc\";// 或者new String(\"abc\");下面结果和过程相同 var len = str.length; // 通用遍历方法示例1 --- 《for》 for(var i = 0; i &lt; len; i++)&#123; console.log(str[i]); &#125; // 通用遍历方法示例2 --- 《while》 while(len &gt;= 0)&#123; console.log(str[len]); len--; &#125; 字符串方法* charAt 返回指定位置处的字符 * toUpperCase 将字符串转换成大写 * toLowerCase 将字符串转换成小写 * indexOf 返回特定字符在字符串中第一次出现的位置，参数2为查询的起始下标，未找到则返回-1 * lastIndexOf 从后往前找。原理和结果都和indexOf一样 * search 和indexOf返回值一样。但是参数只支持一个。且这个参数可以是正则 * startsWith(x) 检测字符串是否以x开头，返回true/false * endsWith(x) 检测字符串是否以x结尾，返回true/false * substr(x, y) 从下标x开始往后截取y个字符串 包括x * substring(x, y) 从下标x截取到y,只包下标小的，不区分x和y谁大,并且结果字符串的顺序不会因为x比y大而变成倒序 * slice(x,y) 支持负数,只包下标小的,并且左面数字一定比右面要大，-1为最大下标 * split('_') 用字符串中的_来分割成多段。生成一个数组。返回值---&gt;&gt;&gt;数组 * replace(reg, 'a') str中符合正则的字符,替换为\"a\",注意：参数2可以是函数，参数1正则如果不带g标识符则只替换第一个 * match(reg) 返回符合字符串中符合正则的字符串组成的数组 * conca(s,s1) 将参数转换为字符串并依次按照顺序将其连接到自身的尾部 * trim 清空自身两边的空字符，和此类似的还有trimLeft/trimRight * charCodeAt(index) index默认为0，返回下标为index位置的字符的Unicode编码(结果是数字,且数据类型是Number类型的); * codePointAt(index) 同charCodeAt，新增的，识别方位比charCodeAt更广 charCodeAt和codePointAt// 返回字符串中下标为index位置的字符的Unicode编码(结果是数字,且数据类型是Number类型的); // 中文和中文标点符号的Unicode码是大于255的 // 中文和中文标点符号的字节长度为 2 // 英文和英文标点符号的Unicode码是小于等于255的 // 英文和英文标点符号的字节长度为 1 var abc = \"abc\"; // charCodeAt str.charCodeAt();// 97 str.charCodeAt(0);// 97 str.charCodeAt(1);// 98 // codePointAt str.codePointAt();// 97 str.codePointAt(0);// 97 str.codePointAt(1);// 98 字符串构造函数上的静态方法* String.fromCharCode和String.fromCodePoint接收一个数字参数，将其根据Unicode编码转换成字符串 String.fromCharCode和String.fromCodePoint// 接收一个数字参数，将其根据Unicode编码转换成字符串 String.fromCharCode(97);// 'a' String.fromCodePoint(97);// 'a'","permalink":"https://codermino.github.io/2020/08/18/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%AD%97%E7%AC%A6%E4%B8%B2string/","photos":[]},{"tags":[{"name":"js学习笔记之es6","slug":"js学习笔记之es6","permalink":"https://codermino.github.io/tags/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8Bes6/"}],"title":"js学习笔记之es6","date":"2020/08/17","text":"声明变量// let关键字就是用来声明变量的 // 使用let关键字声明的变量具有块级作用域 // 在一个大括号中 使用let关键字声明的变量才具有块级作用域 var关键字是不具备这个特点的 // 防止循环变量变成全局变量 // 使用let关键字声明的变量没有变量提升 // 使用let关键字声明的变量具有暂时性死区特性 /* --------let关键字就是用来声明变量的-------- */ // let a = 10; // console.log(a); /* --------使用let关键字声明的变量具有块级作用域-------- */ // if (true) &#123; // let b = 20; // console.log(b) // if (true) &#123; // let c = 30; // &#125; // console.log(c); // &#125; // console.log(b) /* -------在一个大括号中 使用let关键字声明的变量才具有块级作用域 var关键字是不具备这个特点的--------- */ // if (true) &#123; // let num = 100; // var abc = 200; // &#125; // console.log(abc); // console.log(num) /* -------防止循环变量变成全局变量--------- */ // for (let i = 0; i &lt; 2; i++) &#123;&#125; // console.log(i); /*-----使用let关键字声明的变量没有变量提升------*/ // console.log(a); // let a = 100; /* -------使用let关键字声明的变量具有暂时性死区特性------- */ var num = 10 if (true) &#123; console.log(num); let num = 20; &#125; const常量// 使用const关键字声明的常量具有块级作用域 // if (true) &#123; // const a = 10; // if (true) &#123; // const a = 20; // console.log(a); // &#125; // console.log(a); // &#125; // console.log(a); // 使用const关键字声明的常量必须赋初始值 // const PI = 3.14; // 常量声明后值不可更改 const PI = 3.14; // PI = 100; const ary = [100, 200]; ary[0] = 123; ary = [1, 2] console.log(ary); 数组解构// 数组解构允许我们按照一一对应的关系从数组中提取值 然后将值赋值给变量 let ary = [1,2,3]; let [a, b, c, d, e] = ary; console.log(a) console.log(b) console.log(c) console.log(d) console.log(e) 对象解构// 对象解构允许我们使用变量的名字匹配对象的属性 匹配成功 将对象属性的值赋值给变量 let person = &#123;name: 'lisi', age: 30, sex: '男'&#125;; // let &#123; name, age, sex &#125; = person; // console.log(name) // console.log(age) // console.log(sex) let &#123;name: myName&#125; = person; console.log(myName) 箭头函数// 箭头函数是用来简化函数定义语法的 // const fn = () =&gt; &#123; // console.log(123) // &#125; // fn(); // 在箭头函数中 如果函数体中只有一句代码 并且代码的执行结果就是函数的返回值 函数体大括号可以省略 // const sum = (n1, n2) =&gt; n1 + n2; // const result = sum(10, 20); // console.log(result) // 在箭头函数中 如果形参只有一个 形参外侧的小括号也是可以省略的 // const fn = v =&gt; &#123; // alert(v); // &#125; // fn(20) // 箭头函数不绑定this 箭头函数没有自己的this关键字 如果在箭头函数中使用this this关键字将指向箭头函数定义位置中的this function fn () &#123; console.log(this); return () =&gt; &#123; console.log(this) &#125; &#125; const obj = &#123;name: 'zhangsan'&#125;; const resFn = fn.call(obj); resFn(); 箭头函数面试题var age = 100; let obj = &#123; age: 20, say: () =&gt; &#123; console.log(this); alert(this.age) &#125; &#125;; obj.say(); 剩余参数// const sum = (...args) =&gt; &#123; // let total = 0; // args.forEach(item =&gt; total += item); // return total; // &#125;; // console.log(sum(10, 20)); // console.log(sum(10, 20, 30)); let ary1 = ['张三' , '李四', '王五']; let [s1, ...s2] = ary1; console.log(s1) console.log(s2) 拓展运算符// 扩展运算符可以将数组拆分成以逗号分隔的参数序列 // let ary = [\"a\", \"b\", \"c\"]; // ...ary // \"a\", \"b\", \"c\" // console.log(...ary) // console.log(\"a\", \"b\", \"c\") // 扩展运算符应用于数组合并 // let ary1 = [1, 2, 3]; // let ary2 = [4, 5, 6]; // // ...ary1 // 1, 2, 3 // // ...ary1 // 4, 5, 6 // let ary3 = [...ary1, ...ary2]; // console.log(ary3) // 合并数组的第二种方法 // let ary1 = [1, 2, 3]; // let ary2 = [4, 5, 6]; // ary1.push(...ary2); // console.log(ary1) // 利用扩展运算符将伪数组转换为真正的数组 var oDivs = document.getElementsByTagName('div'); console.log(oDivs) var ary = [...oDivs]; ary.push('a'); console.log(ary); from方法(从一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例)// var arrayLike = &#123; // \"0\": \"张三\", // \"1\": \"李四\", // \"2\": \"王五\", // \"length\": 3 // &#125; // var ary = Array.from(arrayLike); // console.log(ary) var arrayLike = &#123; \"0\": \"1\", \"1\": \"2\", \"length\": 2 &#125; var ary = Array.from(arrayLike, item =&gt; item * 2) console.log(ary) find方法var ary = [&#123; id: 1, name: '张三' &#125;, &#123; id: 2, name: '李四' &#125;]; let target = ary.find(item =&gt; item.id === 3); console.log(target) findIndex方法let ary = [10, 20, 50]; let index = ary.findIndex(item =&gt; item &gt; 15); console.log(index) includes方法let ary = [\"a\", \"b\", \"c\"]; let result = ary.includes('a') console.log(result) result = ary.includes('e') console.log(result) 模板字符串// let name = `张三`; // let sayHello = `Hello, 我的名字叫$&#123;name&#125;`; // console.log(sayHello); // let result = &#123; // name: \"zhangsan\", // age: 20 // &#125;; // let html = ` // &lt;div&gt; // &lt;span&gt;$&#123;result.name&#125;&lt;/span&gt; // &lt;span&gt;$&#123;result.age&#125;&lt;/span&gt; // &lt;/div&gt; // `; // console.log(html); const fn = () =&gt; &#123; return '我是fn函数' &#125; let html = `我是模板字符串 $&#123;fn()&#125;`; console.log(html) startsWith和endsWithlet str = 'Hello ECMAScript 2015'; let r1 = str.startsWith('Hello'); console.log(r1); let r2 = str.endsWith('2016'); console.log(r2) repeat方法console.log(\"y\".repeat(5)) set方法// const s1 = new Set(); // console.log(s1.size) // const s2 = new Set([\"a\", \"b\"]); // console.log(s2.size) // const s3 = new Set([\"a\",\"a\",\"b\",\"b\"]); // console.log(s3.size) // const ary = [...s3]; // console.log(ary) // const s4 = new Set(); // 向set结构中添加值 使用add方法 // s4.add('a').add('b'); // console.log(s4.size) // 从set结构中删除值 用到的方法是delete // const r1 = s4.delete('c'); // console.log(s4.size) // console.log(r1); // 判断某一个值是否是set数据结构中的成员 使用has // const r2 = s4.has('d'); // console.log(r2) // 清空set数据结构中的值 使用clear方法 // s4.clear(); // console.log(s4.size); // 遍历set数据结构 从中取值 const s5 = new Set(['a', 'b', 'c']); s5.forEach(value =&gt; &#123; console.log(value) &#125;) Object.assign()合并多个对象，第一个参数就是最终的返回值，如果对象的属性名相同，后面的覆盖前面的用途：复制对象，给options属性赋默认值 let objA = &#123; a: 'aa', b: 'bb' &#125; let objB = &#123; b: 'dd', c: 'ee' &#125; let result = Object.assign(&#123;&#125;, objA, objB) result.a = 'cc' console.log(objA, result) //&#123;a: \"aa\", b: \"bb\"&#125; &#123;a: \"cc\", b: \"dd\", c: \"ee\"&#125; Object.is()判断两个值是否相等，返回布尔值用途：es5中，对于0的判断不区分正负值，-0 == +0返回true，NaN == NaN返回 返回false；Object.is()规避了这些问题 Object.is(+0, -0)//false Object.is(NaN, NaN) //true Proxy基本用法 const person = &#123; name: 'www', age: '20' &#125; const personProxy = new Proxy(person, &#123; get(target, key) &#123; return target[key] ? target[key] : 'default' &#125;, set(target, key, value) &#123; target[key] = value % 2 ? value : 99 &#125; &#125;) console.log(person.xxx) // undefined console.log(personProxy.xxx) // default console.log(personProxy.age) //20 personProxy.age = 100 console.log(personProxy) //&#123;name: \"www\", age: 99&#125; 这里注意的一点是，这里被拦截的是”personProxy“，而不是”person“与Object.definedProperty()的比较： 相比与Object.definedProperty只能监听get,set行为，proxy监听的行为更多一些，has、deleteProperty … 等很多 对于数组的push,pop等操作，proxy是监听的整个对象的行为，所以通过set方法能够监听到；而definedProperty需要指定该对象的属性名，对于数组来说，就是指定数组的下标，是监听不到数组的push,pop等操作的let arr = [] let arrProperty = new Proxy(arr, &#123; set (target, key, value) &#123; console.log(target, key, value) //[1] \"length\" 1 target[key] = value return true &#125; &#125;) arrProperty.push(1) console.log(arrProperty) //[1] proxy以非侵入的方式，监听了对象的读写；definedProperty需要指定具体需要监听对象的属性名， 与上面的数组类似，如果想要监听一个含有多个属性的对象的读写行为， definedProperty需要遍历这个对象的所有属性Reflect封装操作对象的统一API在之前的es5中，操作对象有很多种方式const obj = &#123; name: '111', age: '22' &#125; // 判断对象某个属性是否存在 console.log('name' in obj) // 删除某个属性 console.log(delete obj['name']) // 获取对象key console.log(Object.keys(obj)) 对于不同的操作行为，使用的方式却不同，Reflect的目的是使用同一套方式去操作对象const obj = &#123; name: '111', age: '22' &#125; // 判断对象某个属性是否存在 console.log(Reflect.has(obj,'name')) // 删除某个属性 console.log(Reflect.deleteProperty(obj, 'name')) // 获取对象key console.log(Reflect.ownKeys(obj)) class 类es5写法function People (name) &#123; // 设置实例属性 this.name = name; &#125; // 设置实例的共享方法 People.prototype.sayHi = function () &#123; console.log(this.name) &#125; let p = new People('tom') p.sayHi() 使用class更易理解，结构清晰class Peopel &#123; constructor (name) &#123; this.name = name &#125; say () &#123; console.log(this.name) &#125; &#125; const p = new Peopel('tony') p.say() 类的继承class Peopel &#123; constructor (name) &#123; this.name = name &#125; say () &#123; console.log(this.name) //tom，在子类的sayAge中调用 &#125; &#125; class Worker extends Peopel &#123; constructor (name,age) &#123; super(name) this.age = age &#125; sayAge () &#123; super.say() console.log(this) // Worker &#123;name: \"tom\", age: 18&#125; console.log(this.age) // 18 &#125; &#125; const p = new Worker('tom', 18) p.sayAge() 类的继承还是通过原型链的方式实现，具体可以看下babel转换后的代码super可以作为函数调用，也可以作为对象调用作为函数调用时，只能在子类的constructor中调用，此时执行父类的构造函数constructor，执行父类构造函数时，this指向的是子类Worker，所以实例p会有name属性（对于super理解的还是不够，后面要单独学习下） for … of 遍历es5中，使用for … in 遍历键值对结构数据，使用forEach遍历数组es6中新增了set,map数据结构，for…of是用来统一遍历拥有某一种特性的数据结构（可迭代） const arr = [1,2,3] for (const item of arr) &#123; // 遍历数组 console.log(item) &#125; const s = new Set() s.add(1).add(2).add(3) for (const item of s) &#123; // 遍历set结构 console.log(item) &#125; const m = new Map([ ['name','昵称'], ['title', '标题'] ]) for (const [key, value] of m) &#123; // 遍历map结构 console.log(key) console.log(value) console.log(m.get(key)) &#125; const newSet = new Set([ ['name','昵称'], ['title', '标题'] ]) const newMap = new Map(newSet) for (const [key, val] of newMap) &#123; // 遍历set初始化后的map结构 console.log(key) console.log(val) &#125; const obj = &#123; name: 'ttt', age: '19' &#125; for (const [key, val] of obj) &#123; // 遍历对象报错 Uncaught TypeError: obj is not iterable console.log(key, val) &#125; 上面代码中，for…of可以遍历数组，set, map，但是却不能遍历对象，是因为对象没有可迭代接口 生成器 generator用途：处理异步调用回调嵌套的问题 function *geFn () &#123; console.log('111') yield 100 console.log('222') yield 200 console.log('333') yield 300 &#125; let generator = geFn() console.log(generator.next()) //111 &#123;value: 100, done: false&#125; console.log(generator.next()) //222 &#123;value: 200, done: false&#125; console.log(generator.next()) //333 &#123;value: 300, done: false&#125; 在函数名前面加一个”*”，函数就变为生成器函数，执行该函数时，里面的函数不会立即执行，而是会返回一个生成器对象，调用生成器对象的.next方法函数开始执行，当遇到”yield“关键字，函数会停止执行，并把yield的值当做next方法返回对象的value;当下次调用next方法时，函数从当前位置开始继续执行生成器函数执行后返回的生成器对象generator，内部也是实现了迭代器接口，所以可以使用for…of来遍历 function *geFn () &#123; console.log('111') yield 100 console.log('222') yield 200 console.log('333') yield 300 &#125; let generator = geFn() for (const item of generator) &#123; console.log(item) &#125; 在非生成器函数里使用yield关键字会报错 ES2016 数组新增方法：includesconst arr = [1,2,3] console.log(arr.includes(2)) //true 指数运算符console.log(2 ** 10) //1024 ES2017 Object.values()，以数组的形式，返回对象所有的值let obj = &#123; title: 'wwwww', age: 199 &#125; console.log(Object.values(obj)) //[\"wwwww\", 199] Object.entries()，以数组的形式，返回对象的所有键值对let obj = &#123; title: 'wwwww', age: 199 &#125; console.log(Object.entries(obj)) //[[\"title\", \"wwwww\"],[\"age\", 199]] 可以将对象转为map数据结构let obj = &#123; title: 'wwwww', age: 199 &#125; let m = new Map(Object.entries(obj)) console.log(m) //&#123;\"title\" =&gt; \"wwwww\", \"age\" =&gt; 199&#125; Object.getOwnPropertyDescriptor()获取一个对象的完整描述信息，可用于将一个对象的get，set属性赋值给另一个对象let obj = &#123; firstName: 'abc', lastName: '123', get fullName () &#123; return this.firstName + this.lastName &#125; &#125; console.log(obj.fullName) //abc123 const p2 = Object.assign(&#123;&#125;, obj) // 此时赋值给p2的仅仅是fullName属性的值，并没有fullName属性的getter p2.firstName = '456' console.log(p2.fullName) //abc123 const description = Object.getOwnPropertyDescriptors(obj) console.log(description) const p3 = Object.defineProperties(&#123;&#125;, description); p3.firstName = '789' console.log(p3.fullName) //789123 字符串的padEnd()、padStart()方法 async/await","permalink":"https://codermino.github.io/2020/08/17/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8Bes6/","photos":[]},{"tags":[{"name":"js学习笔记之正则表达式","slug":"js学习笔记之正则表达式","permalink":"https://codermino.github.io/tags/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}],"title":"js学习笔记之正则表达式","date":"2020/08/17","text":"正则// 正则表达式在js中的使用 // 1. 利用 RegExp对象来创建 正则表达式 var regexp = new RegExp(/123/); console.log(regexp); // 2. 利用字面量创建 正则表达式 var rg = /123/; // 3.test 方法用来检测字符串是否符合正则表达式要求的规范 console.log(rg.test(123)); console.log(rg.test('abc')); 边界值// 边界符 ^ $ var rg = /abc/; // 正则表达式里面不需要加引号 不管是数字型还是字符串型 // /abc/ 只要包含有abc这个字符串返回的都是true console.log(rg.test('abc')); console.log(rg.test('abcd')); console.log(rg.test('aabcd')); console.log('---------------------------'); var reg = /^abc/; console.log(reg.test('abc')); // true console.log(reg.test('abcd')); // true console.log(reg.test('aabcd')); // false console.log('---------------------------'); var reg1 = /^abc$/; // 精确匹配 要求必须是 abc字符串才符合规范 console.log(reg1.test('abc')); // true console.log(reg1.test('abcd')); // false console.log(reg1.test('aabcd')); // false console.log(reg1.test('abcabc')); // false 字符类//var rg = /abc/; 只要包含abc就可以 // 字符类: [] 表示有一系列字符可供选择，只要匹配其中一个就可以了 var rg = /[abc]/; // 只要包含有a 或者 包含有b 或者包含有c 都返回为true console.log(rg.test('andy')); console.log(rg.test('baby')); console.log(rg.test('color')); console.log(rg.test('red')); var rg1 = /^[abc]$/; // 三选一 只有是a 或者是 b 或者是c 这三个字母才返回 true console.log(rg1.test('aa')); console.log(rg1.test('a')); console.log(rg1.test('b')); console.log(rg1.test('c')); console.log(rg1.test('abc')); console.log('------------------'); var reg = /^[a-z]$/; // 26个英文字母任何一个字母返回 true - 表示的是a 到z 的范围 console.log(reg.test('a')); console.log(reg.test('z')); console.log(reg.test(1)); console.log(reg.test('A')); // 字符组合 var reg1 = /^[a-zA-Z0-9_-]$/; // 26个英文字母(大写和小写都可以)任何一个字母返回 true console.log(reg1.test('a')); console.log(reg1.test('B')); console.log(reg1.test(8)); console.log(reg1.test('-')); console.log(reg1.test('_')); console.log(reg1.test('!')); console.log('----------------'); // 如果中括号里面有^ 表示取反的意思 千万和 我们边界符 ^ 别混淆 var reg2 = /^[^a-zA-Z0-9_-]$/; console.log(reg2.test('a')); console.log(reg2.test('B')); console.log(reg2.test(8)); console.log(reg2.test('-')); console.log(reg2.test('_')); console.log(reg2.test('!')); 量词// 量词符: 用来设定某个模式出现的次数 // 简单理解: 就是让下面的a这个字符重复多少次 // var reg = /^a$/; // * 相当于 &gt;= 0 可以出现0次或者很多次 // var reg = /^a*$/; // console.log(reg.test('')); // console.log(reg.test('a')); // console.log(reg.test('aaaa')); // + 相当于 &gt;= 1 可以出现1次或者很多次 // var reg = /^a+$/; // console.log(reg.test('')); // false // console.log(reg.test('a')); // true // console.log(reg.test('aaaa')); // true // ? 相当于 1 || 0 // var reg = /^a?$/; // console.log(reg.test('')); // true // console.log(reg.test('a')); // true // console.log(reg.test('aaaa')); // false // &#123;3 &#125; 就是重复3次 // var reg = /^a&#123;3&#125;$/; // console.log(reg.test('')); // false // console.log(reg.test('a')); // false // console.log(reg.test('aaaa')); // false // console.log(reg.test('aaa')); // true // &#123;3, &#125; 大于等于3 var reg = /^a&#123;3,&#125;$/; console.log(reg.test('')); // false console.log(reg.test('a')); // false console.log(reg.test('aaaa')); // true console.log(reg.test('aaa')); // true // &#123;3,16&#125; 大于等于3 并且 小于等于16 var reg = /^a&#123;3,6&#125;$/; console.log(reg.test('')); // false console.log(reg.test('a')); // false console.log(reg.test('aaaa')); // true console.log(reg.test('aaa')); // true console.log(reg.test('aaaaaaa')); // false 用户名验证// 量词是设定某个模式出现的次数 var reg = /^[a-zA-Z0-9_-]&#123;6,16&#125;$/; // 这个模式用户只能输入英文字母 数字 下划线 短横线但是有边界符和[] 这就限定了只能多选1 // &#123;6,16&#125; 中间不要有空格 // console.log(reg.test('a')); // console.log(reg.test('8')); // console.log(reg.test('18')); // console.log(reg.test('aa')); // console.log('-------------'); // console.log(reg.test('andy-red')); // console.log(reg.test('andy_red')); // console.log(reg.test('andy007')); // console.log(reg.test('andy!007')); var uname = document.querySelector('.uname'); var span = document.querySelector('span'); uname.onblur = function() &#123; if (reg.test(this.value)) &#123; console.log('正确的'); span.className = 'right'; span.innerHTML = '用户名格式输入正确'; &#125; else &#123; console.log('错误的'); span.className = 'wrong'; span.innerHTML = '用户名格式输入不正确'; &#125; &#125; 括号总结// 中括号 字符集合.匹配方括号中的任意字符. // var reg = /^[abc]$/; // a 也可以 b 也可以 c 可以 a ||b || c // 大括号 量词符. 里面表示重复次数 // var reg = /^abc&#123;3&#125;$/; // 它只是让c重复三次 abccc // console.log(reg.test('abc')); // console.log(reg.test('abcabcabc')); // console.log(reg.test('abccc')); // 小括号 表示优先级 var reg = /^(abc)&#123;3&#125;$/; // 它是让abc重复三次 console.log(reg.test('abc')); console.log(reg.test('abcabcabc')); console.log(reg.test('abccc')); 座机号码验证// 座机号码验证: 全国座机号码 两种格式: 010-12345678 或者 0530-1234567 // 正则里面的或者 符号 | // var reg = /^\\d&#123;3&#125;-\\d&#123;8&#125;|\\d&#123;4&#125;-\\d&#123;7&#125;$/; var reg = /^\\d&#123;3,4&#125;-\\d&#123;7,8&#125;$/; 替换// 替换 replace // var str = 'andy和red'; // // var newStr = str.replace('andy', 'baby'); // var newStr = str.replace(/andy/, 'baby'); // console.log(newStr); var text = document.querySelector('textarea'); var btn = document.querySelector('button'); var div = document.querySelector('div'); btn.onclick = function() &#123; div.innerHTML = text.value.replace(/激情|gay/g, '**'); &#125;","permalink":"https://codermino.github.io/2020/08/17/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","photos":[]},{"tags":[{"name":"js学习笔记之数组方法","slug":"js学习笔记之数组方法","permalink":"https://codermino.github.io/tags/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"}],"title":"js学习笔记之数组方法","date":"2020/08/17","text":"原型// 1. 构造函数的问题. function Star(uname, age) &#123; this.uname = uname; this.age = age; // this.sing = function() &#123; // console.log('我会唱歌'); // &#125; &#125; Star.prototype.sing = function() &#123; console.log('我会唱歌'); &#125; var ldh = new Star('刘德华', 18); var zxy = new Star('张学友', 19); console.log(ldh.sing === zxy.sing); // console.dir(Star); ldh.sing(); zxy.sing(); // 2. 一般情况下,我们的公共属性定义到构造函数里面, 公共的方法我们放到原型对象身上 对象原型function Star(uname, age) &#123; this.uname = uname; this.age = age; &#125; Star.prototype.sing = function() &#123; console.log('我会唱歌'); &#125; var ldh = new Star('刘德华', 18); var zxy = new Star('张学友', 19); ldh.sing(); console.log(ldh); // 对象身上系统自己添加一个 __proto__ 指向我们构造函数的原型对象 prototype console.log(ldh.__proto__ === Star.prototype); // 方法的查找规则: 首先先看ldh 对象身上是否有 sing 方法,如果有就执行这个对象上的sing // 如果么有sing 这个方法,因为有__proto__ 的存在,就去构造函数原型对象prototype身上去查找sing这个方法 原型constructorfunction Star(uname, age) &#123; this.uname = uname; this.age = age; &#125; // 很多情况下,我们需要手动的利用constructor 这个属性指回 原来的构造函数 // Star.prototype.sing = function() &#123; // console.log('我会唱歌'); // &#125;; // Star.prototype.movie = function() &#123; // console.log('我会演电影'); // &#125; Star.prototype = &#123; // 如果我们修改了原来的原型对象,给原型对象赋值的是一个对象,则必须手动的利用constructor指回原来的构造函数 constructor: Star, sing: function() &#123; console.log('我会唱歌'); &#125;, movie: function() &#123; console.log('我会演电影'); &#125; &#125; var ldh = new Star('刘德华', 18); var zxy = new Star('张学友', 19); console.log(Star.prototype); console.log(ldh.__proto__); console.log(Star.prototype.constructor); console.log(ldh.__proto__.constructor); 原型链function Star(uname, age) &#123; this.uname = uname; this.age = age; &#125; Star.prototype.sing = function() &#123; console.log('我会唱歌'); &#125; var ldh = new Star('刘德华', 18); // 1. 只要是对象就有__proto__ 原型, 指向原型对象 console.log(Star.prototype); console.log(Star.prototype.__proto__ === Object.prototype); // 2.我们Star原型对象里面的__proto__原型指向的是 Object.prototype console.log(Object.prototype.__proto__); // 3. 我们Object.prototype原型对象里面的__proto__原型 指向为 null 原型链查找规则function Star(uname, age) &#123; this.uname = uname; this.age = age; &#125; Star.prototype.sing = function() &#123; console.log('我会唱歌'); &#125; Star.prototype.sex = '女'; // Object.prototype.sex = '男'; var ldh = new Star('刘德华', 18); ldh.sex = '男'; console.log(ldh.sex); console.log(Object.prototype); console.log(ldh); console.log(Star.prototype); console.log(ldh.toString()); 拓展方法// 原型对象的应用 扩展内置对象方法 Array.prototype.sum = function() &#123; var sum = 0; for (var i = 0; i &lt; this.length; i++) &#123; sum += this[i]; &#125; return sum; &#125;; var arr = [1, 2, 3]; console.log(arr.sum()); console.log(Array.prototype); var arr1 = new Array(11, 22, 33); console.log(arr1.sum()); call方法// call 方法 function fn(x, y) &#123; console.log('我想喝手磨咖啡'); console.log(this); console.log(x + y); &#125; var o = &#123; name: 'andy' &#125;; // fn(); // 1. call() 可以调用函数 // fn.call(); // 2. call() 可以改变这个函数的this指向 此时这个函数的this 就指向了o这个对象 fn.call(o, 1, 2); 借助构造函数继承属性// 借用父构造函数继承属性 // 1. 父构造函数 function Father(uname, age) &#123; // this 指向父构造函数的对象实例 this.uname = uname; this.age = age; &#125; // 2 .子构造函数 function Son(uname, age, score) &#123; // this 指向子构造函数的对象实例 Father.call(this, uname, age); this.score = score; &#125; var son = new Son('刘德华', 18, 100); console.log(son); 结束原型继承方法// 借用父构造函数继承属性 // 1. 父构造函数 function Father(uname, age) &#123; // this 指向父构造函数的对象实例 this.uname = uname; this.age = age; &#125; Father.prototype.money = function() &#123; console.log(100000); &#125;; // 2 .子构造函数 function Son(uname, age, score) &#123; // this 指向子构造函数的对象实例 Father.call(this, uname, age); this.score = score; &#125; // Son.prototype = Father.prototype; 这样直接赋值会有问题,如果修改了子原型对象,父原型对象也会跟着一起变化 Son.prototype = new Father(); // 如果利用对象的形式修改了原型对象,别忘了利用constructor 指回原来的构造函数 Son.prototype.constructor = Son; // 这个是子构造函数专门的方法 Son.prototype.exam = function() &#123; console.log('孩子要考试'); &#125; var son = new Son('刘德华', 18, 100); console.log(son); console.log(Father.prototype); console.log(Son.prototype.constructor); 类的本质// ES6 之前通过 构造函数+ 原型实现面向对象 编程 // (1) 构造函数有原型对象prototype // (2) 构造函数原型对象prototype 里面有constructor 指向构造函数本身 // (3) 构造函数可以通过原型对象添加方法 // (4) 构造函数创建的实例对象有__proto__ 原型指向 构造函数的原型对象 // ES6 通过 类 实现面向对象编程 class Star &#123; &#125; console.log(typeof Star); // 1. 类的本质其实还是一个函数 我们也可以简单的认为 类就是 构造函数的另外一种写法 // (1) 类有原型对象prototype console.log(Star.prototype); // (2) 类原型对象prototype 里面有constructor 指向类本身 console.log(Star.prototype.constructor); // (3)类可以通过原型对象添加方法 Star.prototype.sing = function() &#123; console.log('冰雨'); &#125; var ldh = new Star(); console.dir(ldh); // (4) 类创建的实例对象有__proto__ 原型指向 类的原型对象 console.log(ldh.__proto__ === Star.prototype); i = i + 1; i++ foreach方法// forEach 迭代(遍历) 数组 var arr = [1, 2, 3]; var sum = 0; arr.forEach(function(value, index, array) &#123; console.log('每个数组元素' + value); console.log('每个数组元素的索引号' + index); console.log('数组本身' + array); sum += value; &#125;) console.log(sum); filter方法// filter 筛选数组 var arr = [12, 66, 4, 88, 3, 7]; var newArr = arr.filter(function(value, index) &#123; // return value &gt;= 20; return value % 2 === 0; &#125;); console.log(newArr); some函数// some 查找数组中是否有满足条件的元素 // var arr = [10, 30, 4]; // var flag = arr.some(function(value) &#123; // // return value &gt;= 20; // return value &lt; 3; // &#125;); // console.log(flag); var arr1 = ['red', 'pink', 'blue']; var flag1 = arr1.some(function(value) &#123; return value === 'pink'; &#125;); console.log(flag1); // 1. filter 也是查找满足条件的元素 返回的是一个数组 而且是把所有满足条件的元素返回回来 // 2. some 也是查找满足条件的元素是否存在 返回的是一个布尔值 如果查找到第一个满足条件的元素就终止循环 foreach和some的区别var arr = ['red', 'green', 'blue', 'pink']; // 1. forEach迭代 遍历 // arr.forEach(function(value) &#123; // if (value == 'green') &#123; // console.log('找到了该元素'); // return true; // 在forEach 里面 return 不会终止迭代 // &#125; // console.log(11); // &#125;) // 如果查询数组中唯一的元素, 用some方法更合适, arr.some(function(value) &#123; if (value === 'green') &#123; console.log('找到了该元素'); return true; // 在some 里面 遇到 return true 就是终止遍历 迭代效率更高 &#125; console.log(11); &#125;); // arr.filter(function(value) &#123; // if (value == 'green') &#123; // console.log('找到了该元素'); // return true; // // filter 里面 return 不会终止迭代 // &#125; // console.log(11); // &#125;); trim方法删除两边的空格// trim 方法去除字符串两侧空格 var str = ' an dy '; console.log(str); var str1 = str.trim(); console.log(str1); var input = document.querySelector('input'); var btn = document.querySelector('button'); var div = document.querySelector('div'); btn.onclick = function() &#123; var str = input.value.trim(); if (str === '') &#123; alert('请输入内容'); &#125; else &#123; console.log(str); console.log(str.length); div.innerHTML = str; &#125; &#125; Object.keys遍历对象// 用于获取对象自身所有的属性 var obj = &#123; id: 1, pname: '小米', price: 1999, num: 2000 &#125;; var arr = Object.keys(obj); console.log(arr); arr.forEach(function(value) &#123; console.log(value); &#125;) Object.defineProperty() 定义新属性或修改原有的属性// Object.defineProperty() 定义新属性或修改原有的属性 var obj = &#123; id: 1, pname: '小米', price: 1999 &#125;; // 1. 以前的对象添加和修改属性的方式 // obj.num = 1000; // obj.price = 99; // console.log(obj); // 2. Object.defineProperty() 定义新属性或修改原有的属性 Object.defineProperty(obj, 'num', &#123; value: 1000, enumerable: true &#125;); console.log(obj); Object.defineProperty(obj, 'price', &#123; value: 9.9 &#125;); console.log(obj); Object.defineProperty(obj, 'id', &#123; // 如果值为false 不允许修改这个属性值 默认值也是false writable: false, &#125;); obj.id = 2; console.log(obj); Object.defineProperty(obj, 'address', &#123; value: '中国山东蓝翔技校xx单元', // 如果只为false 不允许修改这个属性值 默认值也是false writable: false, // enumerable 如果值为false 则不允许遍历, 默认的值是 false enumerable: false, // configurable 如果为false 则不允许删除这个属性 不允许在修改第三个参数里面的特性 默认为false configurable: false &#125;); console.log(obj); console.log(Object.keys(obj)); delete obj.address; console.log(obj); delete obj.pname; console.log(obj); Object.defineProperty(obj, 'address', &#123; value: '中国山东蓝翔技校xx单元', // 如果值为false 不允许修改这个属性值 默认值也是false writable: true, // enumerable 如果值为false 则不允许遍历, 默认的值是 false enumerable: true, // configurable 如果为false 则不允许删除这个属性 默认为false configurable: true &#125;); console.log(obj.address); get和set// 存取描述符 var store = &#123;name: 'xx'&#125;; var o = &#123;&#125;; Object.defineProperty(o, 'name', &#123; get: function() &#123;// 定义属性值，读取o.name时执行的函数 return store.name; &#125;, set: function(v) &#123; // 在这里可以搞事情，做一些判断。来决定是否进行赋值更改 store.name = v;// 定义赋值操作。在给o.name赋值时执行的函数。 &#125;, enumerable: true,// 是否可以被枚举。true时在for in循环中可以被枚举到 configurable: false// 特性是否可以被修改，如值是false，则不可逆，也就是之后无法再次更改任何特性信息 &#125;) console.log(o); o.name = 'zhangsan'; console.log(o);","permalink":"https://codermino.github.io/2020/08/17/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/","photos":[]},{"tags":[{"name":"js学习笔记之函数","slug":"js学习笔记之函数","permalink":"https://codermino.github.io/tags/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%87%BD%E6%95%B0/"}],"title":"js学习笔记之函数","date":"2020/08/17","text":"函数的this指向问题`&lt;button&gt;点击&lt;/button&gt;` `&lt;script&gt;` // 函数的不同调用方式决定了this 的指向不同 // 1. 普通函数 this 指向window function fn() &#123; console.log('普通函数的this' + this); &#125; window.fn(); // 2. 对象的方法 this指向的是对象 o var o = &#123; sayHi: function() &#123; console.log('对象方法的this:' + this); &#125; &#125; o.sayHi(); // 3. 构造函数 this 指向 ldh 这个实例对象 原型对象里面的this 指向的也是 ldh这个实例对象 function Star() &#123;&#125;; Star.prototype.sing = function() &#123; &#125; var ldh = new Star(); // 4. 绑定事件函数 this 指向的是函数的调用者 btn这个按钮对象 var btn = document.querySelector('button'); btn.onclick = function() &#123; console.log('绑定时间函数的this:' + this); &#125;; // 5. 定时器函数 this 指向的也是window window.setTimeout(function() &#123; console.log('定时器的this:' + this); &#125;, 1000); // 6. 立即执行函数 this还是指向window (function() &#123; console.log('立即执行函数的this' + this); &#125;)(); `&lt;/script&gt;` call函数,改变this指向// 改变函数内this指向 js提供了三种方法 call() apply() bind() // 1. call() var o = &#123; name: 'andy' &#125; function fn(a, b) &#123; console.log(this); console.log(a + b); &#125;; fn.call(o, 1, 2); // call 第一个可以调用函数 第二个可以改变函数内的this 指向 // call 的主要作用可以实现继承 function Father(uname, age, sex) &#123; this.uname = uname; this.age = age; this.sex = sex; &#125; function Son(uname, age, sex) &#123; Father.call(this, uname, age, sex); console.log(this.uname); &#125; var son = new Son('刘德华', 18, '男'); console.log(son); apply函数，改变this指向// 改变函数内this指向 js提供了三种方法 call() apply() bind() // 2. apply() 应用 运用的意思 var o = &#123; name: 'andy' &#125;; function fn(arr) &#123; console.log(this); console.log(arr); // 'pink' &#125;; fn.apply(o, ['pink']); // 1. 也是调用函数 第二个可以改变函数内部的this指向 // 2. 但是他的参数必须是数组(伪数组) // 3. apply 的主要应用 比如说我们可以利用 apply 借助于数学内置对象求数组最大值 // Math.max(); var arr = [1, 66, 3, 99, 4]; var arr1 = ['red', 'pink']; // var max = Math.max.apply(null, arr); var max = Math.max.apply(Math, arr); var min = Math.min.apply(Math, arr); console.log(max, min); bind函数改变this指向`&lt;button&gt;点击&lt;/button&gt;` `&lt;button&gt;点击&lt;/button&gt;` `&lt;button&gt;点击&lt;/button&gt;` `&lt;script&gt;` // 改变函数内this指向 js提供了三种方法 call() apply() bind() // 3. bind() 绑定 捆绑的意思 var o = &#123; name: 'andy' &#125;; function fn(a, b) &#123; console.log(this); console.log(a + b); &#125;; var f = fn.bind(o, 1, 2); f(); // 1. 不会调用原来的函数 可以改变原来函数内部的this 指向 // 2. 返回的是原函数改变this之后产生的新函数 // 3. 如果有的函数我们不需要立即调用,但是又想改变这个函数内部的this指向此时用bind // 4. 我们有一个按钮,当我们点击了之后,就禁用这个按钮,3秒钟之后开启这个按钮 // var btn1 = document.querySelector('button'); // btn1.onclick = function() &#123; // this.disabled = true; // 这个this 指向的是 btn 这个按钮 // // var that = this; // setTimeout(function() &#123; // // that.disabled = false; // 定时器函数里面的this 指向的是window // this.disabled = false; // 此时定时器函数里面的this 指向的是btn // &#125;.bind(this), 3000); // 这个this 指向的是btn 这个对象 // &#125; var btns = document.querySelectorAll('button'); for (var i = 0; i &lt; btns.length; i++) &#123; btns[i].onclick = function() &#123; this.disabled = true; setTimeout(function() &#123; this.disabled = false; &#125;.bind(this), 2000); &#125; &#125; `&lt;/script&gt;` callback高阶函数// 高阶函数- 函数可以作为参数传递 function fn(a, b, callback) &#123; console.log(a + b); callback &amp;&amp; callback(); &#125; fn(1, 2, function() &#123; console.log('我是最后调用的'); &#125;); $(\"div\").animate(&#123; left: 500 &#125;, function() &#123; $(\"div\").css(\"backgroundColor\", \"purple\"); &#125;) 闭包// 闭包（closure）指有权访问另一个函数作用域中变量的函数。 // 闭包: 我们fun 这个函数作用域 访问了另外一个函数 fn 里面的局部变量 num function fn() &#123; var num = 10; function fun() &#123; console.log(num); &#125; fun(); &#125; fn(); 闭包的作用// 闭包（closure）指有权访问另一个函数作用域中变量的函数。 // 一个作用域可以访问另外一个函数的局部变量 // 我们fn 外面的作用域可以访问fn 内部的局部变量 // 闭包的主要作用: 延伸了变量的作用范围 function fn() &#123; var num = 10; // function fun() &#123; // console.log(num); // &#125; // return fun; return function() &#123; console.log(num); &#125; &#125; var f = fn(); f(); // 类似于 // var f = function() &#123; // console.log(num); // &#125; // var f = function fun() &#123; // console.log(num); // &#125; 闭包的应用Demo// 闭包应用-计算打车价格 // 打车起步价13(3公里内), 之后每多一公里增加 5块钱. 用户输入公里数就可以计算打车价格 // 如果有拥堵情况,总价格多收取10块钱拥堵费 function fn() &#123;&#125;; fn(); var car = (function() &#123; var start = 13; // 起步价 局部变量 var total = 0; // 总价 局部变量 return &#123; // 正常的总价 price: function(n) &#123; if (n &lt;= 3) &#123; total = start; &#125; else &#123; total = start + (n - 3) * 5 &#125; return total; &#125;, // 拥堵之后的费用 yd: function(flag) &#123; return flag ? total + 10 : total; &#125; &#125; &#125;)(); console.log(car.price(5)); // 23 console.log(car.yd(true)); // 33 console.log(car.price(1)); // 13 console.log(car.yd(false)); // 13 let car2 = function() &#123; let start = 13; // 起步价 局部变量 let total = 0; // 总价 局部变量 return &#123; // 正常的总价 price: function(n) &#123; if (n &lt;= 3) &#123; total = start; &#125; else &#123; total = start + (n - 3) * 5 &#125; return total; &#125;, // 拥堵之后的费用 yd: function(flag) &#123; return flag ? total + 10 : total; &#125; &#125; &#125;; const &#123;price,yd&#125; = car2(); console.log(price(5)); console.log(yd(true)); console.log(price(1)); console.log(yd(false)); 利用递归遍历数组var data = [&#123; id: 1, name: '家电', goods: [&#123; id: 11, gname: '冰箱', goods: [&#123; id: 111, gname: '海尔' &#125;, &#123; id: 112, gname: '美的' &#125;, ] &#125;, &#123; id: 12, gname: '洗衣机' &#125;] &#125;, &#123; id: 2, name: '服饰' &#125;]; // 我们想要做输入id号,就可以返回的数据对象 // 1. 利用 forEach 去遍历里面的每一个对象 function getID(json, id) &#123; var o = &#123;&#125;; json.forEach(function(item) &#123; // console.log(item); // 2个数组元素 if (item.id === id) &#123; // console.log(item); o = item; // 2. 我们想要得里层的数据 11 12 可以利用递归函数 // 里面应该有goods这个数组并且数组的长度不为 0 &#125; else if (item.goods &amp;&amp; item.goods.length &gt; 0) &#123; o = getID(item.goods, id); &#125; &#125;); return o; &#125; console.log(getID(data, 1)); console.log(getID(data, 2)); console.log(getID(data, 11)); console.log(getID(data, 12)); console.log(getID(data, 111)); 浅拷贝// 浅拷贝只是拷贝一层, 更深层次对象级别的只拷贝引用. // 深拷贝拷贝多层, 每一级别的数据都会拷贝. var obj = &#123; id: 1, name: 'andy', msg: &#123; age: 18 &#125; &#125;; var o = &#123;&#125;; // for (var k in obj) &#123; // // k 是属性名 obj[k] 属性值 // o[k] = obj[k]; // &#125; // console.log(o); // o.msg.age = 20; // console.log(obj); console.log('--------------'); Object.assign(o, obj); console.log(o); o.msg.age = 20; console.log(obj); console.log('--------------'); Object.assign(o, obj); console.log(o); o.msg.age = 20; console.log(obj); let o2 = &#123;...obj&#125;; console.log(o2); o2.msg.age = 30; console.log(obj); 深拷贝// 深拷贝拷贝多层, 每一级别的数据都会拷贝. var obj = &#123; id: 1, name: 'andy', msg: &#123; age: 18 &#125;, color: ['pink', 'red'] &#125;; var o = &#123;&#125;; // 封装函数 function deepCopy(newobj, oldobj) &#123; for (var k in oldobj) &#123; // 判断我们的属性值属于那种数据类型 // 1. 获取属性值 oldobj[k] var item = oldobj[k]; // 2. 判断这个值是否是数组 if (item instanceof Array) &#123; newobj[k] = []; deepCopy(newobj[k], item) &#125; else if (item instanceof Object) &#123; // 3. 判断这个值是否是对象 newobj[k] = &#123;&#125;; deepCopy(newobj[k], item) &#125; else &#123; // 4. 属于简单数据类型 newobj[k] = item; &#125; &#125; &#125; deepCopy(o, obj); console.log(o); var arr = []; console.log(arr instanceof Object); o.msg.age = 20; console.log(obj); function deepCopy2(target)&#123; let copyed_objs = [];//此数组解决了循环引用和相同引用的问题，它存放已经递归到的目标对象 function _deepCopy(target)&#123; if((typeof target !== 'object')||!target)&#123;return target;&#125; for(let i= 0 ;i&lt;copyed_objs.length;i++)&#123; if(copyed_objs[i].target === target)&#123; return copyed_objs[i].copyTarget; &#125; &#125; let obj = &#123;&#125;; if(Array.isArray(target))&#123; obj = [];//处理target是数组的情况 &#125; copyed_objs.push(&#123;target:target,copyTarget:obj&#125;); Object.keys(target).forEach(key=&gt;&#123; if(obj[key])&#123; return;&#125; obj[key] = _deepCopy(target[key]); &#125;); return obj; &#125; return _deepCopy(target); &#125; let o2 = deepCopy2(o); console.log(o2); o2.msg.age = 20; console.log(obj);","permalink":"https://codermino.github.io/2020/08/17/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%87%BD%E6%95%B0/","photos":[]},{"tags":[{"name":"js学习笔记之类","slug":"js学习笔记之类","permalink":"https://codermino.github.io/tags/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%B1%BB/"}],"title":"js学习笔记之类","date":"2020/08/17","text":"创建类// 1. 创建类 class 创建一个 明星类 class Star &#123; constructor(uname, age) &#123; this.uname = uname; this.age = age; &#125; &#125; // 2. 利用类创建对象 new let ldh = new Star('刘德华', 18); let zxy = new Star('张学友', 20); console.log(ldh); console.log(zxy); (1) 通过class 关键字创建类, 类名我们还是习惯性定义首字母大写 (2) 类里面有个constructor 函数,可以接受传递过来的参数,同时返回实例对象 (3) constructor 函数 只要 new 生成实例时,就会自动调用这个函数, 如果我们不写这个函数,类也会自动生成这个函数 (4) 生成实例 new 不能省略 (5) 最后注意语法规范, 创建类 类名后面不要加小括号,生成实例 类名后面加小括号, 构造函数不需要加function 向类中添加方法// 1. 创建类 class 创建一个 明星类 class Star &#123; // 类的共有属性放到 constructor 里面 constructor(uname, age) &#123; this.uname = uname; this.age = age; &#125; sing(song) &#123; // console.log('我唱歌'); console.log(this.uname + song); &#125; &#125; // 2. 利用类创建对象 new var ldh = new Star('刘德华', 18); var zxy = new Star('张学友', 20); console.log(ldh); console.log(zxy); // (1) 我们类里面所有的函数不需要写function //(2) 多个函数方法之间不需要添加逗号分隔 ldh.sing('冰雨'); zxy.sing('李香兰'); 类的继承class Father &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; sum() &#123; console.log(this.x + this.y); &#125; &#125; class Son extends Father &#123; constructor(x, y) &#123; super(x, y); //调用了父类中的构造函数 &#125; &#125; var son = new Son(1, 2); var son1 = new Son(11, 22); son.sum(); son1.sum(); 调用父函数的方法// super 关键字调用父类普通函数 class Father &#123; say() &#123; return '我是爸爸'; &#125; &#125; class Son extends Father &#123; say() &#123; // console.log('我是儿子'); console.log(super.say() + '的儿子'); // super.say() 就是调用父类中的普通函数 say() &#125; &#125; var son = new Son(); son.say(); // 继承中的属性或者方法查找原则: 就近原则 // 1. 继承中,如果实例化子类输出一个方法,先看子类有没有这个方法,如果有就先执行子类的 // 2. 继承中,如果子类里面没有,就去查找父类有没有这个方法,如果有,就执行父类的这个方法(就近原则) 拓展子类的方法 // 父类有加法方法 class Father &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; sum() &#123; console.log(this.x + this.y); &#125; &#125; // 子类继承父类加法方法 同时 扩展减法方法 class Son extends Father &#123; constructor(x, y) &#123; // 利用super 调用父类的构造函数 // super 必须在子类this之前调用 super(x, y); this.x = x; this.y = y; &#125; subtract() &#123; console.log(this.x - this.y); &#125; &#125; var son = new Son(5, 3); son.subtract(); son.sum(); this指向问题`&lt;button&gt;点击&lt;/button&gt;` `&lt;script&gt;` var that; var _that; class Star &#123; constructor(uname, age) &#123; // constructor 里面的this 指向的是 创建的实例对象 that = this; console.log(this); this.uname = uname; this.age = age; // this.sing(); this.btn = document.querySelector('button'); this.btn.onclick = this.sing; &#125; sing() &#123; // 这个sing方法里面的this 指向的是 btn 这个按钮,因为这个按钮调用了这个函数 console.log(this); console.log(that.uname); // that里面存储的是constructor里面的this &#125; dance() &#123; // 这个dance里面的this 指向的是实例对象 ldh 因为ldh 调用了这个函数 _that = this; console.log(this); &#125; &#125; var ldh = new Star('刘德华'); console.log(that === ldh); ldh.dance(); console.log(_that === ldh); // 1. 在 ES6 中类没有变量提升，所以必须先定义类，才能通过类实例化对象 // 2. 类里面的共有的属性和方法一定要加this使用.","permalink":"https://codermino.github.io/2020/08/17/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%B1%BB/","photos":[]},{"tags":[{"name":"webstorm常用快捷键","slug":"webstorm常用快捷键","permalink":"https://codermino.github.io/tags/webstorm%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"}],"title":"webstorm常用快捷键","date":"2020/08/16","text":"Ctrl+Shift + Enter，语句完成 “！”，否定完成，输入表达式时按 “！”键 Ctrl+E，最近的文件 Ctrl+Shift+E，最近更改的文件 Shift+Click，可以关闭文件 `Ctrl+[ OR ]`，可以跑到大括号的开头与结尾 Ctrl+F12，可以显示当前文件的结构 Ctrl+F7，可以查询当前元素在当前文件中的引用，然后按 F3 可以选择 Ctrl+N，可以快速打开类 Ctrl+Shift+N，可以快速打开文件 Alt+Q，可以看到当前方法的声明 Ctrl+P，可以显示参数信息 Ctrl+Shift+Insert，可以选择剪贴板内容并插入 Alt+Insert，可以生成构造器/Getter/Setter等 Ctrl+Alt+V，可以引入变量。例如：new String(); 自动导入变量定义 Ctrl+Alt+T，可以把代码包在一个块内，例如：try/catch Ctrl+Enter，导入包，自动修正 Ctrl+Alt+L，格式化代码 Ctrl+Alt+I，将选中的代码进行自动缩进编排，这个功能在编辑 JSP 文件时也可以工作 Ctrl+Alt+O，优化导入的类和包 Ctrl+R，替换文本 Ctrl+F，查找文本 Ctrl+Shift+Space，自动补全代码 Ctrl+空格，代码提示（与系统输入法快捷键冲突） Ctrl+Shift+Alt+N，查找类中的方法或变量 Alt+Shift+C，最近的更改 Alt+Shift+Up/Down，上/下移一行 Shift+F6，重构 – 重命名 Ctrl+X，删除行 Ctrl+D，复制行 Ctrl+/或Ctrl+Shift+/，注释（//或者/**/） Ctrl+J，自动代码（例如：serr） Ctrl+Alt+J，用动态模板环绕 Ctrl+H，显示类结构图（类的继承层次） Ctrl+Q，显示注释文档 Alt+F1，查找代码所在位置 Alt+1，快速打开或隐藏工程面板 Ctrl+Alt+left/right，返回至上次浏览的位置 Alt+left/right，切换代码视图 Alt+Up/Down，在方法间快速移动定位 Ctrl+Shift+Up/Down，向上/下移动语句 F2 或 Shift+F2，高亮错误或警告快速定位 Tab，代码标签输入完成后，按 Tab，生成代码 Ctrl+Shift+F7，高亮显示所有该文本，按 Esc 高亮消失 Alt+F3，逐个往下查找相同文本，并高亮显示 Ctrl+Up/Down，光标中转到第一行或最后一行下 Ctrl+B/Ctrl+Click，快速打开光标处的类或方法（跳转到定义处） Ctrl+Alt+B，跳转到方法实现处 Ctrl+Shift+Backspace，跳转到上次编辑的地方 Ctrl+O，重写方法 Ctrl+Alt+Space，类名自动完成 Ctrl+Alt+Up/Down，快速跳转搜索结果 Ctrl+Shift+J，整合两行 Alt+F8，计算变量值 Ctrl+Shift+V，可以将最近使用的剪贴板内容选择插入到文本 Ctrl+Alt+Shift+V，简单粘贴 Shift+Esc，不仅可以把焦点移到编辑器上，而且还可以隐藏当前（或最后活动的）工具窗口 F12，把焦点从编辑器移到最近使用的工具窗口 Shift+F1，要打开编辑器光标字符处使用的类或者方法 Java 文档的浏览器 Ctrl+W，可以选择单词继而语句继而行继而函数 Ctrl+Shift+W，取消选择光标所在词 Alt+F7，查找整个工程中使用地某一个类、方法或者变量的位置 Ctrl+I，实现方法 Ctrl+Shift+U，大小写转化 Ctrl+Y，删除当前行 Shift+Enter，向下插入新行 psvm/sout，main/System.out.println(); Ctrl+J，查看更多 Ctrl+Shift+F，全局查找 Ctrl+F，查找/Shift+F3，向上查找/F3，向下查找 Ctrl+Shift+S，高级搜索 Ctrl+U，转到父类 Ctrl+Alt+S，打开设置对话框 Alt+Shift+Inert，开启/关闭列选择模式 Ctrl+Alt+Shift+S，打开当前项目/模块属性 Ctrl+G，定位行 Alt+Home，跳转到导航栏 Ctrl+Enter，上插一行 Ctrl+Backspace，按单词删除 Ctrl+”+/-”，当前方法展开、折叠 Ctrl+Shift+”+/-”，全部展开、折叠 【调试部分、编译】 Ctrl+F2，停止 Alt+Shift+F9，选择 Debug Alt+Shift+F10，选择 Run Ctrl+Shift+F9，编译 Ctrl+Shift+F10，运行 Ctrl+Shift+F8，查看断点 F8，步过 F7，步入 Shift+F7，智能步入 Shift+F8，步出 Alt+Shift+F8，强制步过 Alt+Shift+F7，强制步入 Alt+F9，运行至光标处 Ctrl+Alt+F9，强制运行至光标处 F9，恢复程序 Alt+F10，定位到断点 Ctrl+F8，切换行断点 Ctrl+F9，生成项目 Alt+1，项目 Alt+2，收藏 Alt+6，TODO Alt+7，结构 Ctrl+Shift+C，复制路径 Ctrl+Alt+Shift+C，复制引用，必须选择类名 Ctrl+Alt+Y，同步 Ctrl+~，快速切换方案（界面外观、代码风格、快捷键映射等菜单） Shift+F12，还原默认布局 Ctrl+Shift+F12，隐藏/恢复所有窗口 Ctrl+F4，关闭 Ctrl+Shift+F4，关闭活动选项卡 Ctrl+Tab，转到下一个拆分器 Ctrl+Shift+Tab，转到上一个拆分器 【重构】 Ctrl+Alt+Shift+T，弹出重构菜单 Shift+F6，重命名 F6，移动 F5，复制 Alt+Delete，安全删除 Ctrl+Alt+N，内联 【查找】 Ctrl+F，查找 Ctrl+R，替换 F3，查找下一个 Shift+F3，查找上一个 Ctrl+Shift+F，在路径中查找 Ctrl+Shift+R，在路径中替换 Ctrl+Shift+S，搜索结构 Ctrl+Shift+M，替换结构 Alt+F7，查找用法 Ctrl+Alt+F7，显示用法 Ctrl+F7，在文件中查找用法 Ctrl+Shift+F7，在文件中高亮显示用法","permalink":"https://codermino.github.io/2020/08/16/webstorm%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/","photos":[]},{"tags":[{"name":"computed的get和set","slug":"computed的get和set","permalink":"https://codermino.github.io/tags/computed%E7%9A%84get%E5%92%8Cset/"}],"title":"computed的get和set","date":"2020/08/15","text":"计算属性的一般使用(双向绑定)&lt;h1&gt;&#123;&#123;fullName&#125;&#125;&lt;/h1&gt; &lt;label&gt; &lt;input type=\"text\" v-model=\"firstName\"&gt; &lt;/label&gt; &lt;label&gt; &lt;input type=\"text\" v-model=\"lastName\"&gt; &lt;/label&gt; computed: &#123; fullName() &#123; return this.firstName + ' ' + this.lastName; &#125; &#125;, 计算属性的一般使用(单向绑定)&lt;h1&gt;&#123;&#123;fullName&#125;&#125;&lt;/h1&gt; &lt;button @click=\"fullName = 'sun he'\"&gt;changename&lt;/button&gt; computed: &#123; fullName: &#123; get: function () &#123; return this.firstName + ' ' + this.lastName &#125;, set: function (newValue) &#123; var names = newValue.split(' '); this.firstName = names[0]; this.lastName = names[names.length - 1]; &#125; &#125; &#125;","permalink":"https://codermino.github.io/2020/08/15/computed%E7%9A%84get%E5%92%8Cset/","photos":[]},{"tags":[{"name":"vue别名和波浪号的使用","slug":"vue别名和波浪号的使用","permalink":"https://codermino.github.io/tags/vue%E5%88%AB%E5%90%8D%E5%92%8C%E6%B3%A2%E6%B5%AA%E5%8F%B7%E7%9A%84%E4%BD%BF%E7%94%A8/"}],"title":"vue别名和波浪号的使用","date":"2020/08/14","text":"使用方法使用别名一般就三种情况：在js中用，在css中用，在html文档内用js中用，最简单: import &#123;getName&#125; from '@/util/name' css中使用，需要加入“~”，并且不要写成字符串： &#123; background: url(~@/assets/img/04_2.jpg); background: url('~@/assets/img/04_2.jpg');//错了，这里有个坑，不能写成字符串，我就是因为这样写错了 &#125; html中使用，可以加入‘’也可以不加入‘’。 `&lt;img class=\"pic-404__child left\" src=\"@/assets/404_images/404_cloud.png\" alt=\"404\"&gt;` 在引入文件的时候，路径前面需要加上”~”。 @import '~@/css/index.css' tip: 图片以及一些静态资源尽量放入src/assets目录内，不要放入static目录内，访问不易出错。以@/assets/……方式访问。 在写路径时候，尽量不要使用绝对路径，请使用@别名方式访问资源。","permalink":"https://codermino.github.io/2020/08/14/vue%E5%88%AB%E5%90%8D%E5%92%8C%E6%B3%A2%E6%B5%AA%E5%8F%B7%E7%9A%84%E4%BD%BF%E7%94%A8/","photos":[]},{"tags":[{"name":"yield和return区别","slug":"yield和return区别","permalink":"https://codermino.github.io/tags/yield%E5%92%8Creturn%E5%8C%BA%E5%88%AB/"}],"title":"yield和return区别","date":"2020/08/14","text":"迭代器与可迭代对象开始之前，先理解一下迭代器与可迭代对象，因为yield其实是一种特殊的迭代器，不过这种迭代器更加优雅。 可迭代对象//可迭代对象：列表为例 s = 'ABC' l = list(s) print(l) ['A', 'B', 'C'] 迭代器# 迭代器对象l1 s = 'ABC' l = list(s) l1 = iter(l) print(l1) # 取出迭代器容器中的值，没有值后就抛出异常 print(next(l1)) print(next(l1)) print(next(l1)) print(next(l1)) &lt;list_iterator object at 0x0000020D793D95C0&gt; A B C StopIteration 上面案例中l是一个列表，是一个可迭代对象l1是一个迭代器，直接打印，结果是&lt;list_iterator object at 0x0000020D793D95C0&gt;，访问其中的值可以使用for循环或者next函数，所有值都被访问后，最后会抛出StopIteration异常 关于迭代器与可迭代对象参考我另一篇博文，里面有详细解释：https://blog.csdn.net/u011318077/article/details/93754013 yield生成器就是一个优雅的迭代器，访问也会用到next函数，理解迭代器后可以更轻松的理解yield生成器的执行过程和原理。 yield简单案例及执行步骤下面进入正题，如果你还没有对yield有个初步分认识，那么你先把yield看做“return”，这个是直观的，它首先是个return，普通的return是什么意思，就是在程序中返回某个值，返回之后程序就不再往下运行了。看做return之后再把它看做一个是生成器（generator）的一部分（带yield的函数才是真正的迭代器），好了，如果你对这些不明白的话，那先把yield看做return,然后直接看下面的程序，你就会明白yield的全部意思了(只是先当做return，本质向后看就会明白)。 先看一个普通函数 // 一个普通函数： def foo(): print('Starting.....') // 调用函数，直接执行语句 g = foo() print(\"*\" * 100) Starting..... **************************************************** 生成器函数 // 包含yield关键字，就变成了生成器函数 //调用函数并不会执行语句 def foo(): print('Starting.....') while True: res = yield 4 print(\"res:\", res) // 下面调用函数并没有执行，可以先将后面的语句注释掉 // 逐行运行代码观察效果 g = foo() print(\"第一次调用执行结果：\") print(next(g)) print(\"*\" * 100) print(\"第二次调用执行结果：\") print(next(g)) print(\"*\" * 100） 第一次调用执行结果： Starting..... 4 ******************************************************************** 第二次调用执行结果： res: None 4 ******************************************************************** 下面解释代码运行顺序，相当于代码单步调试()：程序开始执行以后，因为foo函数中有yield关键字，所以foo函数并不会真的执行，而是先得到一个生成器g(相当于一个对象)，函数的一个状态，函数相当于暂停了执行第一次调用，直到遇到next方法，foo函数正式开始执行，先执行foo函数中的print方法，然后进入while循环程序遇到yield关键字，然后把yield想想成return,return了一个4之后，程序停止，但是，程序只是返回了一个值4，并没有执行将4赋值给res操作，此时next(g)语句执行完成，所以第一次调用后的结果有两行（第一个是while上面的print的结果,第二个是return出的结果）也就是执行print(next(g))先调用函数，最后打印出了返回值4程序执行print(“” * 100)，输出100个执行第二次调用，又开始执行下面的print(next(g)),这个时候和上面那个差不多，不过不同的是，这个时候是从刚才那个next程序停止的地方开始执行的，也就是要执行res的赋值操作语句，这时候要注意，yield 4返回值4后就停止了，并没有赋值给前面的res, （因为刚才那个是return出去了，并没有给赋值操作的左边传参数），此时代码实际是从print(“res:”, res)开始执行，这个时候res赋值是空，是None,所以接着下面的输出就是res:None,程序会继续在while里执行，又一次碰到yield,这个时候同样return出4，然后程序停止，print函数输出的4就是这次return出的4.到这里你可能就明白yield和return的关系和区别了，带yield的函数是一个生成器，而不是一个函数了，这个生成器有一个函数就是next函数，next就相当于“下一步”生成哪个数，这一次的next开始的地方是接着上一次的next停止的地方执行的，所以调用next的时候，生成器并不会从foo函数的开始执行，只是接着上一步停止的地方开始，然后遇到yield后，return出要生成的数，此步就结束。 总结上面的foo()就是一个生成器函数，当一个生成器函数调用yield，生成器函数的“状态”会被冻结，所有的变量的值会被保留下来，下一行要执行的代码的位置也会被记录，就是yield这行代码结束的位置直到再次调用next()。一旦next()再次被调用，生成器函数会从它上次离开的地方开始。如果永远不调用next()，yield保存的状态就被无视了。 generator是用来产生一系列值的，yield则像是generator函数的返回结果，(yield也可以看似return)，yield唯一所做的另一件事就是保存一个generator函数的状态 yield和return的区别，return执行后会继续执行后面的代码，但是yield会停止之后的代码继续执行，注意，只是停止生成器函数内部的代码，生成器函数外部代码不受影响 generator就是一个特殊类型的迭代器（iterator）和迭代器相似，我们可以通过使用next()来从generator中获取下一个值 yield中的send函数yield生成器函数中另外一重要函数就是send(），可以传入一个值作为返回值，看下面案例，第二次调用时候传入数字7 # 包含yield关键字，就变成了生成器函数 def foo(): print('Starting.....') while True: res = yield 4 print(\"res:\", res) # 下面调用函数并没有执行，可以先将后面的语句注释掉 # 逐行运行代码观察效果 g = foo() print(\"第一次调用执行结果：\") print(next(g)) print(\"*\" * 100) print(\"第二次调用执行结果(传入参数)：\") print(g.send(7)) print(\"*\" * 100) print(\"第三次调用执行结果：\") print(next(g)) print(\"*\" * 100) 第一次调用执行结果： Starting..... 4 ***************************************************************** 第二次调用执行结果(传入参数)： res: 7 4 ****************************************************************** 第三次调用执行结果： res: None 4 ****************************************************************** send函数的概念：003案例中第二次调用时res的值为什么是None，这个变成了7，到底为什么？这是因为，send是发送一个参数给res的，因为上面讲到，return的时候，并没有把4赋值给res，下次执行的时候只好继续执行赋值操作，只好赋值为None了，而如果用send的话，开始执行的时候，先接着上一次（return 4之后）执行，先把7赋值给了res,然后执行next的作用，遇见下一回的yield，return出结果后结束（return的结果都是4，每次代码最后的结果都是4）。 上面代码执行步骤： 程序执行g.send(7)，程序会从yield关键字那一行继续向下运行，send会把7这个值赋值给res变量 由于send方法中包含next()方法，所以程序会继续向下运行执行print方法，然后再次进入while循环 程序执行再次遇到yield关键字，yield会返回后面的值后，程序再次暂停，直到再次调用next方法或send方法。 深层次补充：(上面的案例描述只是为了容易理解，描述为暂停和赋值)比如说“send方法中包含next()”send先赋值然后在执行next，从一些代码直观上来讲好像是这样，但其实并不是，第一，其实并不是赋值，第二，底层send和next其实都是调用gen_send_ex(PyGenObject *gen,PyObject *arg,int exc)这个函数，只是第二个参数不一样，send也不一定要带参数，尤其是第一次使用send来启动生成器，send带参数还是不允许的。如果对中断了解的话，其实不要把这个当成return来看，因为根本就不是，应该当成中断来理解，因为底层的实现就是中断的原理，保存栈帧，加载栈帧。 yield的好处是什么？通过上面的阅读和敲代码已经理解了什么是yield，和整个执行原理都应该很清楚了，单究竟为什么要使用yield，而不是用return？？？ 我们以列表list为例，为什么用这个生成器，是因为如果用List的话，会占用更大的空间，比如说取0,1,2,3,4,5,6…1000，下面举例，只取到10,1000结果太长了 for n in range(10): a=n print(a) # 相当于return a print(\"*\" * 100) 0 1 2 3 4 5 6 7 8 9 ``` #### 生成器实现上面功能 ```markdown //生成器实现 def foo(num): print(\"starting...\") while num&lt;10: num=num+1 yield num for n in foo(0): print(n) starting... 1 2 3 4 5 6 7 8 9 10 上面两种方式都可以得到0-10之间的数字，但是占用内存不同： 第一种直接使用for循环：for循环运行时，所有的0-10之间数字都存在内存之中需要消耗极大的内存，如果数字是10000，可能for循环直接就将电脑内存消耗完了后面的代码，其它程序就无内存可用了 第二种，虽然也是for循环，但是内部加入了yield：for循环每次调用时，yield生成器(generator)能够迭代的关键是它有一个next()方法，工作原理就是通过重复调用next()方法，直到捕获一个异常,for循环自动结束 每次执行到yield，因为底层的实现就是中断的原理，保存栈帧，加载栈帧。 每次执行结束内存释放，执行的时候占用一点内存，消耗的内存资源就很少 上面for循环执行过程，并没有写next函数，其实自动调用的next函数(参考迭代器与迭代对象中详细解释)： for循环执行过程： 1、调用可迭代对象的iter方法返回一个迭代器对象（iterator）2、不断调用迭代器的next方法返回元素3、直到迭代完成后，处理StopIteration异常 yield的好处总结：1、不会将所有数据取出来存入内存中；而是返回了一个对象；可以通过对象获取数据；用多少取多少，可以节省内容空间。2、除了能返回一个值，还不会终止循环的运行；3、每次执行到yield，因为底层的实现就是中断的原理，保存栈帧，加载栈帧。4、每次执行结束内存释放，执行的时候占用一点内存，消耗的内存资源就很少 补充：1、通常yield都是放在一个函数中，该函数就变成了生成器函数，该函数就变成了一个迭代器2、生成器函数一般都是通过for循环调用，for循环自带next方法3、分布式爬虫会经常使用yield,yield直接放在for循环的内部4、爬虫代码运行时候，for循环自动调用next方法，yield就会不断执行，直到爬取结束5、使用yield也会大大减少爬虫运行时候的内存消耗","permalink":"https://codermino.github.io/2020/08/14/yield%E5%92%8Creturn%E5%8C%BA%E5%88%AB/","photos":[]},{"tags":[{"name":"mysql知识点总结和应用4","slug":"mysql知识点总结和应用4","permalink":"https://codermino.github.io/tags/mysql%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E5%92%8C%E5%BA%94%E7%94%A84/"}],"title":"mysql知识点总结和应用4","date":"2020/08/14","text":"触发器介绍触发器是与表有关的数据库对象，指在 insert/update/delete 之前或之后，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性 , 日志记录 , 数据校验等操作 。 使用别名 OLD 和 NEW 来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。 触发器类型 NEW 和 OLD的使用 INSERT 型触发器 NEW 表示将要或者已经新增的数据 UPDATE 型触发器 OLD 表示修改之前的数据 , NEW 表示将要或已经修改后的数据 DELETE 型触发器 OLD 表示将要或者已经删除的数据 创建触发器create trigger trigger_name before/after insert/update/delete on tbl_name [ for each row ] -- 行级触发器 begin trigger_stmt ; end; 通过触发器记录 emp 表的数据变更日志 , 包含增加, 修改 , 删除 ; 首先创建一张日志表 : create table emp_logs( id int(11) not null auto_increment, operation varchar(20) not null comment '操作类型, insert/update/delete', operate_time datetime not null comment '操作时间', operate_id int(11) not null comment '操作表的ID', operate_params varchar(500) comment '操作参数', primary key(`id`) )engine=innodb default charset=utf8; 创建 insert 型触发器，完成插入数据时的日志记录 : DELIMITER $ create trigger emp_logs_insert_trigger after insert on emp for each row begin insert into emp_logs (id,operation,operate_time,operate_id,operate_params) values(null,'insert',now(),new.id,concat('插入后(id:',new.id,', name:',new.name,', age:',new.age,', salary:',new.salary,')')); end $ DELIMITER ; 创建 update 型触发器，完成更新数据时的日志记录 : DELIMITER $ create trigger emp_logs_update_trigger after update on emp for each row begin insert into emp_logs (id,operation,operate_time,operate_id,operate_params) values(null,'update',now(),new.id,concat('修改前(id:',old.id,', name:',old.name,', age:',old.age,', salary:',old.salary,') , 修改后(id',new.id, 'name:',new.name,', age:',new.age,', salary:',new.salary,')')); end $ DELIMITER ; 创建delete 行的触发器 , 完成删除数据时的日志记录 : DELIMITER $ create trigger emp_logs_delete_trigger after delete on emp for each row begin insert into emp_logs (id,operation,operate_time,operate_id,operate_params) values(null,'delete',now(),old.id,concat('删除前(id:',old.id,', name:',old.name,', age:',old.age,', salary:',old.salary,')')); end $ DELIMITER ; 删除触发器drop trigger [schema_name.]trigger_name 如果没有指定 schema_name，默认为当前数据库 。 查看触发器可以通过执行 SHOW TRIGGERS 命令查看触发器的状态、语法等信息。 show triggers ；","permalink":"https://codermino.github.io/2020/08/14/mysql%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E5%92%8C%E5%BA%94%E7%94%A84/","photos":[]},{"tags":[{"name":"mysql知识点总结和应用3","slug":"mysql知识点总结和应用3","permalink":"https://codermino.github.io/tags/mysql%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E5%92%8C%E5%BA%94%E7%94%A83/"}],"title":"mysql知识点总结和应用3","date":"2020/08/14","text":"存储过程和函数概述存储过程和函数是 事先经过编译并存储在数据库中的一段 SQL 语句的集合，调用存储过程和函数可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。 ​ 存储过程和函数的区别在于函数必须有返回值，而存储过程没有。 ​ 函数 ： 是一个有返回值的过程 ； ​ 过程 ： 是一个没有返回值的函数 ； 创建存储过程CREATE PROCEDURE procedure_name ([proc_parameter[,...]]) begin -- SQL语句 end ; 示例： delimiter $ create procedure pro_test1() begin select 'Hello Mysql' ; end$ delimiter ; 知识小贴士 DELIMITER 该关键字用来声明SQL语句的分隔符 , 告诉 MySQL 解释器，该段命令是否已经结束了，mysql是否可以执行了。 默认情况下，delimiter是分号;。在命令行客户端中， 如果有一行命令以分号结束，那么回车后，mysql将会执行该命令。 调用存储过程call procedure_name() ; 查看存储过程-- 查询db_name数据库中的所有的存储过程 select name from mysql.proc where db='db_name'; -- 查询存储过程的状态信息 show procedure status; -- 查询某个存储过程的定义 show create procedure test.pro_test1 \\G; 删除存储过程DROP PROCEDURE [IF EXISTS] sp_name ； 语法存储过程是可以编程的，意味着可以使用变量，表达式，控制结构 ， 来完成比较复杂的功能。 变量DECLARE通过 DECLARE 可以定义一个局部变量，该变量的作用范围只能在 BEGIN…END 块中。 DECLARE var_name[,...] type [DEFAULT value] delimiter $ create procedure pro_test2() begin declare num int default 5; select num+ 10; end$ delimiter ; SET直接赋值使用 SET，可以赋常量或者赋表达式，具体语法如下： SET var_name = expr [, var_name = expr] ... DELIMITER $ CREATE PROCEDURE pro_test3() BEGIN DECLARE NAME VARCHAR(20); SET NAME = 'MYSQL'; SELECT NAME ; END$ DELIMITER ; 也可以通过select … into 方式进行赋值操作 : DELIMITER $ CREATE PROCEDURE pro_test5() BEGIN declare countnum int; select count(*) into countnum from city; select countnum; END$ DELIMITER ; if条件判断 if search_condition then statement_list [elseif search_condition then statement_list] ... [else statement_list] end if; 根据定义的身高变量，判定当前身高的所属的身材类型 180 及以上 ———-&gt; 身材高挑 170 - 180 ———&gt; 标准身材 170 以下 ———-&gt; 一般身材 delimiter $ create procedure pro_test6() begin declare height int default 175; declare description varchar(50); if height &gt;= 180 then set description = '身材高挑'; elseif height &gt;= 170 and height &lt; 180 then set description = '标准身材'; else set description = '一般身材'; end if; select description ; end$ delimiter ; 传递参数 create procedure procedure_name([in/out/inout] 参数名 参数类型) ... IN : 该参数可以作为输入，也就是需要调用方传入值 , 默认 OUT: 该参数作为输出，也就是该参数可以作为返回值 INOUT: 既可以作为输入参数，也可以作为输出参数 小知识 @description : 这种变量要在变量名称前面加上“@”符号，叫做用户会话变量， 代表整个会话过程他都是有作用的，这个类似于全局变量一样。 @@global.sort_buffer_size : 这种在变量前加上 “@@” 符号, 叫做 系统变量 case结构方式一 : CASE case_value WHEN when_value THEN statement_list [WHEN when_value THEN statement_list] ... [ELSE statement_list] END CASE; 方式二 : CASE WHEN search_condition THEN statement_list [WHEN search_condition THEN statement_list] ... [ELSE statement_list] END CASE; 给定一个月份, 然后计算出所在的季度 delimiter $ create procedure pro_test9(month int) begin declare result varchar(20); case when month &gt;= 1 and month &lt;=3 then set result = '第一季度'; when month &gt;= 4 and month &lt;=6 then set result = '第二季度'; when month &gt;= 7 and month &lt;=9 then set result = '第三季度'; when month &gt;= 10 and month &lt;=12 then set result = '第四季度'; end case; select concat('您输入的月份为 :', month , ' , 该月份为 : ' , result) as content ; end$ delimiter ; while循环while search_condition do statement_list end while; 计算从1加到n的值 delimiter $ create procedure pro_test8(n int) begin declare total int default 0; declare num int default 1; while num&lt;=n do set total = total + num; set num = num + 1; end while; select total; end$ delimiter ; repeat结构有条件的循环控制语句, 当满足条件的时候退出循环 。while 是满足条件才执行，repeat 是满足条件就退出循环。 REPEAT statement_list UNTIL search_condition END REPEAT; 计算从1加到n的值 delimiter $ create procedure pro_test10(n int) begin declare total int default 0; repeat set total = total + n; set n = n - 1; until n=0 end repeat; select total ; end$ delimiter ; loop语句LOOP 实现简单的循环，退出循环的条件需要使用其他的语句定义，通常可以使用 LEAVE 语句实现. [begin_label:] LOOP statement_list END LOOP [end_label] 如果不在 statement_list 中增加退出循环的语句，那么 LOOP 语句可以用来实现简单的死循环。 leave语句用来从标注的流程构造中退出，通常和 BEGIN … END 或者循环一起使用。下面是一个使用 LOOP 和 LEAVE 的简单例子 , 退出循环： delimiter $ CREATE PROCEDURE pro_test11(n int) BEGIN declare total int default 0; ins: LOOP IF n &lt;= 0 then leave ins; END IF; set total = total + n; set n = n - 1; END LOOP ins; select total; END$ delimiter ; 存储函数CREATE FUNCTION function_name([param type ... ]) RETURNS type BEGIN ... END; 案例 :定义一个存储过程, 请求满足条件的总记录数 ; delimiter $ create function count_city(countryId int) returns int begin declare cnum int ; select count(*) into cnum from city where country_id = countryId; return cnum; end$ delimiter ; 调用 select count_city(1); select count_city(2); 删除 drop function fun_name;","permalink":"https://codermino.github.io/2020/08/14/mysql%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E5%92%8C%E5%BA%94%E7%94%A83/","photos":[]},{"tags":[{"name":"mysql知识点总结和应用2","slug":"mysql知识点总结和应用2","permalink":"https://codermino.github.io/tags/mysql%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E5%92%8C%E5%BA%94%E7%94%A82/"}],"title":"mysql知识点总结和应用2","date":"2020/08/14","text":"视图视图概述视图（View）是一种虚拟存在的表。视图并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。通俗的讲，视图就是一条SELECT语句执行后返回的结果集。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。 视图相对于普通的表的优势主要包括以下几项。 简单：使用视图的用户完全不需要关心后面对应的表的结构、关联条件和筛选条件，对用户来说已经是过滤好的复合条件的结果集。 安全：使用视图的用户只能访问他们被允许查询的结果集，对表的权限管理并不能限制到某个行某个列，但是通过视图就可以简单的实现。 数据独立：一旦视图的结构确定了，可以屏蔽表结构变化对用户的影响，源表增加列对视图没有影响；源表修改列名，则可以通过修改视图来解决，不会造成对访问者的影响。 创建或者修改视图创建CREATE [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}] VIEW view_name [(column_list)] AS select_statement [WITH [CASCADED | LOCAL] CHECK OPTION] 修改ALTER [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}] VIEW view_name [(column_list)] AS select_statement [WITH [CASCADED | LOCAL] CHECK OPTION]选项 : WITH [CASCADED | LOCAL] CHECK OPTION 决定了是否允许更新数据使记录不再满足视图的条件。 LOCAL ： 只要满足本视图的条件就可以更新。 CASCADED ： 必须满足所有针对该视图的所有视图的条件才可以更新。 默认值.(级联)示例 , 创建city_country_view视图 , 执行如下SQL : create or replace view city_country_view as select t.*,c.country_name from country c , city t where c.country_id = t.country_id; 删除视图DROP VIEW [IF EXISTS] view_name [, view_name] …[RESTRICT | CASCADE]示例 , 删除视图city_country_view : DROP VIEW city_country_view ;","permalink":"https://codermino.github.io/2020/08/14/mysql%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E5%92%8C%E5%BA%94%E7%94%A82/","photos":[]},{"tags":[{"name":"mysql知识点总结和应用1","slug":"mysql知识点总结和应用1","permalink":"https://codermino.github.io/tags/mysql%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E5%92%8C%E5%BA%94%E7%94%A81/"}],"title":"mysql知识点总结和应用1","date":"2020/08/14","text":"索引索引概述MySQL官方对索引的定义为：索引（index）是帮助MySQL高效获取数据的数据结构（有序）。在数据之外，数据库系统还维护者满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。如下面的==示意图==所示 : 左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找快速获取到相应数据。 一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。索引是数据库中用来提高性能的最常用的工具。 索引优势劣势优势 1） 类似于书籍的目录索引，提高数据检索的效率，降低数据库的IO成本。 2） 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。 劣势 1） 实际上索引也是一张表，该表中保存了主键与索引字段，并指向实体类的记录，所以索引列也是要占用空间的。 2） 虽然索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE。 因为更新表时，MySQL 不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段， 都会调整因为更新所带来的键值变化后的索引信息。 索引结构索引是在MySQL的存储引擎层中实现的，而不是在服务器层实现的。所以每种存储引擎的索引都不一定完全相同，也不是所有的存储引擎都支持所有的索引类型的。MySQL目前提供了以下4种索引： BTREE 索引 ： 最常见的索引类型，大部分索引都支持 B 树索引。 HASH 索引：只有Memory引擎支持 ， 使用场景简单 。 R-tree 索引（空间索引）：空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少，不做特别介绍。 Full-text （全文索引） ：全文索引也是MyISAM的一个特殊索引类型，主要用于全文索引，InnoDB从Mysql5.6版本开始支持全文索引。 索引分类1） 单值索引 ：即一个索引只包含单个列，一个表可以有多个单列索引 2） 唯一索引 ：索引列的值必须唯一，但允许有空值 3） 复合索引 ：即一个索引包含多个列 索引语法创建索引CREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX index_name[USING index_type]ON tbl_name(index_col_name,…) index_col_name : column_name[(length)][ASC | DESC]eq:create index idx_city_name on city(city_name); 查看索引show index from table_name[\\G]; 删除索引DROP INDEX index_name ON tbl_name; ALTER命令1). alter table tb_name add primary key(column_list); 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL2). alter table tb_name add unique index_name(column_list); 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）3). alter table tb_name add index index_name(column_list); 添加普通索引， 索引值可以出现多次。4). alter table tb_name add fulltext index_name(column_list); 该语句指定了索引为FULLTEXT， 用于全文索引索引设计原则索引的设计可以遵循一些已有的原则，创建索引的时候请尽量考虑符合这些原则，便于提升索引的使用效率，更高效的使用索引。 对查询频次较高，且数据量比较大的表建立索引。 索引字段的选择，最佳候选列应当从where子句的条件中提取，如果where子句中的组合比较多，那么应当挑选最常用、过滤效果最好的列的组合。 使用唯一索引，区分度越高，使用索引的效率越高。 索引可以有效的提升查询数据的效率，但索引数量不是多多益善，索引越多，维护索引的代价自然也就水涨船高。 对于插入、更新、删除等DML操作比较频繁的表来说，索引过多，会引入相当高的维护代价，降低DML操作的效率，增加相应操作的时间消耗。 另外索引过多的话，MySQL也会犯选择困难病，虽然最终仍然会找到一个可用的索引，但无疑提高了选择的代价。 使用短索引，索引创建之后也是使用硬盘来存储的，因此提升索引访问的I/O效率，也可以提升总体的访问效率。假如构成索引的字段总长度比较短， 那么在给定大小的存储块内可以存储更多的索引值，相应的可以有效的提升MySQL访问索引的I/O效率。 利用最左前缀，N个列组合而成的组合索引，那么相当于是创建了N个索引，如果查询时where子句中使用了组成该索引的前几个字段， 那么这条查询SQL可以利用组合索引来提升查询效率。 创建复合索引: CREATE INDEX idx_name_email_status ON tb_seller(NAME,email,STATUS); 就相当于 对name 创建索引 ; 对name , email 创建了索引 ; 对name , email, status 创建了索引 ;","permalink":"https://codermino.github.io/2020/08/14/mysql%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E5%92%8C%E5%BA%94%E7%94%A81/","photos":[]},{"tags":[{"name":"找回密码功能流程","slug":"找回密码功能流程","permalink":"https://codermino.github.io/tags/%E6%89%BE%E5%9B%9E%E5%AF%86%E7%A0%81%E5%8A%9F%E8%83%BD%E6%B5%81%E7%A8%8B/"}],"title":"找回密码功能流程","date":"2020/08/14","text":"找回密码流程 1、注册时要求每个用户使用唯一的邮箱，注册后向用户的邮箱发一封邮件 2、找回密码时要求用户填写邮箱地址，提示用户如果不记得地址请在邮箱中搜索 3、找回密码功能限制每帐号每天只能使用三次(只能发三次邮件), 使用缓存来完成这个计数 4、找回密码时向缓存中写入一个随机的字符串作为 Token, 有效期为一天，向用户的邮箱发送包含 Token 的链接 5、用户从链接点回来先验证 Token 的有效性，然后提示填写新密码，然后将新密码和 Token 一起提交给后端完成修改密码的操作 6、删除掉 Token 的缓存","permalink":"https://codermino.github.io/2020/08/14/%E6%89%BE%E5%9B%9E%E5%AF%86%E7%A0%81%E5%8A%9F%E8%83%BD%E6%B5%81%E7%A8%8B/","photos":[]},{"tags":[{"name":"vuex页面刷新数据丢失问题","slug":"vuex页面刷新数据丢失问题","permalink":"https://codermino.github.io/tags/vuex%E9%A1%B5%E9%9D%A2%E5%88%B7%E6%96%B0%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/"}],"title":"vuex页面刷新数据丢失问题","date":"2020/08/14","text":"vuex 数据在页面刷新后数据丢失问题解决方法：在APP.vue文件的created生命周期中加入以下代码： if(localStorage.eleToken)&#123; // 1.使用jwt_decode解码存储的token信息 const decoded = jwt_decode(localStorage.eleToken); console.log(decoded); //调用对应的函数，进行用户信息的存储 this.$store.dispatch(\"setAuthenticated\",isEmpty(localStorage.eleToken)); this.$store.dispatch(\"setUser\",decoded); &#125; 对应的vuex中的mutations和actions const mutations=&#123; set_authenticated(state,isAuthenticated)&#123; if(isAuthenticated)&#123; state.isAuthenticated=isAuthenticated; &#125;else&#123; state.isAuthenticated=false; &#125; &#125;, set_user(state,user)&#123; if(user)&#123; state.user=user; &#125;else&#123; state.user=&#123;&#125;; &#125; &#125; &#125;; const actions=&#123; setAuthenticated:(&#123;commit&#125;,isAuthenticated)=&gt;&#123; commit('set_authenticated',isAuthenticated); &#125;, setUser:(&#123;commit&#125;,user)=&gt;&#123; commit('set_user',user); &#125;, clearCurrentState(&#123;commit&#125;)&#123; commit('set_authenticated',false); commit('set_user',&#123;&#125;); &#125; &#125;;","permalink":"https://codermino.github.io/2020/08/14/vuex%E9%A1%B5%E9%9D%A2%E5%88%B7%E6%96%B0%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/","photos":[]},{"tags":[{"name":"vuex知识点总结","slug":"vuex知识点总结","permalink":"https://codermino.github.io/tags/vuex%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"}],"title":"vuex知识点总结","date":"2020/08/14","text":"1、vuex主要包括以下几个模块： State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。 Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。 Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。 Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。 Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。 2、什么情况下使用 Vuex？ 如果应用够简单，最好不要使用 Vuex，一个简单的 store 模式即可 需要构建一个中大型单页应用时，使用Vuex能更好地在组件外部管理状态 3、Vuex和单纯的全局对象有什么区别？ Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。 这样使得我们可以方便地跟踪每一个状态的变化， 从而让我们能够实现一些工具帮助我们更好地了解我们的应用。 4、为什么 Vuex 的 mutation 中不能做异步操作？ Vuex中所有的状态更新的唯一途径都是mutation，异步操作通过 Action 来提交 mutation实现，这样使得我们可以方便地跟踪每一个状态的变化， 从而让我们能够实现一些工具帮助我们更好地了解我们的应用。 每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来， 然后就可以实现 time-travel 了。如果mutation支持异步操作，就没有办法知道状态是何时更新的， 无法很好的进行状态的追踪，给调试带来困难 5、vuex的action有返回值吗？返回的是什么？ store.dispatch 可以处理被触发的 action 的处理函数返回的 Promise，并且 store.dispatch 仍旧返回 Promise Action 通常是异步的，要知道 action 什么时候结束或者组合多个 action以处理更加复杂的异步流程， 可以通过定义action时返回一个promise对象，就可以在派发action的时候就可以通过处理返回的 Promise处理异步流程。 一个 store.dispatch 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后， 返回的 Promise 才会执行。 6、为什么不直接分发mutation,而要通过分发action之后提交 mutation变更状态？ mutation 必须同步执行，我们可以在 action 内部执行异步操作 可以进行一系列的异步操作，并且通过提交 mutation 来记录 action 产生的副作用（即状态变更） 7、从vuex中获取的数据能直接更改吗？ 从vuex中取的数据，不能直接更改，需要浅拷贝对象之后更改，否则报错； 8、Vuex的严格模式是什么,有什么作用,怎么开启 在严格模式下，无论何时发生了状态变更且不是由mutation函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。 在Vuex.Store 构造器选项中开启,如下： const store = new Vuex.Store(&#123; strict:true, &#125;) 9、mutation和action有什么区别 action 提交的是 mutation，而不是直接变更状态。mutation可以直接变更状态 action 可以包含任意异步操作。mutation只能是同步操作 提交方式不同 action 是用this.store.dispatch('ACTION_NAME',data)来提交。 mutation是用this.$store.commit('SET_NUMBER',10)来提交 接收参数不同，mutation第一个参数是state，而action第一个参数是context，其包含了 &#123; state, // 等同于 `store.state`，若在模块中则为局部状态 rootState, // 等同于 `store.state`，只存在于模块中 commit, // 等同于 `store.commit` dispatch, // 等同于 `store.dispatch` getters, // 等同于 `store.getters` rootGetters // 等同于 `store.getters`，只存在于模块中 &#125; 10、在v-model上怎么用Vuex中state的值？ &lt;input v-model=\"message\"&gt; computed: &#123; message: &#123; get () &#123; return this.$store.state.message &#125;, set (value) &#123; this.$store.commit('updateMessage', value) &#125; &#125; &#125;","permalink":"https://codermino.github.io/2020/08/14/vuex%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/","photos":[]},{"tags":[{"name":"响应式布局尺寸划分","slug":"响应式布局尺寸划分","permalink":"https://codermino.github.io/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%E5%B0%BA%E5%AF%B8%E5%88%92%E5%88%86/"}],"title":"响应式布局尺寸划分","date":"2020/08/14","text":"尺寸划分 超小屏幕(手机) ------- &lt;768px 设置宽度为100% 小屏设备(平板) ------- &gt;=768px &lt;992px 设置宽度为750px 中等屏幕(桌面显示器) ------- &gt;=992px &lt;1200px 设置宽度为970px 宽屏设备(大桌面显示器) ------- &gt;=1200px 设置宽度为1170px","permalink":"https://codermino.github.io/2020/08/14/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%E5%B0%BA%E5%AF%B8%E5%88%92%E5%88%86/","photos":[]},{"tags":[{"name":"echarts自定义样式","slug":"echarts自定义样式","permalink":"https://codermino.github.io/tags/echarts%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%B7%E5%BC%8F/"}],"title":"echarts自定义样式","date":"2020/08/14","text":"一、折线统计图中的自定义样式（注意背景条纹色的设置） let option1 = &#123; title: &#123; // text: \"堆叠区域图\" &#125;, tooltip: &#123; trigger: \"axis\", axisPointer: &#123; type: \"cross\", label: &#123; backgroundColor: \"#6a7985\" &#125; &#125; &#125;, legend: &#123; data: [\"登记数\", \"分享数\"] &#125;, toolbox: &#123;&#125;, grid: &#123; left: 10, right: 10, bottom: 20, top: 30, containLabel: true &#125;, color: [\"#81b22f\", \"#f3d71c\", \"#f4b9a9\"], xAxis: [ &#123; type: \"category\", boundaryGap: false, data: [\"周一\", \"周二\", \"周三\", \"周四\", \"周五\", \"周六\", \"周日\"] &#125; ], yAxis: [ &#123; type: \"value\", splitArea: &#123; show: true, areaStyle:&#123; color:['rgba(255,255,255,0.3)','rgba(241,241,241,0.3)'] &#125; &#125; &#125; ], series: [ &#123; name: \"登记数\", type: \"line\", stack: \"总量\", animationEasing: \"quadraticOut\", label: &#123; normal: &#123; // show: true, position: \"top\" &#125; &#125;, itemStyle: &#123; normal: &#123; color: \"#3888fa\", lineStyle: &#123; color: \"#3888fa\", width: 2 &#125;, areaStyle: &#123; color: \"#f3f8ff\" &#125; &#125; &#125;, data: [820, 932, 901, 934, 1290, 1330, 1320], animationDuration: 2800, animationEasing: \"cubicInOut\" &#125;, &#123; name: \"分享数\", type: \"line\", stack: \"总量\", itemStyle: &#123; normal: &#123; color: \"#FF005A\", lineStyle: &#123; color: \"#FF005A\", width: 2 &#125; &#125; &#125;, data: [350, 432, 601, 554, 390, 430, 410], animationDuration: 2800, animationEasing: \"cubicInOut\" &#125; ] &#125;; 二、雷达图自定义样式 let option2 = &#123; tooltip: &#123; trigger: \"axis\", axisPointer: &#123; // 坐标轴指示器，坐标轴触发有效 type: \"shadow\" // 默认为直线，可选为：'line' | 'shadow' &#125; &#125;, radar: &#123; radius: \"66%\", center: [\"50%\", \"42%\"], splitNumber: 8, splitArea: &#123; areaStyle: &#123; color: \"rgba(127,95,132,.3)\", opacity: 1, shadowBlur: 45, shadowColor: \"rgba(0,0,0,.5)\", shadowOffsetX: 0, shadowOffsetY: 15 &#125; &#125;, indicator: [ &#123; name: \"Sales\", max: 10000 &#125;, &#123; name: \"Administration\", max: 20000 &#125;, &#123; name: \"Information Technology\", max: 20000 &#125;, &#123; name: \"Customer Support\", max: 20000 &#125;, &#123; name: \"Development\", max: 20000 &#125;, &#123; name: \"Marketing\", max: 20000 &#125; ] &#125;, legend: &#123; left: \"center\", bottom: \"10\", data: [\"Allocated Budget\", \"Expected Spending\", \"Actual Spending\"] &#125;, series: [ &#123; type: \"radar\", symbolSize: 0, areaStyle: &#123; normal: &#123; shadowBlur: 13, shadowColor: \"rgba(0,0,0,.2)\", shadowOffsetX: 0, shadowOffsetY: 10, opacity: 1 &#125; &#125;, data: [ &#123; value: [5000, 7000, 12000, 11000, 15000, 14000], name: \"Allocated Budget\", itemStyle: &#123; normal: &#123; color: \"#2ec7c9\", areaStyle: &#123; type: \"default\", // opacity: 0.8, // 图表中各个图区域的透明度 color: \"#5ab1ef\" // 图表中各个图区域的颜色 &#125; &#125; &#125; &#125;, &#123; value: [4000, 9000, 15000, 15000, 13000, 11000], itemStyle: &#123; normal: &#123; color: \"#b6a2de\" // areaStyle: &#123; // type: \"default\", // // opacity: 0.8, // 图表中各个图区域的透明度 // color: \"#b6a2de\" // 图表中各个图区域的颜色 // &#125; &#125; &#125;, name: \"Expected Spending\" &#125;, &#123; value: [5500, 11000, 12000, 15000, 12000, 12000], name: \"Actual Spending\", itemStyle: &#123; normal: &#123; color: \"#5ab1ef\", areaStyle: &#123; type: \"default\", // opacity: 0.8, // 图表中各个图区域的透明度 color: \"#2ec7c9\" // 图表中各个图区域的颜色 &#125; &#125; &#125; &#125; ], animationDuration: 3000 &#125; ] &#125;; 三、玫瑰图自定义样式 let option3 = &#123; tooltip: &#123; trigger: \"item\", formatter: \"&#123;a&#125; &lt;br/&gt;&#123;b&#125; : &#123;c&#125; (&#123;d&#125;%)\" &#125;, legend: &#123; left: \"center\", bottom: \"10\", data: [\"Industries\", \"Technology\", \"Forex\", \"Gold\", \"Forecasts\"] &#125;, series: [ &#123; name: \"WEEKLY WRITE ARTICLES\", type: \"pie\", roseType: \"radius\", radius: [15, 95], center: [\"50%\", \"38%\"], color: [\"#2ec7c9\", \"#b6a2de\", \"#5ab1ef\", \"#ffb980\", \"#d87a80\"], data: [ &#123; value: 320, name: \"Industries\" &#125;, &#123; value: 240, name: \"Technology\" &#125;, &#123; value: 149, name: \"Forex\" &#125;, &#123; value: 100, name: \"Gold\" &#125;, &#123; value: 59, name: \"Forecasts\" &#125; ], animationEasing: \"cubicInOut\", animationDuration: 2600 &#125; ] &#125;; 四、柱形图自定义样式（注意背景条纹色的设置） let option4 = &#123; tooltip: &#123; trigger: \"axis\", axisPointer: &#123; // 坐标轴指示器，坐标轴触发有效 type: \"shadow\" // 默认为直线，可选为：'line' | 'shadow' &#125; &#125;, // backgroundColor: &#123;&#125;, grid: &#123; top: 10, left: \"2%\", right: \"2%\", bottom: \"3%\", containLabel: true &#125;, xAxis: [ &#123; type: \"category\", data: [\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\"], axisTick: &#123; alignWithLabel: true &#125; &#125; ], yAxis: [ &#123; type: \"value\", axisTick: &#123; show: false &#125;, splitArea: &#123; show: true, areaStyle:&#123; color:['rgba(255,255,255,0.3)','rgba(241,241,241,0.3)'] &#125; &#125; &#125; ], series: [ &#123; name: \"pageA\", type: \"bar\", stack: \"vistors\", barWidth: \"60%\", itemStyle: &#123; normal: &#123; color: \"#2ec7c9\" &#125; &#125;, data: [79, 52, 200, 334, 390, 330, 220], animationDuration: 6000 &#125;, &#123; name: \"pageB\", type: \"bar\", stack: \"vistors\", barWidth: \"60%\", itemStyle: &#123; normal: &#123; color: \"#b6a2de\" &#125; &#125;, data: [80, 52, 200, 334, 390, 330, 220], animationDuration: 6000 &#125;, &#123; name: \"pageC\", type: \"bar\", stack: \"vistors\", barWidth: \"60%\", itemStyle: &#123; normal: &#123; color: \"#1e9fff\" &#125; &#125;, data: [30, 52, 200, 334, 390, 330, 220], animationDuration: 6000 &#125; ] &#125;;","permalink":"https://codermino.github.io/2020/08/14/echarts%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%B7%E5%BC%8F/","photos":[]},{"tags":[{"name":"在本地运行webpack打包后的vue项目文件","slug":"在本地运行webpack打包后的vue项目文件","permalink":"https://codermino.github.io/tags/%E5%9C%A8%E6%9C%AC%E5%9C%B0%E8%BF%90%E8%A1%8Cwebpack%E6%89%93%E5%8C%85%E5%90%8E%E7%9A%84vue%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6/"}],"title":"在本地运行webpack打包后的vue项目文件","date":"2020/08/14","text":"那么如何用最简单的方法就可以让打包后的文件正常运行呢？ 解决这个问题首先要安装server，在cmd中输入命令： npm install -g serve 进入项目目录使用：serve -s dist 这时会提示要访问的网址，在浏览器中输入网址就可以打开了！","permalink":"https://codermino.github.io/2020/08/14/%E5%9C%A8%E6%9C%AC%E5%9C%B0%E8%BF%90%E8%A1%8Cwebpack%E6%89%93%E5%8C%85%E5%90%8E%E7%9A%84vue%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6/","photos":[]},{"tags":[{"name":"vue.config.js配置","slug":"vue-config-js配置","permalink":"https://codermino.github.io/tags/vue-config-js%E9%85%8D%E7%BD%AE/"}],"title":"vue.config.js配置","date":"2020/08/14","text":"简易版 const path = require(\"path\"); const resolve = function(dir) &#123; return path.join(__dirname, dir); &#125;; module.exports = &#123; publicPath: process.env.NODE_ENV === \"production\" ? \"./\" : \"./\", outputDir: \"dist\", assetsDir: \"static\", lintOnSave: true, // 是否开启eslint保存检测 productionSourceMap: false, // 是否在构建生产包时生成sourcdeMap chainWebpack: config =&gt; &#123; config.resolve.alias .set(\"@\", resolve(\"src\")) .set(\"@v\", resolve(\"src/views\")) .set(\"@c\", resolve(\"src/components\")) .set(\"@u\", resolve(\"src/utils\")) .set(\"@s\", resolve(\"src/service\")); /* 别名配置 */ config.optimization.runtimeChunk(\"single\"); &#125;, devServer: &#123; // host: \"localhost\", /* 本地ip地址 */ //host: \"192.168.1.107\", host: \"0.0.0.0\", //局域网和本地访问 port: \"8080\", hot: true, /* 自动打开浏览器 */ open: false, overlay: &#123; warning: false, error: true &#125;, /* 跨域代理 */ proxy: &#123; \"/api\": &#123; /* 目标代理服务器地址 */ target: \"http://xxx.com\", // // target: \"http://localhost:8888\", // /* 允许跨域 */ changeOrigin: true, ws: true, pathRewrite: &#123; \"^/api\": \"\" &#125; &#125; &#125; &#125; &#125;; 完整版 const path = require(\"path\"); const UglifyPlugin = require(\"uglifyjs-webpack-plugin\"); module.exports = &#123; // 基本路径 /* 部署生产环境和开发环境下的URL：可对当前环境进行区分，baseUrl 从 Vue CLI 3.3 起已弃用，要使用publicPath */ /* baseUrl: process.env.NODE_ENV === 'production' ? './' : '/' */ publicPath: process.env.NODE_ENV === \"production\" ? \"./\" : \"./\", // 输出文件目录 outputDir: \"dist\", // eslint-loader 是否在保存的时候检查 lintOnSave: true, // use the full build with in-browser compiler? // https://vuejs.org/v2/guide/installation.html#Runtime-Compiler-vs-Runtime-only // compiler: false, runtimeCompiler: true, //关键点在这 // 调整内部的 webpack 配置。 // 查阅 https://github.com/vuejs/vue-doc-zh-cn/vue-cli/webpack.md // webpack配置 // see https://github.com/vuejs/vue-cli/blob/dev/docs/webpack.md chainWebpack: () =&gt; &#123;&#125;, configureWebpack: config =&gt; &#123; if (process.env.NODE_ENV === \"production\") &#123; // 为生产环境修改配置... config.mode = \"production\"; // 将每个依赖包打包成单独的js文件 var optimization = &#123; runtimeChunk: \"single\", splitChunks: &#123; chunks: \"all\", maxInitialRequests: Infinity, minSize: 20000, // 依赖包超过20000bit将被单独打包 cacheGroups: &#123; vendor: &#123; test: /[\\\\/]node_modules[\\\\/]/, name(module) &#123; // get the name. E.g. node_modules/packageName/not/this/part.js // or node_modules/packageName const packageName = module.context.match( /[\\\\/]node_modules[\\\\/](.*?)([\\\\/]|$)/ )[1]; // npm package names are URL-safe, but some servers don't like @ symbols return `npm.$&#123;packageName.replace(\"@\", \"\")&#125;`; &#125; &#125; &#125; &#125;, minimizer: [ new UglifyPlugin(&#123; uglifyOptions: &#123; compress: &#123; warnings: false, drop_console: true, // console drop_debugger: false, pure_funcs: [\"console.log\"] // 移除console &#125; &#125; &#125;) ] &#125;; Object.assign(config, &#123; optimization &#125;); &#125; else &#123; // 为开发环境修改配置... config.mode = \"development\"; var optimization2 = &#123; runtimeChunk: \"single\", splitChunks: &#123; chunks: \"all\", maxInitialRequests: Infinity, minSize: 20000, // 依赖包超过20000bit将被单独打包 cacheGroups: &#123; vendor: &#123; test: /[\\\\/]node_modules[\\\\/]/, name(module) &#123; // get the name. E.g. node_modules/packageName/not/this/part.js // or node_modules/packageName const packageName = module.context.match( /[\\\\/]node_modules[\\\\/](.*?)([\\\\/]|$)/ )[1]; // npm package names are URL-safe, but some servers don't like @ symbols return `npm.$&#123;packageName.replace(\"@\", \"\")&#125;`; &#125; &#125; &#125; &#125; &#125;; &#125; Object.assign(config, &#123; // 开发生产共同配置 // externals: &#123; // 'vue': 'Vue', // 'element-ui': 'ELEMENT', // 'vue-router': 'VueRouter', // 'vuex': 'Vuex' // &#125; // 防止将某些 import 的包(package)打包到 bundle 中，而是在运行时(runtime)再去从外部获取这些扩展依赖(用于csdn引入) resolve: &#123; extensions: [\".js\", \".vue\", \".json\"], //文件优先解析后缀名顺序 alias: &#123; \"@\": path.resolve(__dirname, \"./src\"), \"@c\": path.resolve(__dirname, \"./src/components\"), \"@v\": path.resolve(__dirname, \"./src/views\"), \"@u\": path.resolve(__dirname, \"./src/utils\"), \"@s\": path.resolve(__dirname, \"./src/service\") &#125;, // 别名配置 plugins: [] &#125;, optimization: optimization2 &#125;); &#125;, // vue-loader 配置项 // https://vue-loader.vuejs.org/en/options.html // vueLoader: &#123;&#125;, // 生产环境是否生成 sourceMap 文件 productionSourceMap: false, // css相关配置 css: &#123; // 是否使用css分离插件 ExtractTextPlugin // extract: true, //注释css热更新生效 // 开启 CSS source maps? sourceMap: false, // css预设器配置项 loaderOptions: &#123;&#125;, // 启用 CSS modules for all css / pre-processor files. modules: false &#125;, // use thread-loader for babel &amp; TS in production build // enabled by default if the machine has more than 1 cores parallel: require(\"os\").cpus().length &gt; 1, // 是否启用dll // See https://github.com/vuejs/vue-cli/blob/dev/docs/cli-service.md#dll-mode // dll: false, // PWA 插件相关配置 // see https://github.com/vuejs/vue-cli/tree/dev/packages/%40vue/cli-plugin-pwa pwa: &#123;&#125;, // webpack-dev-server 相关配置 devServer: &#123; /* 自动打开浏览器 */ open: false, // host: \"192.168.0.137\", host: \"0.0.0.0\", //局域网和本地访问 //host: \"192.168.1.137\", port: 8080, https: false, hotOnly: false, /* 使用代理 */ proxy: &#123; \"/api\": &#123; /* 目标代理服务器地址 */ // target: \"http://192.168.0.106:8080/\", target: \"http://192.168.1.126:8080/\", //阳洋 /* 允许跨域 */ changeOrigin: true, ws: true, pathRewrite: &#123; \"^/api\": \"\" &#125; &#125; &#125;, before: () =&gt; &#123;&#125; &#125;, // 第三方插件配置 pluginOptions: &#123;&#125; &#125;; 之后运行打包命令即可 npm run build 清除缓存 tip: 直接在vue项目中新建vue.config.js，然后复制进去即可。 const path = require(\"path\"); // 获取当前时间戳 const Timestamp = new Date().getTime(); // 定义版本号 const VUE_APP_Version = '1.0.0' const resolve = function (dir) &#123; return path.join(__dirname, dir); &#125;; module.exports = &#123; configureWebpack: &#123; output: &#123; //输出重构，打包编译后的文件名称 【模块名称.版本号.时间戳】 filename: `[name].$&#123;VUE_APP_Version&#125;.$&#123;Timestamp&#125;.js`, chunkFilename: `[name].$&#123;VUE_APP_Version&#125;.$&#123;Timestamp&#125;.js` &#125; &#125;, publicPath: process.env.NODE_ENV === \"production\" ? \"./\" : \"./\", // publicPath: './', outputDir: \"dist\", assetsDir: \"static\", lintOnSave: true, // 是否开启eslint保存检测 productionSourceMap: false, // 是否在构建生产包时生成sourcdeMap chainWebpack: config =&gt; &#123; config.resolve.alias .set(\"@\", resolve(\"src\")) .set(\"@v\", resolve(\"src/views\")) .set(\"@c\", resolve(\"src/components\")) .set(\"@u\", resolve(\"src/utils\")) .set(\"@s\", resolve(\"src/service\")); /* 别名配置 */ config.optimization.runtimeChunk(\"single\"); &#125;, devServer: &#123; // host: \"localhost\", /* 本地ip地址 */ //host: \"192.168.1.107\", host: \"0.0.0.0\", //局域网和本地访问 port: \"8080\", hot: true, /* 自动打开浏览器 */ open: false, overlay: &#123; warning: false, error: true &#125;, /* 跨域代理 */ proxy: &#123; \"/api\": &#123; /* 目标代理服务器地址 */ target: \"http://m260048y71.zicp.vip\", // // target: \"http://192.168.1.102:8888\", // /* 允许跨域 */ changeOrigin: true, ws: true, pathRewrite: &#123; \"^/api\": \"\" &#125; &#125; &#125; &#125; &#125;;","permalink":"https://codermino.github.io/2020/08/14/vue-config-js%E9%85%8D%E7%BD%AE/","photos":[]},{"tags":[{"name":"ecahrts自适应和切换问题","slug":"ecahrts自适应和切换问题","permalink":"https://codermino.github.io/tags/ecahrts%E8%87%AA%E9%80%82%E5%BA%94%E5%92%8C%E5%88%87%E6%8D%A2%E9%97%AE%E9%A2%98/"}],"title":"ecahrts自适应和切换问题","date":"2020/08/14","text":"1、解决方法：监听屏幕的 onresize() 事件调用Echarts的resize()事件,代码如下： // 自适应屏幕宽度 window.onresize = function() &#123; myChart.resize(); myChart2.resize(); myChart3.resize(); myChart4.resize(); &#125;; 2、不要页面一加载就全部把页面中的图表都加载好，而是刚开始只渲染默认的第一个图表，其他的图表在tabs选项卡切换的时候再加载渲染出来就可以了，具体代码如下： &lt;template&gt; &lt;!-- 使用tabs选项卡子组件 --&gt; &lt;titleBar :indexRenshiMsg=\"renshiMsg\" @func=\"changeHandle\"&gt;&lt;/titleBar&gt; &lt;el-row style=\"margin-top:20px\"&gt; &lt;div id=\"renshichu\" :style=\"&#123;width: '100%', height: '400px'&#125;\"&gt;&lt;/div&gt; &lt;/el-row&gt; &lt;!-- 使用子组件 --&gt; &lt;titleBar :indexRenshiMsg=\"renshiMsg\" @func=\"changeHandle2\"&gt;&lt;/titleBar&gt; &lt;el-row style=\"margin-top:20px\"&gt; &lt;div id=\"zhinengbu\" :style=\"&#123;width: '100%', height: '400px'&#125;\"&gt;&lt;/div&gt; &lt;/el-row&gt; &lt;!-- 部门管理员权限 --&gt; &lt;titleBar :indexRenshiMsg=\"renshiMsg\" @func=\"changeHandle3\"&gt;&lt;/titleBar&gt; &lt;el-row style=\"margin-top:20px\"&gt; &lt;div id=\"bumengguanli\" :style=\"&#123;width: '100%', height: '400px'&#125;\"&gt;&lt;/div&gt; &lt;/el-row&gt; &lt;/template&gt; &lt;script&gt; import titleBar from \"../components/titleBar\"; // 指定图表的配置项和数据 var option = &#123; tooltip: &#123; trigger: \"axis\", axisPointer: &#123; type: \"cross\", crossStyle: &#123; color: \"#999\" &#125; &#125; &#125;, toolbox: &#123; feature: &#123; dataView: &#123; show: true, readOnly: false &#125;, magicType: &#123; show: true, type: [\"line\", \"bar\"] &#125;, restore: &#123; show: true &#125;, saveAsImage: &#123; show: true &#125; &#125; &#125;, color: [\"#3398DB\"], tooltip: &#123;&#125;, legend: &#123; data: [\"申报人数\"], left: \"left\", top: \"10%\", textStyle: &#123; fontSize: 16 &#125; &#125;, xAxis: &#123; data: [\"教授\", \"副教授\", \"讲师\", \"研究员\", \"副研究员\", \"助理研究员\"], axisLabel: &#123; fontSize: 20 //字体大小 &#125; &#125;, yAxis: [ &#123; type: \"value\", name: \"人数\", axisLabel: &#123; formatter: \"&#123;value&#125;\", fontSize: 20 //字体大小 &#125; &#125; ], series: [ &#123; barWidth: 50, name: \"申报人数\", type: \"bar\", data: [10, 3, 4, 4, 5, 4] &#125; ] &#125;; var option2 = &#123; tooltip: &#123; trigger: \"axis\", axisPointer: &#123; type: \"cross\", crossStyle: &#123; color: \"#999\" &#125; &#125; &#125;, toolbox: &#123; feature: &#123; dataView: &#123; show: true, readOnly: false &#125;, magicType: &#123; show: true, type: [\"line\", \"bar\"] &#125;, restore: &#123; show: true &#125;, saveAsImage: &#123; show: true &#125; &#125; &#125;, tooltip: &#123; trigger: \"axis\", axisPointer: &#123; type: \"cross\", crossStyle: &#123; color: \"#999\" &#125; &#125; &#125;, legend: &#123; data: [\"已审核\", \"未审核\", \"退回\"], left: \"left\", top: \"10%\", orient: \"vertical\", textStyle: &#123; fontSize: 20 &#125; &#125;, xAxis: &#123; type: \"category\", data: [\"论文著作\", \"项目获批\", \"荣誉获奖\"], axisPointer: &#123; type: \"shadow\" &#125;, axisLabel: &#123; fontSize: 20 //字体大小 &#125; &#125;, yAxis: [ &#123; type: \"value\", name: \"人数\", axisLabel: &#123; formatter: \"&#123;value&#125;\", fontSize: 20 //字体大小 &#125; &#125; ], series: [ &#123; barWidth: 50, name: \"已审核\", type: \"bar\", color: \"#92d050\", data: [10, 8, 6] &#125;, &#123; barWidth: 50, name: \"未审核\", type: \"bar\", color: \"#ed7d31\", data: [7, 5, 3] &#125;, &#123; barWidth: 50, name: \"退回\", type: \"bar\", color: \"#9cc3e5\", data: [4, 3, 1] &#125; ] &#125;; var option4 = &#123; tooltip: &#123; trigger: \"axis\", axisPointer: &#123; type: \"cross\", crossStyle: &#123; color: \"#999\" &#125; &#125; &#125;, toolbox: &#123; feature: &#123; dataView: &#123; show: true, readOnly: false &#125;, magicType: &#123; show: true, type: [\"line\", \"bar\"] &#125;, restore: &#123; show: true &#125;, saveAsImage: &#123; show: true &#125; &#125; &#125;, color: [\"#3398DB\"], tooltip: &#123;&#125;, legend: &#123; data: [\"数量\"], left: \"left\", top: \"10%\", textStyle: &#123; fontSize: 20 &#125; &#125;, xAxis: &#123; data: [\"论文发表\", \"著作发表\", \"项目立项\", \"获奖荣誉\", \"教学课程\"], axisLabel: &#123; fontSize: 20 //字体大小 &#125; &#125;, yAxis: [ &#123; type: \"value\", name: \"数量\", axisLabel: &#123; formatter: \"&#123;value&#125;\", fontSize: 20 //字体大小 &#125; &#125; ], series: [ &#123; barWidth: 50, name: \"数量\", type: \"bar\", data: [12, 4, 7, 4, 9, 33] &#125; ] &#125;; export default &#123; components: &#123; titleBar &#125;, name: \"index\", data() &#123; return &#123; num: 115, onePower: true, echartsTitle: \"评审年度 | 2020年\", echartsTitle4: \"个人档案库内情况\", xAxis: [\"教授\", \"副教授\", \"讲师\", \"研究员\", \"副研究员\", \"助理研究员\"], xAxis2: [\"论文著作\", \"项目获批\", \"荣誉获奖\"], xAxis4: [\"论文发表\", \"著作发表\", \"项目立项\", \"获奖荣誉\", \"教学课程\"], series: [10, 3, 4, 4, 5, 4], // 步骤条进度 active: 1, // 待办事项 backlog: 4, // 传给子组件的参数 renshiMsg: &#123; title: \"评审年度 | 2020年\", msg: \"申报人数：\", number: 49 &#125;, chartOptions: [option, option2, option4], tableData: [ &#123; category: \"论文\", research: \"基于C51单片机的全球导弹发射控制系统\", opinion: \"这是一个非常好的想法\", name: \"张三\" &#125;, &#123; category: \"项目\", research: \"基于C51单片机的全球导弹发射控制系统\", opinion: \"这是一个非常好的想法\", name: \"张三\" &#125;, &#123; category: \"获奖\", research: \"全球和平伟大贡献奖\", opinion: \"这是一个非常好的想法\", name: \"张三\" &#125;, &#123; category: \"论文\", research: \"基于C51单片机的全球导弹发射控制系统\", opinion: \"这是一个非常好的想法\", name: \"张三\" &#125;, &#123; category: \"论文\", research: \"基于C51单片机的全球导弹发射控制系统\", opinion: \"这是一个非常好的想法\", name: \"张三\" &#125; ] &#125;; &#125;, mounted() &#123; // 人事处管理员审核权限统计图 var dom = document.getElementById(\"renshichu\"); var myChart = this.echarts.init(dom); myChart.setOption(this.chartOptions[0]); // 职能部门审核用户权限统计图 var dom2 = document.getElementById(\"zhinengbu\"); var myChart2 = this.echarts.init(dom2); myChart2.setOption(this.chartOptions[1]); // 部门管理员权限统计图 var dom3 = document.getElementById(\"bumengguanli\"); var myChart3 = this.echarts.init(dom3); myChart3.setOption(this.chartOptions[2]); // 普通教师权限统计图 var dom4 = document.getElementById(\"jiaoshiquanxian\"); var myChart4 = this.echarts.init(dom4); myChart4.setOption(this.chartOptions[2]); // 自适应屏幕宽度 window.onresize = function() &#123; myChart.resize(); myChart2.resize(); myChart3.resize(); myChart4.resize(); &#125;; &#125;, methods: &#123; // 下面的几个函数都是tabs选项卡切换的点击事件 changeHandle(e) &#123; // 人事处管理员审核权限统计图 var dom = document.getElementById(\"renshichu\"); var myChart = this.echarts.init(dom); myChart.clear(); myChart.setOption(this.chartOptions[e]); &#125;, changeHandle2(e) &#123; // 职能部门审核用户权限统计图 var dom2 = document.getElementById(\"zhinengbu\"); var myChart2 = this.echarts.init(dom2); myChart2.clear(); myChart2.setOption(this.chartOptions[e]); &#125;, changeHandle3(e) &#123; // 职能部门审核用户权限统计图 var dom3 = document.getElementById(\"bumengguanli\"); var myChart3 = this.echarts.init(dom3); myChart3.clear(); myChart3.setOption(this.chartOptions[e]); &#125; &#125; &#125;; &lt;/script&gt;","permalink":"https://codermino.github.io/2020/08/14/ecahrts%E8%87%AA%E9%80%82%E5%BA%94%E5%92%8C%E5%88%87%E6%8D%A2%E9%97%AE%E9%A2%98/","photos":[]},{"tags":[{"name":"scrapy的shell的使用","slug":"scrapy的shell的使用","permalink":"https://codermino.github.io/tags/scrapy%E7%9A%84shell%E7%9A%84%E4%BD%BF%E7%94%A8/"}],"title":"scrapy的shell的使用","date":"2020/07/26","text":"scrapy shell 网址 然后可以在Terminal中使用tab键进行代码提示(但是可能会出现warning等提示信息，扰乱界面) 可以在settings.py中 import logging logging.getLogger('parso').setLevel(logging.WARNING)","permalink":"https://codermino.github.io/2020/07/26/scrapy%E7%9A%84shell%E7%9A%84%E4%BD%BF%E7%94%A8/","photos":[]},{"tags":[{"name":"scrapy添加cookie的三种方式","slug":"scrapy添加cookie的三种方式","permalink":"https://codermino.github.io/tags/scrapy%E6%B7%BB%E5%8A%A0cookie%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/"}],"title":"scrapy添加cookie的三种方式","date":"2020/07/26","text":"settings中添加 settings文件中给Cookies_enabled=False解注释 settings的headers配置的cookie就可以用了 这种方法最简单，同时cookie可以直接粘贴浏览器的。 后两种方法添加的cookie是字典格式的，需要用json反序列化一下, 而且需要设置settings中的Cookies_enabled=True eq:cookie = &#123;k1: v1, k2: v2&#125; DownloadMiddleware中添加 settings中给downloadmiddleware解注释 去中间件文件中找downloadmiddleware这个类， 修改process_request，添加request.cookies=&#123;&#125;即可。 爬虫主文件中重写start_request def start_requests(self): yield scrapy.Request(url,dont_filter=True,cookies=&#123;自己的cookie&#125;) 方法三的Demo1 import scrapy class ItaobaoSpider(scrapy.Spider): name = 'itaobao' allowed_domains = ['taobao.com'] # start_urls = ['https://cart.taobao.com/cart.htm?spm=a1z02.1.a2109.d1000367.OOeipq&amp;nekot=1470211439694'] # 需要重写start_requests方法 def start_requests(self): url = \"https://cart.taobao.com/cart.htm?spm=a1z02.1.a2109.d1000367.OOeipq&amp;nekot=1470211439694\" # 此处的cookie为手动登录后从浏览器粘贴下来的值 cookie = \"thw=cn; cookie2=16b0fe13709f2a71dc06ab1f15dcc97b; _tb_token_=fe3431e5fe755;\" \\ \" _samesite_flag_=true; ubn=p; ucn=center; t=538b39347231f03177d588275aba0e2f;\" \\ \" tk_trace=oTRxOWSBNwn9dPyorMJE%2FoPdY8zfvmw%2Fq5hoqmmiKd74AJ%2Bt%2FNCZ%\" \\ \"2FSIX9GYWSRq4bvicaWHhDMtcR6rWsf0P6XW5ZT%2FgUec9VF0Ei7JzUpsghuwA4cBMNO9EHkGK53r%\" \\ \"2Bb%2BiCEx98Frg5tzE52811c%2BnDmTNlzc2ZBkbOpdYbzZUDLaBYyN9rEdp9BVnFGP1qVAAtbsnj35zfBVfe09E%\" \\ \"2BvRfUU823q7j4IVyan1lagxILINo%2F%2FZK6omHvvHqA4cu2IaVAhy5MzzodyJhmXmOpBiz9Pg%3D%3D; \" \\ \"cna=5c3zFvLEEkkCAW8SYSQ2GkGo; sgcookie=E3EkJ6LRpL%2FFRZIBoXfnf; unb=578051633; \" \\ \"uc3=id2=Vvl%2F7ZJ%2BJYNu&amp;nk2=r7kpR6Vbl9KdZe14&amp;lg2=URm48syIIVrSKA%3D%3D&amp;vt3=F8dBxGJsy36E3EwQ%2BuQ%3D;\" \\ \" csg=c99a3c3d; lgc=%5Cu5929%5Cu4ED9%5Cu8349%5Cu5929%5Cu4ED9%5Cu8349; cookie17=Vvl%2F7ZJ%2BJYNu;\" \\ \" dnk=%5Cu5929%5Cu4ED9%5Cu8349%5Cu5929%5Cu4ED9%5Cu8349; skt=4257a8fa00b349a7; existShop=MTU5MzQ0MDI0MQ%3D%3D;\" \\ \" uc4=nk4=0%40rVtT67i5o9%2Bt%2BQFc65xFQrUP0rGVA%2Fs%3D&amp;id4=0%40VH93OXG6vzHVZgTpjCrALOFhU4I%3D;\" \\ \" tracknick=%5Cu5929%5Cu4ED9%5Cu8349%5Cu5929%5Cu4ED9%5Cu8349; _cc_=W5iHLLyFfA%3D%3D; \" \\ \"_l_g_=Ug%3D%3D; sg=%E8%8D%893d; _nk_=%5Cu5929%5Cu4ED9%5Cu8349%5Cu5929%5Cu4ED9%5Cu8349;\" \\ \" cookie1=VAmiexC8JqC30wy9Q29G2%2FMPHkz4fpVNRQwNz77cpe8%3D; tfstk=cddPBI0-Kbhyfq5IB_1FRmwX4zaRClfA\" \\ \"_qSREdGTI7eLP5PGXU5c-kQm2zd2HGhcE; mt=ci=8_1; v=0; uc1=cookie21=VFC%2FuZ9ainBZ&amp;cookie15=VFC%2FuZ9ayeYq2g%3D%3D&amp;cookie\" \\ \"16=WqG3DMC9UpAPBHGz5QBErFxlCA%3D%3D&amp;existShop=false&amp;pas=0&amp;cookie14=UoTV75eLMpKbpQ%3D%3D&amp;cart_m=0;\" \\ \" _m_h5_tk=cbe3780ec220a82fe10e066b8184d23f_1593451560729; _m_h5_tk_enc=c332ce89f09d49c68e13db9d906c8fa3; \" \\ \"l=eBxAcQbPQHureJEzBO5aourza7796IRb8sPzaNbMiInca6MC1hQ0PNQD5j-MRdtjgtChRe-PWBuvjdeBWN4dbNRMPhXJ_n0xnxvO.; \" \\ \"isg=BJ2drKVLn8Ww-Ht9N195VKUWrHmXutEMHpgqKF9iKfRAFrxIJAhD3DbMRAoQ1unE\" cookies = &#123;&#125; # 提取键值对 请求头中携带cookie必须是一个字典，所以要把原生的cookie字符串转换成cookie字典 for cookie in cookie.split(';'): key, value = cookie.split(\"=\", 1) cookies[key] = value yield scrapy.Request(url=url, cookies=cookies, callback=self.parse) def parse(self, response): print(response.text) 方法三的Demo1的最终cookie的dict形式 cookie = &#123;'ll': '\"108090\"', ' bid': 'LKyRKxbzn_E', ' _pk_ses.100001.8cb4': '*', ' __utma': '30149280.1348080368.1556600783.1556600783.1556600783.1', ' __utmc': '30149280', ' __utmz': '30149280.1556600783.1.1.utmcsr', ' __utmt': '1', ' dbcl2': '\"177745320:ER12/4y8Vxk\"', ' ck': '9SGi', ' _pk_id.100001.8cb4': 'fc3beca6f0344a06.1556600779.1.1556600805.1556600779.', ' push_noty_num': '0', ' push_doumail_num': '0', ' __utmv': '30149280.17774', ' __utmb': '30149280.3.10.1556600783', ' ap_v': '0,6.0'&#125; def start_requests(self): yield scrapy.Request(self.profile_url, callback=self.parse_profile, cookies=self.cookie) 方法三的Demo2 def start_requests(self): \"\"\" 根据cookies模拟登陆人人网，注意settings.py文件的cookies必须是开启的 :return: \"\"\" cookies=\"anonymid=jxcn09d5-vd52v0; depovince=GUZ; _r01_=1; ick_login=d41bb8a9-056b-41a7-b187-7c706f0f8702; ick=39b091b8-f882-499b-992b-34a682d3469a; JSESSIONID=abcHJrhG1CAIo64PJRrUw; jebe_key=9ca5b44f-aaec-4180-962e-bf7581ad6e5e%7Cc1d85b293dafa0e44367ceed107b877e%7C1561517245262%7C1%7C1561517244004; jebe_key=9ca5b44f-aaec-4180-962e-bf7581ad6e5e%7Cc1d85b293dafa0e44367ceed107b877e%7C1561517245262%7C1%7C1561517244011; wp_fold=0; td_cookie=18446744069457827825; jebecookies=e9de8580-fb15-4891-b7c3-7c08ebb41f5c|||||; _de=AE9934B6C85831351B86F7DDD5B20F8A; p=b25ab0edb69343d7f80c5e481864b8c30; first_login_flag=1; ln_uact=18620028487; ln_hurl=http://head.xiaonei.com/photos/0/0/men_main.gif; t=b8a0d848e228dd51d2c84609f814495b0; societyguester=b8a0d848e228dd51d2c84609f814495b0; id=971298880; xnsid=6e5116da; ver=7.0; loginfrom=null\" cookies = &#123;i.split(\"=\")[0]:i.split(\"=\")[1] for i in cookies.split(\"; \")&#125; yield scrapy.Request( self.start_urls[0], callback=self.parse, cookies=cookies )","permalink":"https://codermino.github.io/2020/07/26/scrapy%E6%B7%BB%E5%8A%A0cookie%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/","photos":[]},{"tags":[{"name":"scrapy爬虫细节","slug":"scrapy爬虫细节","permalink":"https://codermino.github.io/tags/scrapy%E7%88%AC%E8%99%AB%E7%BB%86%E8%8A%82/"}],"title":"scrapy爬虫细节","date":"2020/07/25","text":"scrapy.Request相关 yield scrapy.Request( url, callback, meta = &#123;\"item\":item&#125; ) 在对应的callback函数中可以使用下面的代码，接收上一个函数传递过来的参数。 item=response.meta['key'] 使用for...in 循环导致数据重复问题 在scrapy中使用了for in 循环，由于是多线程，如果还需要继续scrapy.Request进行请求更深的页面数据。 可以使用form copy import deepcopy 进行深拷贝。 可以防止scrapy多线程导致item的数据重复(上一个数据传递过来之后，后面的数据还没有解析完成， 下一个for循环，将传递下去的item的某些字段覆盖，从而可能导致重复) scrapy翻页 response.text =&gt; unicode编码返回body部分，等同于 response.body.decode(response.encoding) page_count = int(re. findall(\"var pagecount=.7);, response.body.decode())[0]) current_page = int(re. findall\"var currentPage=.2);, response.body.decode())[0] if current_page page_count: next_url item[\"s_href\"] +\"?pageNumber=[&amp;sort=\". format(current_page 1) yield scrapy. Request( next_url, callback=self.parse_book_list, meta = &#123;\"item\":response.meta[\"item\"]&#125; ) 创建CrawlSpider爬虫简要步骤 1.创建项目文件： scrapy startproject douyu 2.进入项目文件： cd douyu 3.创建爬虫 scrapy genspider -t crawl dy 'douyu.com' 正则的使用 def parse_item(self, response): item = &#123;&#125; item[\"title\"]=re.findall(\"&lt;!---TitleStart--&gt;(.*)&lt;--TitleEnd---&gt;\", response.body. decode())[0] item[\"publish_date\"] = re.findall(\"发布时间:(20\\d&#123;2&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;)\", response.body. decode())[0] CrawlSpider补充知识 CrawlSpider补充(了解) LinkExtractor更多常见参数: allow:满足括号中“正则表达式的URL会被提取,如果为空,则全部匹配。 (就是在当前的爬虫的页面，如果为True就会寻找当前页面是否有满足当前rule的连接，如果为False就不会继续寻找) deny:满足括号中“正则表达式\"的URL一定不提取(优先级高于 allow) allow_domains:会被提取的链接的 domains. deny_domains:一定不会被提取链接的 domains restrict_xpaths:使用 xpath表达式和 allow共同作用过滤链接,级 xpath足范围内的ur地址会被提取 spiders.rule常见参数: linkextractor:是一个 Link Extractor对象,用于定义需要提取的链接。 calLback:从linkextractor中每获取到链接时,参数所指定的值作为回调函数 follow:是一个布尔(boolean)值,指定了根据该规则从 response提取的链接是否需要跟进。 如果 callback为none, follow默认设置为Tre,否则默认为 False process_links:指定该 spider中哪个的函数将会被调用,从 linkextractor中获取到链接列表时将会调用该函数, 该方法主要用来过滤url process_request:指定该 spider中哪个的函数将会被调用,该规则提取到每个 request时都会调用该函数, 用来过滤 request 模拟登录的原因 scrapy模拟登陆 为什么需要模拟登陆? 获取 cookie,能够爬取登陆后的页面 回顾: requests是如何模拟登陆的? 1、直接携带 cookies请求页面 2、找接口发送post请求 cookie存储 selenium是如何模拟登陆的? 找到对应的 input标签,输入文字点击登录 dir函数的使用 在python2.7中, dir(response)查看response内置函数可以找到decode, encode()方法。 class CheckUserAgent: def process_response(self, request, response, spider): print(dir(response)) print(request.headers[User-Agent\"]) 添加代理 class RandomUserAgent(object): def process_request(self, request, spider): useragent= random.choice(UER_AGENTS) request.headers[\"User-Agent\"] = useragent #添加自定义的UA,给 requestheaders的赋值即可 class ProxyMiddleware(object) def process_request(self, request, spider): reqeust.meta [\"proxy\"] = \"http://124.115.126.76: 808\" #添加代理,需要在request的mea信息中添加字段 #代理的形式为:协议+ip地址+端口 发送post请求 使用scrapr.Request的时候一直是发送的get请求， 那么post请求就是需要使用scrapy.FormRequest来发送， 同时使用formdata来携带需要post的数据 scrapy模拟登陆之发送post请求 class GithubSpider(scrapy.Spider): name =github' allowed_domains ['github.com'] start_urls = ['https://github.com/login' -请求首页,为了获取登录参数 headers =&#123; \"Accept\":\"**\", \"Accept-Language\": \"en-US, en;q=. 8, zh-TW;q=0.6, zh; q=0.4\", &#125; def parse(self, response): print(response.url) utf8 = response.xpath(\"//form[@action='/session']/div[1]/input[1]/@value\").extract_first() authenticity_token = response.xpath(\"//form[@action='/session']/div[1]/input[2]/@value\").extract_first() return scrapy.FormRequest( \"https://github.com/session\", headers=self.headers, #可以在spider中定义,也可以在 setting中定义 formdata = dict( commit=\"Sign in\", utf8=utf8, authenticity_token=authenticity_token, login=\"user_name\",(对应的标签的name) password=\"password\"(对应的标签的name) ), callbackself = self.after_login #登录之后的回调函数 ) def after_login(self, response): print(response.url,\"*\"*100, response.status) 注意 : github的部分页面只允许一处登录,比如https:/github.comsettings/security 自动寻找post的action进行提交 import scrapy import re class Github2Spider(scrapy.Spider): name =github2' allowed_domains ['github.com'] start_urls =['https://github.com/login'] def parse(self, response): yield scrapy.FormRequest.from_response( response, #自动的从response中寻找from表单 formdata = &#123;\"login\":\"noobpythoner\",\"password\":\"zhoudawei1123\"&#125;, callback=self.after_login ) def after_login(self, response): print(re.findall(\"noobpythoner|NoobPythoner\", response.body.decode())) xpath的contains语法 div_list = response.xpath(\"//div[contains(@class,'i')]) 提取下一页的文本 next_url = response.xpath(\"//a[text()='下一页']/@href).extract_first() if next_url is not None: next_url = urllib","permalink":"https://codermino.github.io/2020/07/25/scrapy%E7%88%AC%E8%99%AB%E7%BB%86%E8%8A%82/","photos":[]},{"tags":[{"name":"Excel打开UTF8编码CSV文件乱码","slug":"Excel打开UTF8编码CSV文件乱码","permalink":"https://codermino.github.io/tags/Excel%E6%89%93%E5%BC%80UTF8%E7%BC%96%E7%A0%81CSV%E6%96%87%E4%BB%B6%E4%B9%B1%E7%A0%81/"}],"title":"Excel打开UTF8编码CSV文件乱码","date":"2020/07/25","text":"1. 新建一个excel表格 2. 执行“数据”-&gt;“自文本” 3. 选择 CSV 文件，出现文本导入向导 4. 选择“分隔符号”，下一步 5. 勾选“逗号”，去掉“ Tab 键”，下一步，完成 6. 在“导入数据”对话框里，直接点确定","permalink":"https://codermino.github.io/2020/07/25/Excel%E6%89%93%E5%BC%80UTF8%E7%BC%96%E7%A0%81CSV%E6%96%87%E4%BB%B6%E4%B9%B1%E7%A0%81/","photos":[]},{"tags":[{"name":"scrapy保存图片","slug":"scrapy保存图片","permalink":"https://codermino.github.io/tags/scrapy%E4%BF%9D%E5%AD%98%E5%9B%BE%E7%89%87/"}],"title":"scrapy保存图片","date":"2020/07/12","text":"为什么使用ImagesPipelines进行图片下载 1. 避免重新下载最近已经下载过的数据 2. 可以方便的指定文件存储的路径 3. 可以将下载的图片转换成通用的格式。比如png或jpg 4. 可以方便的成成缩略图 5. 可以方便的检测图片的宽和高，确保他们满足最小限制 6. 异步下载，效率非常高 crawl.py文件内容 import scrapy from bmw.items import BmwItem #引入item文件的BmwItem类 class Bmw5Spider(scrapy.Spider): name = 'bmw5' start_urls = ['https://car.autohome.com.cn/pic/series/4350.html'] def parse(self, response): uiboxs=response.xpath(\"//div[@class='uibox']\")[1:] for uibox in uiboxs: title=uibox.xpath(\".//div[@class='uibox-title']/a/text()\").get() #获取分类的标题 images=uibox.xpath(\".//ul/li/a/img/@src\").getall() #获取所有图片的url地址 urls=list(map(lambda url:response.urljoin(url),images)) #将图片的url地址进行处理，前面加上https:// item=BmwItem(title=title,image_urls=urls) #进行包装 yield item #返回给items.py文件 items.py文件内容 import scrapy class BmwItem(scrapy.Item): title=scrapy.Field() #用来存储图片分类的名称标题 image_urls=scrapy.Field() #用来存储需要下载的图片的url images=scrapy.Field() #用来保存下载之后图片的本地路径 方法一、同步的方式进行图片下载 这样下载的方式是一个一个的下载，下载的效率比较低， 同步的方式进行下载 import os from urllib import request class BmwPipeline(object): def __init__(self): #os.path.dirname(__file__)获得当前文件所在的上级目录 #创建项目工程下的iamges文件夹 self.path=os.path.join(os.path.dirname(os.path.dirname(__file__)),'images') #判断images文件夹是否存在，如果不存在则创建 if not os.path.exists(self.path): os.mkdir(self.path) #这个函数会自动调用,每次爬取一个item就会调用一次进行数据的处理 def process_item(self, item, spider): title=item['title'] #图片所在分类的标题 urls=item['image_urls'] #分类下图片的url地址 category_path=os.path.join(self.path,title) #创建分类文件夹 if not os.path.exists(category_path): os.mkdir(category_path) #遍历urls数组，进行图片下载 for url in urls: image_name=url.split('_')[-1] #按照_进行拆分得到图片的名称 request.urlretrieve(url,os.path.join(category_path,image_name)) #进行图片的下载 return item 对应的settings.py文件内容 ITEM_PIPELINES = &#123; 'bmw.pipelines.BmwPipeline': 300, #开启pipelines &#125; 方法二、使用scrapy自带的ImagesPipeline settings.py文件的内容 IMAGES_EXPIRES = 90 # 90天内抓取的都不会被重抓 ITEM_PIPELINES = &#123; 'scrapy.pipelines.images.ImagesPipeline': 1, &#125; 方法三、重写ImagesPipeline---Demo1 import os from urllib import request from scrapy.pipelines.images import ImagesPipeline from bmw import settings #继承了ImagesPipeline这个类 class BMWImagePipeline(ImagesPipeline): def get_media_requests(self, item, info): #这个方法是在发送下载请求之前调用 #其实这个方法本身就是去发送下载请求的 request_objs=super(BMWImagePipeline, self).get_media_requests(item,info) for request_obj in request_objs: request_obj.item=item return request_objs # 我们可以通过继承FilesPipeline重写file_path() # 方法来重定义文件名 def file_path(self, request, response=None, info=None): #这个方法是在图片将要被存储的时候调用的，来获取这个图片存储的路径 path=super(BMWImagePipeline, self).file_path(request,response,info) category=request.item.get('title') image_store=settings.IMAGES_STORE category_path=os.path.join(image_store,category) if not os.path.exists(category_path): os.mkdir(category_path) image_name=path.replace(\"full/\",'') image_path=os.path.join(category_path,image_name) return image_path def item_completed(self, results, item, info): \"\"\" 将图片的本地路径赋值给item['image_paths'] :param results:下载结果，二元组定义如下：(success, image_info_or_failure)。 第一个元素表示图片是否下载成功；第二个元素是一个字典。 如果success=true，image_info_or_error词典包含以下键值对。失败则包含一些出错信息。 字典内包含* url：原始URL * path：本地存储路径 * checksum：校验码 :param item: :param info: :return: \"\"\" # print(results) image_paths = [x['path'] for ok, x in results if ok] if not image_paths: raise DropItem(\"Item contains no images\") # 如果没有路径则抛出异常 item['images'] = image_paths return item 方法三、重写ImagesPipeline---Demo2 #引入其他所需的相关模块 from scrapy import Request from scrapy.exceptions import DropItem category = '' #继承了ImagesPipeline这个类 class BMWImagePipeline(ImagesPipeline): global category #用来存储下载的图片所属的分类标题 category = item['title'] for img_url in item['image_urls']: #遍历image_urls并发起请求 yield Request(img_url) # 我们可以通过继承FilesPipeline重写file_path() # 方法来重定义文件名 def file_path(self, request, response=None, info=None): image_store=settings.IMAGES_STORE #获取settings.py中配置的图片下载路径 category_path=os.path.join(image_store,category) #创建分类名称文件夹 if not os.path.exists(category_path): #不存在则进行创建 os.mkdir(category_path) image_name = request.url.split(\"__\")[-1] #将图片的url地址按照_进行拆分得到图片的名称 return os.path.join(category_path,image_name) #拼接下载的图片的路径 def item_completed(self, results, item, info): \"\"\" 将图片的本地路径赋值给item['image_paths'] :param results:下载结果，二元组定义如下：(success, image_info_or_failure)。 第一个元素表示图片是否下载成功；第二个元素是一个字典。 如果success=true，image_info_or_error词典包含以下键值对。失败则包含一些出错信息。 字典内包含* url：原始URL * path：本地存储路径 * checksum：校验码 :param item: :param info: :return: \"\"\" # print(results) #results 数组第一个参数为表示图片是否下载成功；第二个元素是一个字典。 #ok, x in results 遍历results数组 if ok 成立 去除x['path']并且包装成数组返回给image_paths image_paths = [x['path'] for ok, x in results if ok] if not image_paths: raise DropItem(\"Item contains no images\") # 如果没有路径则抛出异常 item['images'] = image_paths #将下载之后的图片的本地路径保存在items.py的images中 #也可以在这里使用os.rename进行文件的重命名 return item Demo2对应的settings.py文件配置 #设置图片的存储路径 IMAGES_STORE=os.path.join(os.path.dirname(os.path.dirname(__file__)),'images4') #90天内抓取的都不会被重抓 IMAGES_EXPIRES = 90 #90天内抓取的都不会被重抓 ITEM_PIPELINES = &#123; 'bmw.pipelines.BMWImagePipeline':1 &#125; ImagesPipelines的其他作用---保存缩略图 settings.py文件的相关配置 # 设置图片缩略图 IMAGES_THUMBS = &#123; 'small': (50, 50), 'big': (250, 250), &#125; # 图片过滤器，最小高度和宽度，低于此尺寸不下载 # 注意：这些尺寸的限制不会影响缩略图生成 # 默认情况下，没有限制，所有的图片都会被处理。 IMAGES_MIN_HEIGHT = 70 IMAGES_MIN_WIDTH = 70 piplines文件内容---更改thumbs缩略图保存的文件路径 def thumb_path(self, request, thumb_id, response=None, info=None): ## start of deprecation warning block (can be removed in the future) def _warn(): from scrapy.exceptions import ScrapyDeprecationWarning import warnings warnings.warn('ImagesPipeline.thumb_key(url) method is deprecated, please use ' 'thumb_path(request, thumb_id, response=None, info=None) instead', category=ScrapyDeprecationWarning, stacklevel=1) # check if called from thumb_key with url as first argument if not isinstance(request, Request): _warn() url = request else: url = request.url # detect if thumb_key() method has been overridden if not hasattr(self.thumb_key, '_base'): _warn() return self.thumb_key(url, thumb_id) ## end of deprecation warning block thumb_guid = hashlib.sha1(to_bytes(url)).hexdigest() # change to request.url after deprecation return 'thumbs/%s/%s/%s.jpg' % (category,thumb_id, thumb_guid)","permalink":"https://codermino.github.io/2020/07/12/scrapy%E4%BF%9D%E5%AD%98%E5%9B%BE%E7%89%87/","photos":[]},{"tags":[{"name":"scrapy数据保存为xml格式","slug":"scrapy数据保存为xml格式","permalink":"https://codermino.github.io/tags/scrapy%E6%95%B0%E6%8D%AE%E4%BF%9D%E5%AD%98%E4%B8%BAxml%E6%A0%BC%E5%BC%8F/"}],"title":"scrapy数据存为xml格式","date":"2020/07/12","text":"scrapy crawl myspider -o data.xml","permalink":"https://codermino.github.io/2020/07/12/scrapy%E6%95%B0%E6%8D%AE%E5%AD%98%E4%B8%BAxml%E6%A0%BC%E5%BC%8F/","photos":[]},{"tags":[{"name":"scrapy数据存入csv文件","slug":"scrapy数据存入csv文件","permalink":"https://codermino.github.io/tags/scrapy%E6%95%B0%E6%8D%AE%E5%AD%98%E5%85%A5csv%E6%96%87%E4%BB%B6/"}],"title":"scrapy数据存入csv文件","date":"2020/07/11","text":"方法一、通过终端方式 scrapy crawl name(爬虫名字) -o result.csv tip: #在pycharm中可以新建一个start.py加入如下内容，然后运行即可 from scrapy import cmdline cmdline.execute(\"scrapy crawl field(爬虫名字) -o info.csv -t csv\".split()) 方法一、通过pipelines方式 from scrapy.exporters import CsvItemExporter class CsvPipeline（object）： def __init __（self）： self.file = open（“xxx.csv”，'wb'） self.exporter = CsvItemExporter（self.file， encoding='utf-8'） self.exporter.start_exporting（） def close_spider（ self，spider）： self.exporter.finish_exporting（） self.file.close（） def process_item（self，item，spider）： self.exporter.export_item（item） return item Demo2--pipelines方式 import csv class MyProjectPipeline(object): # 保存为csv格式 def __init__(self): # 打开文件，指定方式为写，利用第3个参数把csv写数据时产生的空行消除 self.f = open(\"myproject.csv\",\"a\",newline=\"\") # 设置文件第一行的字段名，注意要跟spider传过来的字典key名称相同 self.fieldnames = [\"goods_sketch\",\"goods_img\",\"good_price\",\"goods_shop\",\"b_href\",\"title\"] # 指定文件的写入方式为csv字典写入，参数1为指定具体文件，参数2为指定字段名 self.writer = csv.DictWriter(self.f, fieldnames=self.fieldnames) # 写入第一行字段名，因为只要写入一次，所以文件放在__init__里面 self.writer.writeheader() def process_item(self, item, spider): # 写入spider传过来的具体数值 self.writer.writerow(item) # 写入完返回 return item def close(self,spider): self.f.close()","permalink":"https://codermino.github.io/2020/07/11/scrapy%E6%95%B0%E6%8D%AE%E5%AD%98%E5%85%A5csv%E6%96%87%E4%BB%B6/","photos":[]},{"tags":[{"name":"scrapy数据存入json文件","slug":"scrapy数据存入json文件","permalink":"https://codermino.github.io/tags/scrapy%E6%95%B0%E6%8D%AE%E5%AD%98%E5%85%A5json%E6%96%87%E4%BB%B6/"}],"title":"scrapy数据写入json文件","date":"2020/07/11","text":"方法一、使用终端命令 scrapy crawl novel -o novel.json 方法二、使用pipelines from scrapy.exporters import JsonItemExporter # JsonItemExporter：一次性写入大量数据，占用内存 from scrapy.exporters import JsonLinesItemExporter # 逐条写入 class JsonPipeline(object): def __init__(self): self.fp = open('sftaobao.json', 'wb') # ensure_ascii=False:以中文字符保存 self.exporter = JsonItemExporter(self.fp, ensure_ascii=False, encoding='utf-8') # JsonLinesItemExporter：一个字典一行，整个文件不满足json格式的；数据都直接存到磁盘文件中，内存占用少. # self.exporter = JsonLinesItemExporter(self.fp, ensure_ascii=False, encoding='utf-8') #不需要start_exporting和finish_exporting self.exporter.start_exporting() # 以标识 exporting 过程的开始。 def open_sprider(self): pass def process_item(self, item, spider): self.exporter.export_item(item) return item def close_sprider(self, spider): self.exporter.finish_exporting() # 以标识 exporting 过程的结束 self.fp.close() 方法三、文件读写方式 import json class JsonWriterPipeline(object): def open_spider(self, spider): #在爬虫开启的时候执行,仅执行一次 self. file =open(spider. settings.get( \"SAVE_FILE\", \"./temp.json\"), 'w') def close_spider(self, spider): #在爬虫关闭的时候执行,仅执行一次 self.file.close() def process_item(self, item, spider): line=json. dumps(dict(item))+\"\\n\" self.file.write(line) return item #不return的情况下,另个一个权重较低的 pipeline就不会获取到该item","permalink":"https://codermino.github.io/2020/07/11/scrapy%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5json%E6%96%87%E4%BB%B6/","photos":[]},{"tags":[{"name":"scrapy数据存入redis","slug":"scrapy数据存入redis","permalink":"https://codermino.github.io/tags/scrapy%E6%95%B0%E6%8D%AE%E5%AD%98%E5%85%A5redis/"}],"title":"scrapy数据存入redis","date":"2020/07/11","text":"import redis class QiubaiproPipelineByRedis(object): conn = None def open_spider(self,spider): print('开始爬虫') # 创建链接对象 self.conn = redis.Redis(host='127.0.0.1',port=6379) def process_item(self, item, spider): dict = &#123; 'author':item['author'], 'content':item['content'] &#125; # 写入redis中 self.conn.lpush('data', dict) return item from scrapy.exceptions import DropItem def process_item(self, item, spider): #当添加失败的时候会返回一个0 if self.conn.sadd('data',item['author']) return item #丢掉不符合条件的item raise DropItem","permalink":"https://codermino.github.io/2020/07/11/scrapy%E6%95%B0%E6%8D%AE%E5%AD%98%E5%85%A5redis/","photos":[]},{"tags":[{"name":"scrapy数据存入mongodb","slug":"scrapy数据存入mongodb","permalink":"https://codermino.github.io/tags/scrapy%E6%95%B0%E6%8D%AE%E5%AD%98%E5%85%A5mongodb/"}],"title":"scrapy数据存入mongodb","date":"2020/07/11","text":"存入mongodb def __init__(self): host = settings['MONGODB_HOST'] #数据库的host 如:127.0.0.1 port = settings['MONGODB_PORT'] #数据库端口号 如：27017 dbname = settings['MONGODB_DBNAME'] #数据库名称 如:XXX # 创建数据库连接 client = pymongo.MongoClient(host=host, port=port) # 指向指定数据库 mdb = client[dbname] # 获取数据库里面存放数据的表名 self.post = mdb[settings['MONGODB_DOCNAME']] def process_item(self, item, spider): data = dict(item) # 向指定的表里添加数据 self.post.insert(data) return item Demo2 from pymongo import MongoClient class xxxPipeline(object): def open_spider(self,spider): client = MongoClient() self.collection = client['test']['test'] def process_item(self,item,spider): spider.setting,get('MONGO_HOST') item['content'] = self.process_content(item['content']) print(item) return item def process_content(self,content): content = [re.sub(r\"\\xa0|\\s\",\"\",i) for i in content] content = [i for i in content if len(i)&gt;0] #去除列表中的空字符串 return content","permalink":"https://codermino.github.io/2020/07/11/scrapy%E6%95%B0%E6%8D%AE%E5%AD%98%E5%85%A5mongodb/","photos":[]},{"tags":[{"name":"scrapy数据存入mysql","slug":"scrapy数据存入mysql","permalink":"https://codermino.github.io/tags/scrapy%E6%95%B0%E6%8D%AE%E5%AD%98%E5%85%A5mysql/"}],"title":"scrapy数据存入mysql","date":"2020/07/11","text":"1、同步方式 import pymysql #引入相关库 class MysqlPipeline(object): \"\"\" 同步操作 \"\"\" def __init__(self): # 建立连接,下面是两种方式 1. self.conn = pymysql.connect( host='localhost', db='bole', user='root', passwd='123456', charset='utf8', port=330, use_unicode=True) 2. self.conn = pymysql.connect('localhost','root','Abcd1234','test') # 有中文要存入数据库的话要加charset='utf8' # 创建游标 self.cursor = self.conn.cursor() #每爬取到一条数据就会调用一次process_item函数 def process_item(self,item,spider): # sql语句 try: # 查重处理,根据表的主键进行一次查询，查看是否有重复数据 self.cursor.execute( \"\"\"select * from doubanmovie where img_url = %s\"\"\", item['img_url']) # 是否有重复数据 repetition = self.cursor.fetchone() if repetition: #两种方式丢弃无效数据 1. pass 2. raise DropItem(\"Missing price in %s\" % item) #需要引入相关的模块from scrapy.exceptions import DropItem else: insert_sql = \"\"\" insert into test_zxf(quote,author,tags,born_date,born_location) VALUES(%s,%s,%s,%s,%s) \"\"\" # 执行插入数据到数据库操作 self.cursor.execute(insert_sql,(item['quote'],item['author'],item['tags'],item['born_date'], item['born_location'])) # 提交，不进行提交无法保存到数据库 self.conn.commit() except Exception as error: # 出现错误时打印错误日志 self.conn.rollback() log(error) return item def close_spider(self,spider): # 关闭游标和连接 self.cursor.close() self.conn.close() 同步方式Demo2 class WhfjPipeline(object): def __init__(self): dbparams = &#123; 'host': '127.0.0.1', 'user': 'root', 'password': '19980211', 'database': 'fangjia', 'port': 3306, 'charset': 'utf8' &#125; self.conn = pymysql.connect(**dbparams) self.cursor = self.conn.cursor() self._sql = None def process_item(self, item, spider): self.cursor.execute(self.sql, (item['xiaoqu_name'], item['position'], item['price'])) self.conn.commit() return item #将一个方法变为属性进行调用 @property def sql(self): if not self._sql: self._sql = \"\"\" insert into fangchan2(id,xiaoqu_name,position,price) values(null,%s,%s,%s); \"\"\" return self._sql return self._sql tip: ### # 我们可以使用@property装饰器来创建只读属性，@property装饰器会将方法转换为相同名称的只读属性,可以与所定义的属性配合使用，这样可以防止属性被修改。 # class DataSet(object): # @property # def method_with_property(self): ##含有@property # return 15 # def method_without_property(self): ##不含@property # return 15 # # l = DataSet() # print(l.method_with_property) # 加了@property后，可以用调用属性的形式来调用方法,后面不需要加（）。 # print(l.method_without_property()) #没有加@property , 必须使用正常的调用方法的形式，即在后面加() ### 1、异步方式 #piplines调用 from scrapyDemo.db.dbhelper import DBHelper class ScrapydemoPipeline(object): # 连接数据库 def __init__(self): self.db = DBHelper() def process_item(self, item, spider): # 插入数据库 self.db.insert(item) return item #这里面我们用到了数据库的操作DBHelper类，那 #么我们在scrapyDemo/db目录下创建dbhelper.py 模块，记得再创建一个__init__.py哦。 import pymysql from twisted.enterprise import adbapi from scrapy.utils.project import get_project_settings #导入seetings配置 import time class DBHelper(): '''这个类也是读取settings中的配置，自行修改代码进行操作''' def __init__(self): settings = get_project_settings() #获取settings配置，设置需要的信息 #或者使用这种方式来获取settings中定义的变量 userAgent = settings.get('USER_AGENT') dbparams = dict( host=settings['MYSQL_HOST'], #读取settings中的配置 db=settings['MYSQL_DBNAME'], user=settings['MYSQL_USER'], passwd=settings['MYSQL_PASSWD'], charset='utf8', #编码要加上，否则可能出现中文乱码问题 cursorclass=pymysql.cursors.DictCursor, use_unicode=False, ) #**表示将字典扩展为关键字参数,相当于host=xxx,db=yyy.... dbpool = adbapi.ConnectionPool('pymysql', **dbparams) self.dbpool = dbpool def connect(self): return self.dbpool #创建数据库 def insert(self, item): sql = \"insert into tech_courses(title,image,brief,course_url,created_at) values(%s,%s,%s,%s,%s)\" #调用插入的方法 query = self.dbpool.runInteraction(self._conditional_insert, sql, item) #调用异常处理方法 query.addErrback(self._handle_error) return item #写入数据库中 def _conditional_insert(self, tx, sql, item): item['created_at'] = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time())) params = (item[\"title\"], item['image'], item['brief'], item['course_url'], item['created_at']) tx.execute(sql, params) #错误处理方法 def _handle_error(self, failue): print('--------------database operation exception!!-----------------') print(failue) #demo2: #tip: 1. @classmethod不需要self参数，但第一个参数需要是表示自身类的cls参数。 # 用twisted库将数据进行异步插入到数据库 class MysqlTwistedPipeline(object): def __init__(self, dbpool): self.dbpool = dbpool #这个函数会自动调用 @classmethod def from_settings(cls, settings): # 需要在setting中设置数据库配置参数 dbparms = dict( host=settings['MYSQL_HOST'], db=settings['MYSQL_DBNAME'], user=settings['MYSQL_USER'], passwd=settings['MYSQL_PASSWORD'], charset='utf8', cursorclass=MySQLdb.cursors.DictCursor, use_unicode=True, ) # 连接ConnectionPool（使用MySQLdb连接，或者pymysql） dbpool = adbapi.ConnectionPool(\"pymysql\", **dbparms) # **让参数变成可变化参数 return cls(dbpool) # # 返回一个pipeline实例化对象 def process_item(self, item, spider): # 使用twisted将MySQL插入变成异步执行 #使用数据库连接池对象进行数据库操作,自动传递cursor对象到数据库操作方法的第一个参数 query = self.dbpool.runInteraction(self.do_insert, item) # 添加异常处理 query.addCallback(self.handle_error) def handle_error(self, failure): # 处理异步插入时的异常 print(failure) def do_insert(self, cursor, item): # 执行具体的插入 insert_sql = \"\"\" insert into jobbole_artitle(name, base_url, date, comment) VALUES (%s, %s, %s, %s) \"\"\" #这里不需要进行commit()提交，adbapi会进行自动的commit cursor.execute(insert_sql, (item['name'], item['base_url'], item['date'], item['coment'],)) 最后的tip: 在python1.7以前的版本引入settings中定义的常量的方式可以使用: from scrapy.conf import settings 但是在1.7版本之后,scrapy.conf就被移除了，1.7以后的版本里，正确使用 settings.py中配置的方法是: from scrapy.utils.project import get_project_settings settings = get_project_settings() host = settings['MONGODB_HOST] port = settings['MONGODB_PORT']","permalink":"https://codermino.github.io/2020/07/11/scrapy%E6%95%B0%E6%8D%AE%E5%AD%98%E5%85%A5mysql/","photos":[]},{"tags":[{"name":"markdown基本语法","slug":"markdown基本语法","permalink":"https://codermino.github.io/tags/markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"}],"title":"markdown基本语法","date":"2020/07/11","text":"+ space = 原点 数字+.+space=有序列表 #+space一级标题 ##+space二级标题 **字符**加粗 *字符*斜体 &gt;+space说明文字 ```+语言=代码块 内容原封不动的显示使用` 超链接 [百度](https://www.baidu.com)","permalink":"https://codermino.github.io/2020/07/11/markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/","photos":[]},{"tags":[{"name":"python引入模块的四种方式","slug":"python引入模块的四种方式","permalink":"https://codermino.github.io/tags/python%E5%BC%95%E5%85%A5%E6%A8%A1%E5%9D%97%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F/"}],"title":"python引入模块四种方式","date":"2020/07/11","text":"1. import time #使用import模块名直接导入一个模块 2. from random import randint #from模块名 import函数名,导入一个模块里的方法或者变量 3. from math import* #from模块名 import*导入这个模块里的\"所有方法和变量 4. import datetime as dt #导入一个模块并给这个模块起一个别名 5. from copy import deepcopy as dp #from模块名 import函数名as别名","permalink":"https://codermino.github.io/2020/07/11/python%E5%BC%95%E5%85%A5%E6%A8%A1%E5%9D%97%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F/","photos":[]},{"tags":[{"name":"python字符串前修饰符","slug":"python字符串前修饰符","permalink":"https://codermino.github.io/tags/python%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%89%8D%E4%BF%AE%E9%A5%B0%E7%AC%A6/"}],"title":"python字符串前修饰符","date":"2020/07/05","text":"1、字符串前加 u 例：u\"我是含有中文字符组成的字符串。\" 作用： 后面字符串以 Unicode 格式 进行编码，一般用在中文字符串前面，防止因为源码储存格式问题，导致再次使用时出现乱码。 2、字符串前加 r 例：r\"\\n\\n\\n\\n” # 表示一个普通生字符串 \\n\\n\\n\\n，而不表示换行了。 作用： 去掉反斜杠的转移机制。 （特殊字符：即那些，反斜杠加上对应字母，表示对应的特殊含义的，比如最常见的”\\n”表示换行，”\\t”表示Tab等。 ） 应用： 常用于正则表达式，对应着re模块。 3、字符串前加 b 例: response = b'Hello World!' # b' ' 表示这是一个 bytes 对象 作用： b\" \"前缀表示：后面字符串是bytes 类型。 用处： 网络编程中，服务器和浏览器只认bytes 类型数据。 如：send 函数的参数和 recv 函数的返回值都是 bytes 类型 附： 在 Python3 中，bytes 和 str 的互相转换方式是 str.encode('utf-8') bytes.decode('utf-8') 具体见底部代码 python str与bytes之间的转换 4、字符串前加 f import time t0 = time.time() time.sleep(1) name = 'processing' # 以 f开头表示在字符串内支持大括号内的python 表达式 print(f'{name} done in {time.time() - t0:.2f} s') 输出： processing done in 1.00 s # bytes object b = b\"example\" # str object s = \"example\" # str to bytes sb = bytes(s, encoding = \"utf8\") # bytes to str bs = str(b, encoding = \"utf8\") # an alternative method # str to bytes sb2 = str.encode(s) # bytes to str bs2 = bytes.decode(b)","permalink":"https://codermino.github.io/2020/07/05/python%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%89%8D%E4%BF%AE%E9%A5%B0%E7%AC%A6/","photos":[]},{"tags":[{"name":"pyinstaller","slug":"pyinstaller","permalink":"https://codermino.github.io/tags/pyinstaller/"}],"title":"pyinstaller的使用","date":"2020/07/05","text":"pyinstaller -F -w TestDataGen.py pyinstaller -Fw -i xxx.ico TestDataGen.py","permalink":"https://codermino.github.io/2020/07/05/pyinstaller%E7%9A%84%E4%BD%BF%E7%94%A8/","photos":[]},{"tags":[{"name":"git","slug":"git","permalink":"https://codermino.github.io/tags/git/"}],"title":"git提交pr","date":"2020/07/05","text":"简单过程 首先git分为本地仓库(自己电脑中)和远程仓库(git官网自己的账号中)，仓库可以理解为保存代码的地方， 简单的说是在自己本地仓库修改代码，提交到自己远程仓库，提交pr后被接受后再会被合并到master。 下面一步一步来。 详细过程 申请账号、添加ssh公钥等过程就不说了哈。 fork 将项目fork到自己的仓库中，可以在github的首页搜索到自己的想要的开源项目， 我以flink为例： 进去后，点出fork，稍等片刻，此项目便会出现在自己的仓库中 进到自己fork的项目中，就能看到Clone or download按钮，如下，记下这个https链接。 通过上面的步骤，已经将远程仓库建好 clone 需要将远程仓库clone到本地，此处省略安装本地github的过程， 随便在哪个目录(项目存放的目录)，右键打开一个Git base， 执行一下git clone https://github.com/***/***.git(使用上一步的https链接)， 等待命令完成，时间视下载速度而定，也许会比较慢， 网上也有些可以提高git clone速度的方法，不防一试。 上面的命令完成后，当前目录下会多一个目录，我clone的是flink， 所以会多一个flink目录，进到flink目录中，试试跑一下git status试试，会提示现在是master分支。 用git remote -v命令，可以看到此时只与自己的远程仓库建立了连接 还需要与上游建立连接，这里上游指的是一开始fork的那个项目源，以flink为例，执行如下命令： git remote add upstream https://github.com/apache/flink.git 再用git remote -v可以看到： 接下来就能创建分支了。 创建分支 接着上面的运行命令：git checkout -b flink-fs， 这个命令的意思是创建一个叫flink-fs的分支，运行这个命令后bash将自动切换到新的分支下. 修改代码 自行修改代码. 提交 可以先使用git status来查看有哪些文件被修改了 然后再git add ***.java将要提交的文件都加上 然后再git commit -m \"modify XX\"，需要注意的是git commit只是把修改的代码提交到当前分支(当前分支是flink-fs，而不是master)，”modify XX”是本次提交的简单说明 然后再git push origin flink-fs，这一步才是将当前分支推送到自己的远程仓库。 这时，在自己的远程仓库便能看刚才push上去的分支了 提交pr 找到New pull request 需要注意的是compare处选择刚才提交上来的分支 然后点Create pull request 写好名字，写好说明，提交，就OK啦。","permalink":"https://codermino.github.io/2020/07/05/git%E6%8F%90%E4%BA%A4pr/","photos":[]},{"tags":[{"name":"git","slug":"git","permalink":"https://codermino.github.io/tags/git/"}],"title":"git同步更新fork项目","date":"2020/07/05","text":"master:git同步更新fork项目 1、打开fork 过来的项目如下所示： 2、点击new pull request 3、在进入的界面， 后进行将左边的设置为你自己的仓库， fork 过来的源在右边， 如下图： 4、当选择完后会变成下图（关键步骤，千万不可选错分支） 5、接下来， 将其展示出可以调整状态： 右边改为源fork地址 6、就会出现变更数据： 7、点击create pull request 8、进行数据的合并： 9 、最后合并!","permalink":"https://codermino.github.io/2020/07/05/git%E5%90%8C%E6%AD%A5%E6%9B%B4%E6%96%B0fork%E9%A1%B9%E7%9B%AE/","photos":[]},{"tags":[{"name":"cookie和session的区别","slug":"cookie和session的区别","permalink":"https://codermino.github.io/tags/cookie%E5%92%8Csession%E7%9A%84%E5%8C%BA%E5%88%AB/"}],"title":"cookie和session的区别","date":"2020/06/25","text":"cookie 和session 的区别详解 这些都是基础知识，不过有必要做深入了解。 先简单介绍一下。二者的定义：当你在浏览网站的时候，WEB 服务器会先送一小小资料放在你的计算机上， Cookie 会帮你在网站上所打的文字或是一些选择，都纪录下来。 当下次你再光临同一个网站，WEB 服务器会先看看有没有它上次留下的 Cookie 资料， 有的话，就会依据 Cookie里的内容来判断使用者，送出特定的网页内容给你。 Cookie 的使用很普遍，许多有提供个人化服务的网站，都是利用 Cookie来辨认使用者， 以方便送出使用者量身定做的内容，像是 Web 接口的免费 email 网站，都要用到 Cookie。 具体来说cookie机制采用的是在客户端保持状态的方案， 而session机制采用的是在服务器端保持状态的方案。同时我们也看到， 由于采用服务器端保持状态的方案在客户端也需要保存一个标识， 所以session机制可能需要借助于cookie机制来达到保存标识的目的，但实际上它还有其他选择。 cookie机制。正统的cookie分发是通过扩展HTTP协议来实现的， 服务器通过在HTTP的响应头中加上一行特殊的指示以提示浏览器按照指示生成相应的cookie。 然而纯粹的客户端脚本如JavaScript或者VBScript也可以生成cookie。 而cookie的使用是由浏览器按照一定的原则在后台自动发送给服务器的。 浏览器检查所有存储的cookie，如果某个cookie所声明的作用范围大于等于将要请求的资源所在的位置， 则把该cookie附在请求资源的HTTP请求头上发送给服务器。 cookie的内容主要包括：名字，值，过期时间，路径和域。 路径与域一起构成cookie的作用范围。 若不设置过期时间，则表示这个cookie的生命期为浏览器会话期间， 关闭浏览器窗口，cookie就消失。这种生命期为浏览器会话期的cookie被称为会话cookie。 会话cookie一般不存储在硬盘上而是保存在内存里，当然这种行为并不是规范规定的。 若设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器， 这些cookie仍然有效直到超过设定的过期时间。 存储在硬盘上的cookie可以在不同的浏览器进程间共享，比如两个IE窗口。 而对于保存在内存里的cookie，不同的浏览器有不同的处理方式session机制。 session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。 当程序需要为某个客户端的请求创建一个session时， 服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id）， 如果已包含则说明以前已经为此客户端创建过session， 服务器就按照session id把这个session检索出来使用（检索不到，会新建一个）， 如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id， session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发送给服务器。一般这个cookie的名字都是类似于SEEESIONID。但cookie可以被人为的禁止，则必须有其他机制以便在cookie被禁止时仍然能够把session id传递回服务器。经常被使用的一种技术叫做URL重写，就是把session id直接附加在URL路径的后面。还有一种技术叫做表单隐藏字段。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器。比如： &lt;form name=\"testform\" action=\"/xxx\"&gt; &lt;input type=\"hidden\" name=\"jsessionid\" value=\"ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764\"&gt; &lt;input type=\"text\"&gt; &lt;/form&gt; 实际上这种技术可以简单的用对action应用URL重写来代替。 cookie 和session 的区别： 1、cookie数据存放在客户的浏览器上，session数据放在服务器上。 2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗,考虑到安全应当使用session。 3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能, 考虑到减轻服务器性能方面，应当使用COOKIE。 4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。 5、所以个人建议：将登陆信息等重要信息存放为SESSION,其他信息如果需要保留，可以放在COOKIE中 Jwt和一些权限 JWT 一般和 OAuth2 使用。 对外服务器使用 OAuth2，类似于三方的 API ; 内部使用 JWT 进行服务与服务间的交互，也就是内网间的传输。 OAuth2 进行授权用，JWT 是让系统知道你是谁。 OAuth2 转 JWT 一般在网关层进行转换。","permalink":"https://codermino.github.io/2020/06/25/cookie%E5%92%8Csession%E7%9A%84%E5%8C%BA%E5%88%AB/","photos":[]},{"tags":[{"name":"爬虫下载图片","slug":"爬虫下载图片","permalink":"https://codermino.github.io/tags/%E7%88%AC%E8%99%AB%E4%B8%8B%E8%BD%BD%E5%9B%BE%E7%89%87/"}],"title":"网页图片批量获取（Python教程）","date":"2020/06/25","text":"图片下载（知识点） urllib 库 我们首先了解一下 urllib 库，它是 Python 内置的 HTTP 请求库，也就是说我们不需要额外安装即可使用，它包含四个模块： 第一个模块 request，它是最基本的 HTTP 请求模块，我们可以用它来模拟发送一请求。 就像在浏览器里输入网址，然后敲击回车一样，只需要给库方法传入 URL ， 还有额外的参数，就可以模拟实现这个过程了； 第二个 error 模块即异常处理模块，如果出现请求错误，我们可以捕获这些异常， 然后进行重试或其他操作，保证程序不会意外终止； 第三个 parse 模块是一个工具模块，提供了许多 URL 处理方法，比如拆分、解析、合并等等的方法； 第四个模块是 robotparser，主要是用来识别网站的 robots.txt 文件， 然后判断哪些网站可以爬，哪些网站不可以爬，其实用的比较少。 使用 urlopen() 发送请求 urllib.request 模块提供了最基本的构造 HTTP 请求的方法，利用它可以模拟浏览器的一个请求发起过程，同时它还带有处理 authenticaton（授权验证）、 redirections（重定向)、 cookies（浏览器 Cookies）以及其它内容。 接下来，我们来感受下它的强大之处，以百度为例 ，我们把网页爬取下来。 code: import urllib.request response = urllib.request.urlopen('https://www.baidu.com') print(response.read().decode('utf-8')) urllib.request.urlopen（URL） ：发送 HTTP 请求，返回为 HTTPResponse； response.read() : 获取 HTTP 请求之后响应的内容。 IO open() file object = open(file_name [, access_mode][, buffering]) 打开 file 对象，并返回对应的数据流。如果打开失败，则抛出 IOError异常。 file_name： file_name 变量是一个包含了你要访问的文件名称的字符串值； access_mode ： access_mode 决定了打开文件的模式：只读( r)，写入(w)，追加(a)，创建(x)等。这个参数是非强制的，默认文件访问模式为只读( r)； buffering : 如果 buffering 的值被设为 0，就不会有寄存。如果 buffering 的值取 1，访问文件时会寄存行。如果将 buffering 的值设为大于 1 的整数，表明这就是寄存区的缓冲大小。如果取负值，则寄存区的缓冲大小为系统默认。 上面介绍了这么多知识点，接下来举个“栗子”吧，让我们体验下如何使用 open() 函数。 # 打开一个文件(文件必须已经存在) fo = open(\"example.txt\", \"w\") fo.write( \"\"\"这个博主值得你关注! 这篇博客值得你点赞！ \"\"\") # 关闭打开的文件 fo.close() OS库 os 模块代表了程序所在的操作系统，主要用于获取程序运行所在操作系统的相关信息。 举个“栗子”：创建目录： import os # 创建的目录 path = \"/tmp/home/monthly/daily/hourly\" os.mkdir(path); print(\"目录已创建\") os.mkdir()创建该目录，若目录已存在会报错 再举个“栗子”：判断文件或目录是否已存在： import os exists = os.path.exists(\"foo.txt\") if exists: abspath = os.path.abspath(\"foo.txt\") print(abspath) else: print(\"文件不存在\") os.path.exists()判断目录或文件是否存在 os.path.abspath()返回绝对路径 正则表达式（知识点） 为什么使用正则表达式？ 1、典型的搜索和替换操作，要求您提供与预期的搜索结果匹配的确切文本。虽然这种技术， 对于对静态文本执行简单搜索和替换任务，可能已经足够了，但它缺乏灵活性， 若采用这种方法搜索动态文本，也不是不可能，至少也会变得很困难。 2、比如说，判断邮箱格式是否正确、手机号格式是否正确。 这种需求如果不使用正则匹配的话，那么就需要写很多逻辑进行 equals 操作。 想一想都很麻烦，麻烦的原因是 equals 操作只能确切匹配，缺乏灵活度。 3、而正则就不同了，正则可以使用限定符，匹配字符出现的次数，这样一来灵活度都高了。 4、正则表达式是一个以简单直观的方式通过寻找模式匹配文本的工具 正则表达式的重复限定符 限定符用来指定正则表达式的一个给定组件，必须要出现多少次才能满足匹配。 有 * 或 + 或 ? 或 &#123;n&#125; 或 &#123;n,&#125; 或 &#123;n,m&#125; 共 6种。 如上图 正则表达式的特殊字符类 如上图 正则表达式的分组 要实现分组很简单，使用 ()即可。 从正则表达式的左边开始看，看到的第一个左括号 (表示表示第一个分组，第二个表示第二个分组，依次类推。 a='&lt;div&gt;&lt;a href=\"https://support.google.com/chrome/?p=ui_hotword_search\" target=\"_blank\"&gt;python正则表达式之分组&lt;/a&gt;&lt;p&gt;dfsl&lt;/p&gt;&lt;/div&gt;' print(re.search(r'&lt;a.*&gt;(.*)&lt;/a&gt;',a).group(1)) 输出： python正则表达式之分组 需要注意的是，有一个隐含的全局分组（就是索引号为 0的分组），就是整个正则表达式匹配的结果。 如果正则表达式包含组，则re.findall()返回组的列表 re 库的 findall 函数 在字符串中，找到正则表达式所匹配的所有子串，并返回一个列表。如果没有找到匹配的，则返回空列表。 举个“栗子”：查找字符串中的所有数字。 ort re result1 = re.findall(r'\\d+', 'runoob 123 google 456') result2 = re.findall(r'\\d+', 'run88oob123google456', 0, 10) print(result1) print(result2) ['123', '456'] ['88', '12'] 正则表达式的懒惰匹配算法 针对 正则表达式的重复限定符 默认情况下，Python正则表达式的匹配算法采用贪婪性算法（尽可能多的重复前导字符） 如果正则表达式的重复限定符的后面加后缀?，则正则表达式引擎使用懒惰性匹配算法（尽可能少的重复前导字符） 图片链接提取（例题） 使用 urllib 访问 http://www.tencent.com/ 网页，提取其网页中所有的图片链接。 import urllib.request as req import re \"\"\" 爬取网页内容 \"\"\" def getHTML(url): response = req.urlopen(url) return response.read().decode('utf-8') # 所爬取网站为utf-8编码 \"\"\" 获取网页中全部图片的链接 - 如果网页爬取的超链接为相对路径，需要与网页根路径进行补全 - 网页爬取的超链接如果有重复项，需要去重（不一定有重复，但保险起见） \"\"\" def getImgUrls(html): root = 'http://www.tencent.com/' imgUrls = re.findall(r'img src=\"(.*?)\".*&gt;', html) temp = [] for url in imgUrls: if url not in temp: temp.append(url) for index, url in enumerate(temp): if root not in url: temp[index] = root + url return temp if __name__ == '__main__': url = 'http://www.tencent.com/' html = getHTML(url) imgUrls = getImgUrls(html) for url in imgUrls: print(url) 输出效果（运行时间为2020年5月7日，网站内容可能会变哦）： http://www.tencent.com//data/index/index_detail_1.jpg http://www.tencent.com//data/index/index_detail_2.jpg http://www.tencent.com//data/index/index_detail_3.jpg http://www.tencent.com//img/index/tencent_logo.png 文本内容分析（例题） 通过路径 /root/score.txt，以只读的方式读取 score.txt 文件； 获取 2016年一本线最高的的三个省份，并将其打印到控制台（格式为： 省份**********分数） score.txt 文件数据类似如下： 甘肃 490 632 621 625 630 597 608 吉林 530 658 639 649 634 599 615 新疆 464 673 617 630 612 534 578 广西 502 642 601 620 603 584 592 上海 360 489 475 480 / / / 广东 508 641 600 613 619 585 597 内蒙古 484 641 615 627 623 558 597 陕西 470 665 628 638 639 596 615 四川 532 665 626 643 651 612 623 黑龙江 486 667 623 641 628 580 600 安徽 518 655 620 631 647 608 621 河北 525 682 654 667 669 640 649 江西 529 645 614 629 613 589 599 浙江 600 692 670 679 676 652 661 湖南 517 662 635 644 646 593 609 宁夏 465 637 565 597 590 481 526 山东 537 679 655 665 660 597 637 河南 523 665 644 652 659 629 638 山西 519 639 617 625 638 579 599 天津 512 659 634 649 600 537 567 北京 548 662 607 629 613 570 592 重庆 525 671 644 655 654 634 642 云南 525 680 653 663 663 627 639 青海 416 596 562 580 571 502 533 江苏 353 404 376 386 384 355 366 福建 465 632 614 623 606 485 576 海南 602 829 710 750 737 672 700 贵州 473 671 627 643 658 600 616 辽宁 498 660 624 637 641 607 621 湖北 512 665 622 640 637 604 614 以第一行数据为例，对数据结构进行说明： 甘肃 490 632 621 625 630 597 608 ， 第一列为省份， 第二列为 2016年的一本线分数 490， 第三列为 2015年的一本线分数 632， 其次类推，分别是 2014、 2013、 2012、 2011、 2010 年的分数线。 代码： # 先读取所有省份和对应的2016年一本线分数，分别存入列表prov和score prov, score = [], [] with open(r'/root/score.txt', 'r') as f: for line in f.readlines(): t = line.split() prov.append(t[0]) score.append(int(t[1])) # 对prov和score中的数据进行排序 temp = list(zip(prov, score)) # 把prov和score压缩为一个列表tmp ''' 对temp排序，当列表元素是元组时， 需要以元组的第二个元素进行排序，即根据一本线分数排序， 所以写了takeSecond()函数 ''' def takeSecond(elem): return elem[1] temp.sort(reverse=True, key=takeSecond) # 降序排序 # 获取 2016年一本线最高的的三个省份，并将其打印到控制台 for i in range(3): p = str(temp[i][0]) s = str(temp[i][1]) print(p + '**********' + s) 效果： 海南**********602 浙江**********600 北京**********548 图片批量下载（例题） 以http://www.tencent.com/该网址为例，将网页上的所有图片批量下载到一个文件夹中。 三个步骤就可以完成了 如何获取 HTML 源码， 如何获取 HTML 源码上的指定标签， 如何使用 OS 模块完成目录的创建。 import urllib.request as req import re import os # 获取网页的HTML源码,返回HTML源码 def getHTML(url): response = req.urlopen(url) return response.read().decode('utf-8') # 从HTML代码中提取图片的网址,返回图片链接列表 def getImgUrls(html): root = 'http://www.tencent.com/' imgUrls = re.findall(r'img src=\"(.*?)\".*&gt;', html) temp = [] for url in imgUrls: if url not in temp: temp.append(url) for index, url in enumerate(temp): if root not in url: temp[index] = root + url return temp # 下载一幅图片，图片的链接为url，下载后的图片名字为name def downloadImg(url, name): response = req.urlopen(url) img = open(name, 'wb') # 以二进制形式写入 img.write(response.read()) img.close() # 将url对应网页上所有图片下载到dirPath文件夹 def downloadAllImg(url, dirPath): # 若文件夹不存在，则创建 exists = os.path.exists(dirPath) if not exists: os.mkdir(dirPath) # 获取网页上所有图片的网址 html = getHTML(url) imgUrls = getImgUrls(html) print(os.path) # 下载图片，注意异常处理 for url in imgUrls: imgName = os.path.split(url)[1] # 获取文件名 filePath = os.path.join(dirPath, imgName) # 存放入文件夹内的完整路径名 try: downloadImg(url, filePath) except: continue if __name__ == '__main__': url = 'http://www.tencent.com/' dirPath = 'D:\\imgs' downloadAllImg(url, dirPath) os.path.split(path) 以 path 中最后一个 / 作为分隔符，分隔后，将索引为0的视为目录（路径），将索引为1的视为文件名 os.path.join(path1, path2, ...) 以/拼接参数","permalink":"https://codermino.github.io/2020/06/25/%E7%BD%91%E9%A1%B5%E5%9B%BE%E7%89%87%E6%89%B9%E9%87%8F%E8%8E%B7%E5%8F%96%EF%BC%88Python%E6%95%99%E7%A8%8B%EF%BC%89/","photos":[]},{"tags":[{"name":"火柴","slug":"火柴","permalink":"https://codermino.github.io/tags/%E7%81%AB%E6%9F%B4/"}],"title":"火柴软件使用说明","date":"2020/06/24","text":"呼叫火柴 火柴是一款PC端的 快速启动+文件搜索+局域网传文件 软件。使用方法十分简单，双击 Ctrl 键 呼出搜索框，输入内 容即可搜索，再次双击 Ctrl 键 则可以关闭桌面搜索框。 快速启动 火柴增加了“快速启动”面板。可以将常用的软件、文件、网址固定在面板中（每排8个，共4排，最多放31个。）可 根据自己的习惯增加，例如像我这个样子。 快速启动拓展 如果面板放满了，还可以搜索软件名进行软件启动。火柴支持 程序名/文件名（如输入“QQ”，打开”QQ”），名称 缩写（如“PS”，打开“photoshop”）,乃至软件俗称（如“吃鸡”）。 文件搜索 使用Windows搜索的都知道，由于索引服务的原因，导致Windows自带搜索出奇的缓慢，经常要等数分钟，才会搜出 结果。众所周知，everything是一款强大的本地搜索软件，基于everything内核的火柴也是如此。而且，火柴搜索显示 上做出优化，不用用户编写复杂的正则表达式(因为不是每个人都是大牛)。 网络搜索 此外，火柴还支持“网络搜索”。集成了若干搜索引擎，默认可以进行百度搜索、淘宝搜索、微信搜索等。如果想要 搜索的内容，在浏览器内有收藏书签，火柴会在搜索结果中提示，并且使用收藏书签所在的浏览器打开，充分照顾用 户使用习惯。此外，网络搜索还支持高级搜索。（玩法太多，此处省略10万字） 局域网传文件 火柴另一个功能就是局域网传文件。局域网文件中，如果是网线连接，速度最高可达110MB/s，wifi连接最高速度也能达 到70MB/s。 小程序 火柴内集成了24个实用得小工具——“火柴小程序”。小程序涵盖了工作、学习、娱乐、生活等诸多方面，可满足大部 分人的需求。调用小程序也很方便，输入“xcx”,就可以查看小程序列表，并启动需要的小程序。 小程序列表 也可以直接输入小程序对应得命令，启动对应得小程序。如输入“fy”，启动“翻译小程序”；输入“time”，启动 “时间戳小程序” 部分小程序，还支持快捷键。例如【alt】+【Q】，启动“火柴截图”；【alt】+【1】启动“综合导航”（全屏面板） 皮肤 此外，火柴还支持支换肤。如果不喜欢素颜的默认皮肤，可以到皮肤中心选择下载自己喜欢的皮肤，或者 干脆自己动手制作。（ps: 我更喜欢自己动手制作）","permalink":"https://codermino.github.io/2020/06/24/%E7%81%AB%E6%9F%B4%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/","photos":[]},{"tags":[{"name":"this.$nextTick","slug":"this-nextTick","permalink":"https://codermino.github.io/tags/this-nextTick/"}],"title":"this.$nextTick","date":"2020/03/31","text":"原理 1.vue依靠数据驱动来完成视图和dom的渲染 2.vue的响应式不是数据发生变化之后立即变化，更新的过程是异步的 3.如果想要在created钩子函数中进行dom操作，created钩子函数中是在页面创建的时候进行调用， 可能还未对页面中的dom元素进行渲染完成。所以无法直接进行操作，需要通过this.$nextTick()来完成。 验证 创建对应的html页面 span标签中显示的内容是data中的value的值 点击button按钮之后会触发changeValue事件，修改data中的value的值 主要是验证span标签中value的值的变化过程 &lt;button @click=\"changeValue\"&gt;点击改变value&lt;/button&gt; &lt;span ref=\"container\"&gt;&#123;&#123;this.value&#125;&#125;&lt;/span&gt; 创建对应的数据和钩子函数 created()&#123; console.log('开始执行created函数'); console.log(this.value); console.log(this.$refs.container); this.$nextTick(()=&gt;&#123; console.log('created中的$nextTick函数'); &#125;) &#125;, mounted() &#123; console.log('开始执行mounted函数'); console.log(this.$refs.container.innerHTML); this.$nextTick(()=&gt;&#123; console.log('mounted中的$nextTick函数'); &#125;) &#125;, data()&#123; return&#123; value:'改变之前的内容(old)' &#125; &#125;, methods:&#123; changeValue()&#123; this.value = '改变之后的内容(new)'; console.log(this.$refs.container.innerText); this.$nextTick(()=&gt;&#123; console.log(this.$refs.container.innerText); &#125;) &#125; &#125; 输出 页面中的输出结果 test.vue?b018:13 开始执行created函数 test.vue?b018:14 改变之前的内容(old) test.vue?b018:15 undefined test.vue?b018:21 开始执行mounted函数 test.vue?b018:22 改变之前的内容(old) test.vue?b018:17 created中的$nextTick函数 test.vue?b018:24 mounted中的$nextTick函数 test.vue?b018:35 改变之前的内容(old) test.vue?b018:37 改变之后的内容(new) 输出结果分析 结果分析 页面打开后调用created钩子函数 输出相应的打印结果，可以看到在第15行结果为undefined(输出的是span标签) 可以看出在created钩子函数调用的时候，页面的dom元素还没有渲染完成 在第17行可以看到，在页面的dom元素渲染完成之后，会按照生命周期顺序执行created和mouted钩子函数中的this.$nextTick()函数 并且输出对应的内容 在点击了按钮之后，改变了data中的value的值，页面中也进行了dom的刷新，但是... 通过35行的打印可以知道，此时span标签中的内容还是修改之前的内容 通过37行的打印可以知道，在dom元素彻底渲染完成之后，span标签中的内容也完成了更新。(此时打印的内容是更新完的value的内容) 总结 this.$nextTick() veu的响应式的更新的过程是异步的。 是保证在dom元素渲染完成之后再进行某个操作。 所以如果希望某个函数或者数据的赋值等操作是在dom元素渲染完成之后再进行，那么可以用this.$nextTick()","permalink":"https://codermino.github.io/2020/03/31/this-nextTick/","photos":[]},{"tags":[{"name":"stream处理大文件","slug":"stream处理大文件","permalink":"https://codermino.github.io/tags/stream%E5%A4%84%E7%90%86%E5%A4%A7%E6%96%87%E4%BB%B6/"}],"title":"nodejs的stream","date":"2020/02/25","text":"读取 const fs = require('fs'); const fileReadStream = fs.createReadStream(\"input.json\"); fileReadStream.once('data',(chunk)=&gt;&#123; console.log(chunk.toString()); &#125;); fileReadStream.on(\"end\",()=&gt;&#123; console.log('end'); &#125;); fileReadStream.on('error',(err)=&gt;&#123; console.log(err); &#125;); 读取并写入 const fs = require('fs'); const fileReadStream = fs.createReadStream(\"input.json\"); const fileWriteStream = fs.createWriteStream('output.json'); let count = 0; fileReadStream.on('data',(chunk)=&gt;&#123; console.log(`$&#123;++count&#125; 接收到: $&#123;chunk.length&#125;`); fileWriteStream.write(chunk); &#125;); fileReadStream.on(\"end\",()=&gt;&#123; console.log('end'); &#125;); fileReadStream.on('error',(err)=&gt;&#123; console.log(err); &#125;); 管道流写入 const fs = require('fs'); const fileReadStream = fs.createReadStream(\"input.json\"); const fileWriteStream = fs.createWriteStream('output.json'); //通过管道流的方式进行写入 fileReadStream.pipe(fileWriteStream); 管道流产生一个gz压缩文件 const fs = require('fs'); const zlib = require('zlib'); const fileReadStream = fs.createReadStream(\"input.json\"); const fileWriteStream = fs.createWriteStream('output.gz'); fileWriteStream.on('pipe',(source)=&gt;&#123; console.log(source); &#125;); fileReadStream .pipe(zlib.createGzip()) .pipe(fileWriteStream);","permalink":"https://codermino.github.io/2020/02/25/nodejs%E7%9A%84stream/","photos":[]},{"tags":[{"name":"gm","slug":"gm","permalink":"https://codermino.github.io/tags/gm/"}],"title":"通过控制台使用gm裁剪图片","date":"2020/02/15","text":"转换图片格式 gm convert input output 改变图片大小 gm convert -quality 80 -resize 100×100 input.jpg output.jpg 添加水印文字 -font 字体 -fill 填充颜色 -pointsize 字体大小 -draw 内容 gm convert -font Arial -fill blue -pointsize 18 -draw \"text 100,100 'www.abc.com'\" input output","permalink":"https://codermino.github.io/2020/02/15/%E9%80%9A%E8%BF%87%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%BD%BF%E7%94%A8gm%E8%A3%81%E5%89%AA%E5%9B%BE%E7%89%87/","photos":[]},{"tags":[{"name":"gm裁切图片(1)","slug":"gm裁切图片-1","permalink":"https://codermino.github.io/tags/gm%E8%A3%81%E5%88%87%E5%9B%BE%E7%89%87-1/"}],"title":"gm裁切图片(1)","date":"2020/02/05","text":"引入相关包 const fs = require('fs'),gm = require('gm'); 缩放 gm('input.jpg') .resize(50, 50,\"!\") .write('output.jpg', function (err) &#123; if (err) &#123; console.log(err); &#125; &#125;); 裁剪指定位置 gm('./demo.jpg') .crop(364, 480, 82, 3) .write('./cut.jpg', function (err) &#123; if (!err) console.log('crazytown has arrived'); &#125;);","permalink":"https://codermino.github.io/2020/02/05/gm%E8%A3%81%E5%88%87%E5%9B%BE%E7%89%87-1/","photos":[]},{"tags":[{"name":"md5加密注册表单","slug":"md5加密注册表单","permalink":"https://codermino.github.io/tags/md5%E5%8A%A0%E5%AF%86%E6%B3%A8%E5%86%8C%E8%A1%A8%E5%8D%95/"}],"title":"md5加密注册表单","date":"2020/02/05","text":"文件夹的创建 创建public文件夹用来存放jquery文件 创建views文件夹用来存放前端页面 创建models文件夹用来存放md5.js文件 register前端页面 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;注册&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;form action=\"\" method=\"post\"&gt; &lt;label for=\"username\"&gt;&lt;/label&gt; &lt;p&gt;用户名：&lt;input name=\"userName\" type=\"text\" id=\"username\"/&gt;&lt;/p&gt; &lt;label for=\"password\"&gt;&lt;/label&gt; &lt;p&gt;密 码：&lt;input name=\"password\" type=\"password\" id=\"password\"/&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"button\" value=\"注册\" id=\"zhuce\"&gt;&lt;/p&gt; &lt;/form&gt; &lt;/div&gt; &lt;script type=\"text/javascript\" src=\"/jquery-1.11.3.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; //用ajax提交表单 $(\"#zhuce\").click(function()&#123; $.post(\"/doregist\",&#123; \"username\" : $(\"#username\").val(), \"password\" : $(\"#password\").val() &#125;,function(result)&#123; if(result === \"1\")&#123; alert(\"注册成功\"); window.location.href=\"/login\"; &#125;else&#123; alert(\"注册失败\"); &#125; &#125;) &#125;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; login前端页面 &lt;!doctype html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;登录&lt;/h1&gt; &lt;div&gt; &lt;form action=\"\" method=\"post\"&gt; &lt;label for=\"dengluming\"&gt;&lt;/label&gt; &lt;p&gt; 登录名： &lt;input type=\"text\" id=\"dengluming\"/&gt; &lt;/p&gt; &lt;label for=\"mima\"&gt;&lt;/label&gt; &lt;p&gt; 密码： &lt;input type=\"password\" id=\"mima\"/&gt; &lt;/p&gt; &lt;p&gt; &lt;input id=\"denglu\" type=\"button\" value=\"登陆\"/&gt; &lt;/p&gt; &lt;/form&gt; &lt;/div&gt; &lt;script type=\"text/javascript\" src=\"/jquery-1.11.3.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; //用ajax提交表单 $(\"#denglu\").click(function()&#123; $.post(\"/dologin\",&#123; \"dengluming\" : $(\"#dengluming\").val(), \"mima\" : $(\"#mima\").val() &#125;,function(result)&#123; if(result === \"1\")&#123; alert(\"登陆成功\"); window.location.href=\"/index\"; &#125;else if(result === \"-2\")&#123; alert(\"没有这个注册用户\"); &#125;else if(result === \"-1\")&#123; alert(\"密码不正确\"); &#125; &#125;) &#125;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; md5.js const crypto = require(\"crypto\"); module.exports = function(password)&#123; let md5 = crypto.createHash('md5'); return md5.update(password).digest('base64'); &#125;; 引入相关的包 const express = require('express'); const path = require('path'); const ejs = require('ejs'); const MongoClient = require('mongodb').MongoClient; const md5 = require(\"./model/md5.js\"); const formidable = require('formidable'); const session = require('express-session'); express中间件 使用express中间件,并且在3000端口监听 const app = express(); app.listen(3000,function () &#123; console.log('server is running...'); &#125;); 使用html模板引擎 将ejs模板引擎转为html模板引擎 app.set('views', path.join(__dirname, 'views')); app.engine('html', ejs.__express); app.set('view engine', 'html'); 使用express-session中间件 使用express-session中间件,并且如果用户主动刷新页面那么session自动重新计时，并且session的有效时间为60s app.use(session(&#123; secret: 'keyboard cat', name : 'login', resave: true,//是否允许session重新设置 saveUninitialized: false, cookie: &#123;maxAge: 60 * 1000&#125;, rolling: true //add 刷新页面 session 过期时间重置 &#125;)); 开放静态资源服务 将Public文件夹开放出来 app.use(express.static('./public')); 渲染前端页面 设置重定向,一开始的时候自动重定向到register路由,并且渲染register.html文件 app.get('/',function (req,res) &#123; res.redirect('/register'); &#125;); app.get('/register',function (req,res) &#123; res.render('register'); &#125;); app.get('/login',function (req,res) &#123; res.render('login'); &#125;); 注册接口 app.post('/dologin',function (req,res) &#123; let form = new formidable.IncomingForm(); form.parse(req, function(err, fields, files)&#123; const array = []; const username = fields.dengluming; let password = fields.mima; password = (你的md5加密方式) 例如:md5(password); const url = \"mongodb://localhost:27017/\"; //连接数据库 MongoClient.connect(url, &#123;useUnifiedTopology:true&#125;, (err, client)=&gt; &#123; //回调函数表示链接成功做的事情，db参数就是连接上的数据库实体 if(err) &#123; console.log(\"数据库连接失败\"); return ; &#125; //插入数据，集合如果不存在，也没有关系，程序会帮你创建 const db = client.db('learnnode'); const result = db.collection('Student').find(&#123;username:username&#125;); result.each(function (err, doc) &#123; if(err) &#123; return; &#125; if(doc != null) &#123; array.push(doc); //放入结果数组 &#125;else &#123; let checkNum = 0; const resultNum = array.length; if(resultNum === 0)&#123; res.send('-2'); &#125;else &#123; //遍历结束，没有更多的文档 array.forEach(function (data) &#123; if(data.password === password)&#123; req.session.login = true; req.session.username = username; req.session.password = password; res.send('1'); &#125;else &#123; checkNum++; &#125; &#125;); if(checkNum === resultNum)&#123; res.send('-1'); &#125; &#125; &#125; &#125;); &#125;); &#125;); &#125;); 注册接口 app.post('/doregist',function (req,res) &#123; let form = new formidable.IncomingForm(); form.parse(req, function(err, fields, files)&#123; const username = fields.username; let password = fields.password; const url = \"mongodb://localhost:27017/\"; MongoClient.connect(url, &#123;useUnifiedTopology:true&#125;, (err, client)=&gt; &#123; //回调函数表示链接成功做的事情，db参数就是连接上的数据库实体 if(err) &#123; console.log(\"数据库连接失败\"); return ; &#125; //插入数据，集合如果不存在，也没有关系，程序会帮你创建 const db = client.db('learnnode'); password = md5(md5(password).substr(4,7) + md5(password)); const myObj = &#123;username: username, password: password&#125;; db.collection('Student').insertOne(myObj,function (err,result) &#123; if(err)&#123; console.log(err); res.send('-1'); &#125;else &#123; console.log('插入数据成功'); res.send('1'); &#125; client.close(); &#125;); &#125;); &#125;); &#125;);","permalink":"https://codermino.github.io/2020/02/05/md5%E5%8A%A0%E5%AF%86%E6%B3%A8%E5%86%8C%E8%A1%A8%E5%8D%95/","photos":[]},{"tags":[{"name":"session的使用","slug":"session的使用","permalink":"https://codermino.github.io/tags/session%E7%9A%84%E4%BD%BF%E7%94%A8/"}],"title":"session的使用","date":"2020/02/01","text":"基本使用 const express = require('express'); //引入express-session中间件 const session = require('express-session'); const app = express(); app.set('trust proxy', 1) ;// trust first proxy //使用session并且配置相关参数 app.use(session(&#123; secret: 'keyboard cat', resave: false, saveUninitialized: true // cookie: &#123; secure: true &#125; &#125;)); app.get('/',function (req,res) &#123; if(req.session.login)&#123; res.send('欢迎您：'+req.session.username); &#125;else &#123; res.send('没有登录'); &#125; &#125;); app.get('/login',function (req,res) &#123; req.session.login = true; req.session.username = '张三'; res.send('登录成功'); &#125;); app.listen(3000,function () &#123; console.log('server is running...'); &#125;);","permalink":"https://codermino.github.io/2020/02/01/session%E7%9A%84%E4%BD%BF%E7%94%A8/","photos":[]},{"tags":[{"name":"cookie的使用","slug":"cookie的使用","permalink":"https://codermino.github.io/tags/cookie%E7%9A%84%E4%BD%BF%E7%94%A8/"}],"title":"cookie的使用","date":"2020/02/01","text":"基本使用 const express = require('express'); //使用cookie-parser中间件 const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.get('/',function (req,res) &#123; res.send(req.cookies.xihao); &#125;); // http://localhost:3000/gonglue?dest=北京 app.get('/gonglue',function (req,res) &#123; const destination = req.query.dest; //先取出cookie,然后再设置cookie const likes = req.cookies.xihao || []; likes.push(destination); //maxAge设置最大存活时间，在nodejs中是以毫秒为单位(900000ms),但是在浏览器的cookie中会是以秒为单位(900s) res.cookie('xihao',likes,&#123; maxAge: 900000, httpOnly: true &#125;); res.send(destination+'旅游攻略'); &#125;); app.listen(3000,function () &#123; console.log('server is running...'); &#125;);","permalink":"https://codermino.github.io/2020/02/01/cookie%E7%9A%84%E4%BD%BF%E7%94%A8/","photos":[]},{"tags":[{"name":"app.use中间件","slug":"app-use中间件","permalink":"https://codermino.github.io/tags/app-use%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"title":"app.use中间件","date":"2020/01/30","text":"使用 const express = require('express'); const app = express(); //在使用app.use中间件的时候如果不指定路由，那么默认是/ //会匹配到/、/abc、/abc/123等路由 如果在浏览器中输入的路由是http://localhost:3000/user/456/abc app.use(function(req, res, next)&#123; //GET /user/456/abc console.log('%s %s', req.method, req.url); next(); &#125;); 那么和get、post不同的是use会向下接着匹配 app.use('/user',function(req, res, next)&#123; const basePath = req.baseUrl; const path = req.path; /user console.log(basePath); /456/abc console.log(path); res.send('Hello World'); &#125;); app.listen(3000); 开放静态资源文件夹 //开放同级目录下的public文件夹，并且在路由的时候使用/static代替 app.use('/static',express.static(__dirname + '/public')); 原生开放静态资源原理 const express = require('express'); const fs = require('fs'); const app = express(); app.use(openStatic); app.listen(3000,function () &#123; console.log('server is running...'); &#125;); function openStatic(req,res,next) &#123; const filePath = req.path; fs.readFile(__dirname+filePath,function (err,data) &#123; if(err)&#123; next() &#125;else &#123; res.send(data.toString()); &#125; &#125;) &#125; 优先级 会按照从上到下的优先级顺序执行 app.use(express.static(__dirname + '/public')); app.use(express.static(__dirname + '/files')); app.use(express.static(__dirname + '/uploads'));","permalink":"https://codermino.github.io/2020/01/30/app-use%E4%B8%AD%E9%97%B4%E4%BB%B6/","photos":[]},{"tags":[{"name":"将ejs模板引擎修改为html模板引擎","slug":"将ejs模板引擎修改为html模板引擎","permalink":"https://codermino.github.io/tags/%E5%B0%86ejs%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E4%BF%AE%E6%94%B9%E4%B8%BAhtml%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"}],"title":"将ejs模板引擎修改为html模板引擎","date":"2020/01/29","text":"引入 const ejs = require('ejs'); const path = require('path'); 使用html模板引擎 app.set('views', path.join(__dirname, 'views')); app.engine('html', ejs.__express); app.set('view engine', 'html'); 渲染html页面 app.get('/',function (req,res) &#123; res.redirect('/user'); &#125;); app.get('/user',function (req,res) &#123; res.render('form'); &#125;); 渲染原理 在渲染的时候app.set('views', path.join(__dirname, 'views')); 渲染的页面会在views文件夹下寻找指定名的文件(上述例子寻找views/form.html) 将渲染ejs文件修改为渲染html文件 app.engine('html', ejs.__express); //如果不想使用views这个文件夹，可以使用下面的语句进行修改 app.set('views','文件夹的名字'); app.set('view engine', 'html');","permalink":"https://codermino.github.io/2020/01/29/%E4%BD%BF%E7%94%A8html%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/","photos":[]},{"tags":[{"name":"body-parser","slug":"body-parser","permalink":"https://codermino.github.io/tags/body-parser/"}],"title":"body-parser的使用","date":"2020/01/29","text":"安装 npm install body-parser 使用 var bodyParser = require('body-parser'); app.use(bodyParser.urlencoded(&#123; extended: false &#125;)); // parse application/json app.use(bodyParser.json()); 表单 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Demo&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form method=\"post\" action=\"#\"&gt; &lt;label for=\"username\"&gt;&lt;/label&gt; &lt;input id=\"username\" type=\"text\" placeholder=\"请输入姓名\" name=\"username\"/&gt; &lt;input type=\"submit\" value=\"提交\"/&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 获取表单数据 app.post('/user',function (req,res) &#123; res.setHeader('Content-Type', 'text/plain'); res.write('you posted:\\n'); res.end(JSON.stringify(req.body, null, 2)); &#125;);","permalink":"https://codermino.github.io/2020/01/29/body-parser%E7%9A%84%E4%BD%BF%E7%94%A8/","photos":[]},{"tags":[{"name":"express","slug":"express","permalink":"https://codermino.github.io/tags/express/"}],"title":"express模板的使用","date":"2020/01/28","text":"安装 npm install express --save Demo const express = require('express') const app = express() app.get('/', function (req, res) &#123; res.send('Hello World') &#125;) app.listen(3000,function()&#123; console,log('正在运行......'); &#125; ) 其他参数 app.get('/abc',function()&#123; res.send('这是二级路由') &#125;) 正则 //匹配路由为/student/后面加上10位数字的路由 app.get(/^\\/student\\/([\\d]&#123;10&#125;)$/,function (req,res) &#123; res.send('学号'+req.params[0]); &#125;); //也可以获取到参数之后，然后再用正则进行验证 app.get('/book/:id',function (req,res) &#123; let id = req.params['id']; let reg = /^[\\d]&#123;6&#125;$/; if (reg.test(id))&#123; res.send(id) &#125;else &#123; res.send('error'); &#125; &#125;); express的参数显示 app.get('/teacher/:id',function (req,res) &#123; res.send('工号'+req.params.id); &#125;); express的参数显示的格式限制 //限制编号后面是3-8为数字的路由 app.get('/master/:iid([\\\\d]&#123;3,8&#125;)',function (req,res) &#123; res.send('编号'+req.params.iid); &#125;); tips res.send()还可以send一个json对象 res.send(&#123; 'data':'这是二级路由' &#125;)","permalink":"https://codermino.github.io/2020/01/28/express%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%BD%BF%E7%94%A8/","photos":[]},{"tags":[{"name":"ejs模板的基本使用","slug":"ejs模板的基本使用","permalink":"https://codermino.github.io/tags/ejs%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"}],"title":"ejs模板的使用","date":"2020/01/28","text":"安装 npm install ejs 基本使用1 //引入ejs const ejs = require('ejs'); //定义字符串 let str = '今天是星期&lt;%= a%&gt;'; //定义data data = &#123; a:'天' &#125;; //ejs渲染str和data let html = ejs.render(str, data); //控制台输出 console.log(html); 基本使用2 1.首先创建一个ejs文件:index.ejs &lt;!doctype html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;今天是星期&lt;%=a%&gt;&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 2.使用ejs模板传数据和进行渲染 //引入fs和ejs const fs = require('fs'); const ejs = require('ejs'); //读取文件(读取当前路径下的index.ejs文件) fs.readFile('./index.ejs',function (err, data) &#123; if(err)&#123; console.log(err); &#125;else&#123; //需要将模板转为字符串,因为在传输过程中是byte流 const template = data.toString(); const dictionary = &#123; a:'天' &#125;; //使用ejs进行渲染，传入的数据有data,和ejs界面需要使用的数据 const html = ejs.render(template, dictionary); //控制台输出渲染之后的结果 console.log(html); &#125; &#125;); 基本使用3 //引入fs、ejs和http const fs = require('fs'); const ejs = require('ejs'); const http = require('http'); //使用http开启一个服务器 let server = http.createServer(function (req, res) &#123; fs.readFile('./index.ejs',function (err, data) &#123; if(err)&#123; console.log(err); &#125;else&#123; const template = data.toString(); const dictionary = &#123; a:'天' &#125;; const html = ejs.render(template, dictionary); //显示 res.writeHead(200,&#123;\"Content-Type\":\"text/html;charset=UTF8\"&#125;); res.end(html) &#125; &#125;); &#125;); //在3000端口监听 server.listen(3000, function () &#123; console.log('服务器启动成功'); &#125;); 基本使用4 //也可以在传递数据的时候传入一个数组 const dictionary = &#123; a:'天', news:['星期一','星期二','星期三'] &#125;; //在前端页面中可以使用for循环遍历 &lt;ul&gt; &lt;% for(let i=0; i&lt;news.length; i++)&#123; %&gt; &lt;li&gt;&lt;%=news[i]%&gt;&lt;/li&gt; &lt;%&#125;%&gt; &lt;/ul&gt; 基本使用5 //也可以传入一个数组对象 people:[ &#123;name:'张三',age:29&#125;, &#123;name:'李四',age:31&#125;, &#123;name:'王五',age:38&#125;, &#123;name:'孙六',age:30&#125; ] &lt;ul&gt; &lt;% for(let i = 0;i&lt;people.length;i++)&#123; if(people[i].age&gt;30)&#123; %&gt; &lt;li&gt;&lt;%= people[i].name%&gt;&lt;/li&gt; &lt;%&#125;%&gt; &lt;%&#125;%&gt; &lt;/ul&gt;","permalink":"https://codermino.github.io/2020/01/28/ejs%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%BD%BF%E7%94%A8/","photos":[]},{"tags":[{"name":"formidable文件改名","slug":"formidable文件改名","permalink":"https://codermino.github.io/tags/formidable%E6%96%87%E4%BB%B6%E6%94%B9%E5%90%8D/"}],"title":"formidable上传文件改名","date":"2020/01/25","text":"引用模块 主要使用的是nodejs的fs模块和path模块 var fs = require('fs'); var sd = require('silly-datetime'); var path = require('path') 具体使用 time = sd.format(new Date(),'YYYYMMDDHHMMSS'); 产生一个过位数的随机数 random = parseInt(Math.random()* 89999 + 10000); extname = path.extname(files.前端表单上传的图片的file的名字).name; oldpath = __dirname + '/' + files.名字.path; 这里使用的新的名字由三部分组成：时间戳、随机数、拓展名 newpath = __dirname + '/uploads/' + time + random + extname; 执行 fs.rename(oldpath, newpath, function(err)&#123; if(err)&#123; throw Error('改名失败'); &#125; res.writeHead(200, &#123;'content-type' : 'text/plain'&#125;); res.end('成功'); &#125;);","permalink":"https://codermino.github.io/2020/01/25/formidable%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E6%94%B9%E5%90%8D/","photos":[]},{"tags":[{"name":"formidable文件上传","slug":"formidable文件上传","permalink":"https://codermino.github.io/tags/formidable%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}],"title":"nodejs的formidable","date":"2020/01/25","text":"安装 npm i -S formidable 引用 var formidable = require('formidable'), http = require('http'), util = require('util'); 创建相关路由 http.createServer(function(req, res) &#123; if (req.url == '/upload' &amp;&amp; req.method.toLowerCase() == 'post') &#123; // parse a file upload var form = new formidable.IncomingForm(); form.parse(req, function(err, fields, files) &#123; //在fields中存储的是上传的输入框或者单选框等信息 //在files中存储的是上传的图片或者视频等信息 res.writeHead(200, &#123;'content-type': 'text/plain'&#125;); res.write('received upload:\\n\\n'); res.end(util.inspect(&#123;fields: fields, files: files&#125;)); &#125;); return; &#125; tip: 在前端中的上传的表单中一定要加上:enctype=\"multipart/form-data\" eq: &lt;form action=\"/upload\" enctype=\"multipart/form-data\" method=\"post\"&gt; 相关API参数 -Creates a new incoming form. var form = new formidable.IncomingForm() -Sets encoding for incoming form fields. form.encoding = 'utf-8'; -Sets the directory for placing file uploads in. You can move them later on using fs.rename(). The default is os.tmpdir(). form.uploadDir = \"/my/dir\"; -If you want the files written to form.uploadDir to include the extensions of the original files, set this property to true. form.keepExtensions = false; -Either 'multipart' or 'urlencoded' depending on the incoming request. form.type -Limits the amount of memory all fields together (except files) can allocate in bytes. If this value is exceeded, an 'error' event is emitted. The default size is 20MB. form.maxFieldsSize = 20 * 1024 * 1024; -Limits the size of uploaded file. If this value is exceeded, an 'error' event is emitted. The default size is 200MB. form.maxFileSize = 200 * 1024 * 1024; -Limits the number of fields that the querystring parser will decode. Defaults to 1000 (0 for unlimited). form.maxFields = 1000; -If you want checksums calculated for incoming files, set this to either 'sha1' or 'md5'. form.hash = false; -If this option is enabled, when you call form.parse, the files argument will contain arrays of files for inputs which submit multiple files using the HTML5 multiple attribute. form.multiples = false; Event 'progress' Emitted after each incoming chunk of data that has been parsed. Can be used to roll your own progress bar. form.on('progress', function(bytesReceived, bytesExpected) &#123; &#125;); 'field' Emitted whenever a field / value pair has been received. form.on('field', function(name, value) &#123; &#125;); 'fileBegin' Emitted whenever a new file is detected in the upload stream. Use this event if you want to stream the file to somewhere else while buffering the upload on the file system. form.on('fileBegin', function(name, file) &#123; &#125;); 'file' Emitted whenever a field / file pair has been received. file is an instance of File. form.on('file', function(name, file) &#123; &#125;); 'error' Emitted when there is an error processing the incoming form. A request that experiences an error is automatically paused, you will have to manually call request.resume() if you want the request to continue firing 'data' events. form.on('error', function(err) &#123; &#125;); 'aborted' Emitted when the request was aborted by the user. Right now this can be due to a 'timeout' or 'close' event on the socket. After this event is emitted, an error event will follow. In the future there will be a separate 'timeout' event (needs a change in the node core). form.on('aborted', function() &#123; &#125;); 'end' form.on('end', function() &#123; &#125;); Emitted when the entire request has been received, and all contained files have finished flushing to disk. This is a great place for you to send your response.","permalink":"https://codermino.github.io/2020/01/25/nodejs%E7%9A%84formidable/","photos":[]},{"tags":[{"name":"mongodb","slug":"mongodb","permalink":"https://codermino.github.io/tags/mongodb/"}],"title":"mongodb操作","date":"2020/01/12","text":"查询 find(): db.集合名称.find(&#123;条件文档&#125;) findOne(): db.集合名称.findOne(&#123;条件文档&#125;) pretty():将结果格式化 db.集合名称.find(&#123;条件文档&#125;).pretty() 查询条件 等于:默认是等于判断，没有运算符 小于: $lt (less than) 小于等于:$lte (less than equal) 大于: $gt (greater than) 大于等于:$gte (greater than equal) 不等于: $ne (not equal) eq: db.集合名称.find(&#123;条件文档:&#123;查询条件&#125;&#125;) 使用\"$in\",\"$nin\"判断是否在某个范围内 eq: 查询年龄为18、28的学生 db.stu.find(&#123;age:&#123;$in:[18,28]&#125;&#125;) and: 在json中写多个条件即可 查询年龄大于或等于18，并且性别为true的学术 db.stu.find(age:&#123;$gte:18&#125;,gender:true) or: 使用$or,值为数组，数组中每个元素为json 查询年龄大于18，或性别为false的学生 db.stu.find(&#123;$or:[&#123;age:&#123;$gt:18&#125;&#125;,&#123;gender:false&#125;]&#125;) 查询年龄大于18或者性别为男生，并且姓名是Mark db.stu.find(&#123;$or:[&#123;age:&#123;$gt:18&#125;&#125;,&#123;gender:false&#125;],name:'Mark'&#125;) 正则 使用//或$regex编写正则表达式 查询姓李的学生 db.stu.find(&#123;last_name:/^李/&#125;) db.stu.find(&#123;last_name:&#123;$regex:'^李'&#125;&#125;) limit和skip limit():用于等去指定数量的文档 db.集合名称.find().limit(NUMBER) 查询2条学生信息 db.stu.find().limit(2) skip():用于跳过指定数量的文档 db.集合名称.find().skip(NUMBER) db.stu.find().skip(2) 同时使用 db.stu.find().limit(3).skip(2) 或 db.stu.find().skip(3).limit(2) ★ 自定义查询 在mongodb中支持js语法 使用$where后面写一个函数，返回满足条件的数据 查询年龄大于20的学生 db.stu.find(&#123; $where:function()&#123; return this.age&gt;20; &#125; &#125;) 投影 在查询到的返回结果中，只选择必要的字段 db.集合名称.find(&#123;&#125;,&#123;字段名称:1,.....&#125;) 参数为字段与值，值为1表示显示，值为0不显示 特殊：对于_id列默认是显示的，如果不显示需要明确设置为0 eq: db.stu.find(&#123;&#125;,&#123;_id:0,name:1,age:1,gender:1&#125;) 排序 方法sort(),用于对集合进行排序 db.集合名称.find().sort(&#123;字段1,...&#125;) 参数1位升序排列 参数-1为降序排列 根据性别降序，再根据年龄升序 eq: db.stu.find().sort(&#123;gender:-1,age:1&#125;) 统计个数 方法count()用于统计结果集中文档条数 db.集合名称.find(&#123;条件&#125;).count() db.集合名称.count(&#123;条件&#125;) db.stu.find(&#123;gender:true&#125;).count() db.stu.count(&#123;age:&#123;$gt:20&#125;&#125;,gender:true) 消除重复 方法distinct()对数据进行去重 db.集合名称.distinct('去重字段',&#123;条件&#125;) db.stu.distinct('address',&#123;age:&#123;$gt:20&#125;&#125;) 数据备份和恢复 备份的语法： mongoddump -h host -d dbname -o dbdirectory -h：服务器地址，也可以指定端口号 -d：需要备份的数据库名称 -o：备份的数据存放的位置，此目录中存放着备份出来的数据 eq: mongodump -h 地址 -d test -o 路径 如何备份的是本地的服务器，那么-h可以省略不写 恢复语法： mongorestore -g dbhost -d dbname --dir dbdirectory -h：服务器地址 -d：需要恢复的数据库实例 --dir：备份数据所在的位置 eq: mongoretore -h 地址 -d test2 --dir 地址/test 聚合 聚合(aggregate)是基于数据处理的聚合管道，每个文档通过一个由多个阶段(stage) 组成的管道，可以对每个极端的管道进行分组、过滤等功能，然后经过一系列的处理， 输出相应的结果。 db.集合名称.aggregate(&#123;管道:&#123;表达式&#125;&#125;) 常用管道 在mongodb中，文档处理完毕后，通过管道进行下一次处理 常用管道如下： $group：将集合中的文档分组，可用于统计结果 $match：过滤数据，只输出符合条件的文档 $project：修改输入文档的结构，如重命名、增加、删除字段、创建计算结果 $sort：将输入文档排序后输出 $limit：限制聚合管道返回的文档树 $skip：跳过指定数量的文档，并返回余下的文档 $unwind：将数组类型的字段进行拆分 常用管道表达式 $sum：计算总和，$sum:1表示以一倍计数 $avg：计算平均值 $min：获取最小值 $max：获取最大值 $psuh：在结果文档中插入值到一个数组中 $first：根据资源文档的排序获取第一个文档数据 $last：根据资源文档的排序获取最后一个文档数据 分组 将集合中的文档分组，可用于统计结果 _id表示分组的依据，使用某个字段的格式为'$字段' eq:统计男生、女生的总人数 db.stu.aggregate(&#123; $group: &#123; _id:'$gender', counter:&#123;$sum:1&#125; &#125; &#125;) Group by null 将集合中所有文档分为一组 eq:求学生总人数、平均年靓 db.stu.aggregate(&#123; $group: &#123; _id:null, counter:&#123;$sum:1&#125;, avgAge:&#123;$avg:'$age'&#125; &#125; &#125;) 处理$project 修改输入文档的结构，如重命名、增加、删除字段、创建计算结果 eq1:查询学生的姓名、年龄 db.stu.aggregate( &#123;$project:&#123;_id:0,name:1,age:1&#125;&#125; ) eq2:查询男生、女生人数，输出个数 db.stu.aggregate( &#123;$group:&#123;_id:'$gender',counter:&#123;$sum:1&#125;&#125;&#125;, &#123;$project:&#123;_id:0,counter:1&#125;&#125; ) 综合实例 选择年龄大于20的学生，观察男性和女性有多少人 db.stu.aggregate( &#123;$match:&#123;age:&#123;$gt:20&#125;&#125;&#125;, &#123;$group:&#123;_id:\"$gender\",count:&#123;$sum:1&#125;&#125;&#125;, &#123;$project:&#123;_id:0,gender:\"$_id\",count:1&#125;&#125; ) 排序 $sort -将输入文档排序后输出 eq1: -查询学生信息，按照年龄升序排序 b.stu.aggregate(&#123;$sort:&#123;age:1&#125;&#125;) eq2: -查询男生、女生人数。按人数降序排序 db.stu.aggregate( &#123;$group:&#123;_id:'$gender',counter:&#123;$sum:1&#125;&#125;&#125;, &#123;$sort:&#123;counter:-1&#125;&#125; ) limit和skip $limit -限制聚合管道返回的文数 -eq -查询2条学生信息 db.stu.aggregate(&#123;$limit:2&#125;) $skip -跳过指定数量的文档，并返回余下的文档 -eq -查询从第3条开始的学生信息 db.stu.aggregate(&#123;$skip:2&#125;) -eq 统计男生、女生人数，按人数升序,取第二条数据 db.stu.aggregate( &#123;$group:&#123;_id:'$gender',counter:&#123;$sum:1&#125;&#125;&#125; &#123;$sort:&#123;counter:1&#125;&#125;, &#123;$skip:1&#125;, &#123;$limit:1&#125; ) tip: -注意顺序：先写skip，再写limit（这样做效率更高） -如果想要_id不显示出来，那么在$group中加上_id:null unwind $unwind -属性值为false表示丢弃属性值为空的文档 -属性preserveNullAndEmptyArrays值为true表示保留属性值为空的文档 用法： db.invertory.aggregate(&#123; $unwind:&#123; path:'$字段名称', preserveNullAndEmptyArrays:&lt;boolean&gt;#防止数据丢失 &#125; &#125;) 索引 索引：以提升查询速度 测试：插入10万条数据到数据库中 for(i=0;i&lt;100000;i++)&#123; db.t255.insert(&#123;name:'test'+i,age:i&#125;) &#125; db.t1.find(&#123;name:'test10000'&#125;) db.t1.find(&#123;name:'test10000'&#125;).explain('executionStats') 建立索引之后的对比： 语法：db.集合.ensureIndex(&#123;属性：1&#125;)，1表示升序，-1表示降序 具体操作：db.t255.ensureIndex(&#123;name:1&#125;) db.t1.find(&#123;name:'test10000'&#125;).explain('executionStats') 在默认情况下索引字段的值可以相同 创建唯一索引（索引的值是唯一的）： -db.t1.ensureIndex(&#123;'name':1&#125;,&#123;'unique':true&#125;) 建立联合索引（什么时候需要联合索引）： -db.t1.ensureIndex(&#123;name:1,age:1&#125;) 查看当前集合的所有索引: -db.t1.getIndexes() 删除索引： -db.t1.dropIndex(&#123;'索引名称':1&#125;) mongodb mysql redis的区别和使用场景 -mysql是关系型数据库，支持事务 -MongoDB，redis非关系型数据库，不支持事务 -mysql，mongodb,redis的使用根据如何方便进行选择 -希望速度快的时候，选择mongodb或者是redis -数据量过大的时候，选择频繁使用的数据存入redis，其他的存入mongodb -mongodb不用提前建表建数据库，使用方便，字段数量不确定的时候使用mongodb -后续需要用到数据之间的关系，此时考虑mysql 爬虫数据去重 使用数据库建立关键字段（一个或者多个）建立索引进行去重 根据url地址进行去重 -使用场景： url地址对应的数据不会变的情况，url地址能够唯一判别一条数据的情况 -思路 url存在redis中 拿到url地址，判断url在redis的url的集合中是否存在 存在： 说明url已经被请求过，不再请求 不存在： url地址没有被请求过，请求，把该url存入redis的集合中 -布隆过滤器 使用多个加密算法加密url地址，得到多个值 往对应值的位置把结果设置为1 新来一个url地址，一样通过加密算法生成多个值 如果对应的位置的值全为1，说明这个url地址已经抓取过 否则没有抓过，就把对应位置的值设置为1 根据数据本身进行去重 选择特定的字段，使用加密算法（md5,sha1）将字段进行加密，生成字符串，存入redis的集合中 后续新来一条数据，同样的方法进行加密，如果得到的字符串在redis中存在，说明数据存在，对数据进行更新，否则说明数据不存在，直接插入","permalink":"https://codermino.github.io/2020/01/12/mongodb%E6%93%8D%E4%BD%9C/","photos":[]},{"tags":[{"name":"git","slug":"git","permalink":"https://codermino.github.io/tags/git/"}],"title":"Git基本操作","date":"2019/12/05","text":"master:默认开发分支 Head :默认开发分支 origin:默认远程版本库 Head^ :Head 的父提交 创建版本库 git clone &lt;url&gt; 克隆远程版本库 git init 初始化本地版本库 修改和提交 git status 查看状态 git diff 查看变更内容 git add . 跟踪所有改动过的文件#跟踪指定的文件 git add &lt;file&gt; 跟踪指定的文件 git mv &lt;old&gt; &lt;new&gt; 文件改名 git rm &lt;file&gt; 删除文件 git rm --cached &lt;file&gt; 停止跟踪文件但不删除 git commit -m 'message' 提交所有更新过的文件 git commit --amend 修改最后一次提交 查看提交历史 git log 查看提交历史 git log -p &lt;file&gt; 查看指定文件的提交历史 git blame &lt;file&gt; 以列表方式查看指定文件的提交历史 撤销 git reset --hard HEAD 撤消工作目录中所有未提交文件的修改内容 git checkout HEAD &lt;file&gt; 撤消指定的未提交文件的修改内容 git revert &lt;commit&gt; 撤消指定的提交 分支与标签 git branch 显示所有本地分支 git checkout &lt;branch/tag&gt; 切换到指定分支或标签 git branch &lt;new- branch&gt; 创建新分支 git branch -d &lt;branch&gt; 删除本地分支 git tag 列出所有本地标签 git tag &lt;tagname&gt; 基于最新提交创建标签 git tag -d &lt;tagname&gt; 删除标签 合并与衍合 git merge &lt;branch&gt; 合并指定分支到当前分支 git rebase &lt;branch&gt; 行合指定分支到当前分支 远程操作 git remote -V 查看远程版本库信息 git remote show &lt;remote&gt; 查看指定远程版本库信息 git remote add &lt;remote&gt; &lt;url&gt; 添加远程版本库 git fetch &lt;remote&gt; 从远程库获取代码 git pull &lt;remote&gt; &lt;branch&gt; 下载代码及快速合并 git push &lt;remote&gt; &lt;branch&gt; 上传代码及快速合并 git push &lt;remote&gt; : &lt;branch/ tag一name&gt; 删除远程分支或标签 git push --tags 上传所有标签 例子 git 新建分支并提交本地代码到远程分支 step1：在本地新建分支 git branch newbranch step2：把本地分支push到远程 git push origin newbranch step3：切换到该分支 git checkout newbranch step4：查看本地修改 git status step5：添加本地修改 git add . step6：commit修改 git commit -m 'XXXX' step7：push代码 git push OVER 在github远程端删除一个分支 git push origin :newbranch (分支名前的冒号代表删除) git创建tag标签 git add . git commit -m ‘xxxxx’ git tag ‘xxxx’ git pull git push –tags","permalink":"https://codermino.github.io/2019/12/05/Git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","photos":[]}]}