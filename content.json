{"meta":{"title":"Mino","subtitle":"Mino's personal blog","description":"Mino's personal blog","author":"Mino","url":"https://codermino.github.io","root":"/"},"posts":[{"tags":[{"name":"css3动画控制元素淡入淡出","slug":"css3动画控制元素淡入淡出","permalink":"https://codermino.github.io/tags/css3%E5%8A%A8%E7%94%BB%E6%8E%A7%E5%88%B6%E5%85%83%E7%B4%A0%E6%B7%A1%E5%85%A5%E6%B7%A1%E5%87%BA/"}],"title":"css3动画控制元素淡入淡出","date":"2020/10/07","text":"html部分&lt;div class&#x3D;&quot;demo&quot;&gt;&lt;&#x2F;div&gt; css部分/*定义公共淡入淡出效果 fadenum*/ @-webkit-keyframes fadenum&#123; 0%&#123; opacity: 0; &#125; 100%&#123; opacity: 1; &#125; &#125; @-moz-keyframes fadenum&#123; 0%&#123; opacity: 0; &#125; 100%&#123; opacity: 1; &#125; &#125; @-o-keyframes fadenum&#123; 0%&#123; opacity: 0; &#125; 100%&#123; opacity: 1; &#125; &#125; @keyframes fadenum&#123; 0%&#123; opacity: 0; &#125; 100%&#123; opacity: 1; &#125; &#125; /*元素使用该效果*/ .demo&#123; width: 300px; height: 200px; background: red; -webkit-animation: fadenum 4s ease; -moz-animation: fadenum 4s ease; animation:fadenum 4s ease; &#125;","permalink":"https://codermino.github.io/2020/10/07/css3%E5%8A%A8%E7%94%BB%E6%8E%A7%E5%88%B6%E5%85%83%E7%B4%A0%E6%B7%A1%E5%85%A5%E6%B7%A1%E5%87%BA/","photos":[]},{"tags":[{"name":"iview输入框去掉边框","slug":"iview输入框去掉边框","permalink":"https://codermino.github.io/tags/iview%E8%BE%93%E5%85%A5%E6%A1%86%E5%8E%BB%E6%8E%89%E8%BE%B9%E6%A1%86/"}],"title":"iview输入框去掉边框","date":"2020/10/07","text":"html部分&lt;i-input class&#x3D;&quot;txtput&quot; :maxlength&#x3D;&quot;20&quot; placeholder&#x3D;&quot;请输入...&quot; &gt;&lt;&#x2F;i-input&gt; css部分/* 穿透进iview的input框 */ .txtput &gt;&gt;&gt; .ivu-input&#123; width: 85%; border: none; outline:none; font-size: 20px; margin-left: 0%; border-bottom: 1.3px solid gainsboro; &#125; /* 去除点击之后的input框 */ .txtput &gt;&gt;&gt; .ivu-input:focus&#123; outline:none; border:none; box-shadow: 0 0 0 2px transparent; border-bottom: 1.3px solid gainsboro; &#125;","permalink":"https://codermino.github.io/2020/10/07/iview%E8%BE%93%E5%85%A5%E6%A1%86%E5%8E%BB%E6%8E%89%E8%BE%B9%E6%A1%86/","photos":[]},{"tags":[{"name":"vue3note","slug":"vue3note","permalink":"https://codermino.github.io/tags/vue3note/"}],"title":"vue3note","date":"2020/10/07","text":"","permalink":"https://codermino.github.io/2020/10/07/vue3note/","photos":[]},{"tags":[{"name":"vue父子组件数据双向绑定","slug":"vue父子组件数据双向绑定","permalink":"https://codermino.github.io/tags/vue%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/"}],"title":"vue父子组件数据双向绑定","date":"2020/10/06","text":"方法一父组件 &lt;child-test :inputData&#x3D;&quot;inputData&quot; @inputdataChange&#x3D;&quot;inputdataChange&quot;&gt;&lt;&#x2F;child-test&gt; &lt;span&gt;&#123;&#123;inputData&#125;&#125;&lt;&#x2F;span&gt; 子组件 &lt;template&gt; &lt;div class&#x3D;&quot;childTest&quot;&gt; 输入内容&lt;input type&#x3D;&quot;text&quot; :value&#x3D;&quot;inputData&quot; @input&#x3D;&quot;inputChange&quot;&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default &#123; name: &quot;childTest&quot;, props: &#123; inputData: &#123; type: String, default: &#39;&#39; &#125;, &#125;, methods: &#123; inputChange(e) &#123; this.$emit(&#39;inputdataChange&#39;,e.target.value) &#125; &#125;, &#125; &lt;&#x2F;script&gt; 方法二(使用v-model)官方介绍 允许一个自定义组件在使用 v-model 时定制 prop 和 event。默认情况下， 一个组件上的 v-model 会把 value 用作 prop 且把 input 用作 event， 但是一些输入类型比如单选框和复选框按钮可能想使用 value prop 来达到不同的目的。 使用 model 选项可以回避这些情况产生的冲突。 父组件不需要做方法监听，而是通过v-model指令绑定一个变量即可。1、子组件通过props接受一个父组件通过v-model指令绑定的变量 props: ['value'] 2、子组件新建一个model对象 model: &#123; prop: 'value', // props接受的变量名称 event: 'change' //定义一个方法 &#125; 父组件 &lt;child-test2 v-model&#x3D;&quot;inputData&quot;&gt;&lt;&#x2F;child-test2&gt; &#123;&#123;inputData&#125;&#125; 父组件则只要v-model绑定一个变量即可，当输入框改变时inputValue就会得到响应。 子组件 &lt;template&gt; &lt;div class&#x3D;&quot;childTest2&quot;&gt; &lt;!-- 输入值: &lt;input type&#x3D;&quot;text&quot; :value&#x3D;&quot;value&quot; @input&#x3D;&quot;inputChange&quot;&gt;--&gt; &lt;!-- 输入值: &lt;input type&#x3D;&quot;text&quot; :value&#x3D;&quot;inputData&quot; @change&#x3D;&quot;inputValueChange&quot;&gt;--&gt; 输入值: &lt;input type&#x3D;&quot;text&quot; :value&#x3D;&quot;inputData&quot; @input&#x3D;&quot;inputValueChange&quot;&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default &#123; name: &quot;childTest2&quot;, &#x2F;&#x2F; props: &#123; &#x2F;&#x2F; value: &#123; &#x2F;&#x2F; type: String &#x2F;&#x2F; &#125; &#x2F;&#x2F; &#125;, props: &#123; inputData: &#123; type: String &#125; &#125;, model: &#123; prop: &#39;inputData&#39;, &#x2F;&#x2F; props接受的变量名称 event: &#39;change&#39; &#x2F;&#x2F;定义一个方法(默认为input) &#125;, methods: &#123; &#x2F;&#x2F; inputChange(e) &#123; &#x2F;&#x2F; this.$emit(&#39;input&#39;,e.target.value); &#x2F;&#x2F; &#125;, inputValueChange(e)&#123; this.$emit(&#39;change&#39;,e.target.value); &#125; &#125;, &#125; 在input框改变的事件里通过$emit触发在model对象里面定义的change方法,并传入输入的的值。 &lt;&#x2F;script&gt;","permalink":"https://codermino.github.io/2020/10/06/vue%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/","photos":[]},{"tags":[{"name":"callback函数","slug":"callback函数","permalink":"https://codermino.github.io/tags/callback%E5%87%BD%E6%95%B0/"}],"title":"callback函数","date":"2020/09/28","text":"A callback is a function that is passed as an argument to another function and is executed after its parent function has completed. function add (num, callback) &#123; if (num &gt; 10) &#123; // eslint-disable-next-line standard/no-callback-literal callback(num + 1) &#125; else &#123; callback(num) &#125; &#125; add(0, item =&gt; &#123; console.log(item) &#125;)","permalink":"https://codermino.github.io/2020/09/28/callback%E5%87%BD%E6%95%B0/","photos":[]},{"tags":[{"name":"mysql优化一般步骤","slug":"mysql优化一般步骤","permalink":"https://codermino.github.io/tags/mysql%E4%BC%98%E5%8C%96%E4%B8%80%E8%88%AC%E6%AD%A5%E9%AA%A4/"}],"title":"mysql优化一般步骤","date":"2020/09/20","text":"创建索引 总体上来说，子查询还是不如连接查询快 select优化插入大量数据的时候，先删除索引，导完再把索引添加上。 InnoDB的表按照主键顺序插入会比较快。 先将自动提交修改为手动提交。（AUTOCOMMIT=0时比1时快） 优化insert语句 多行数据最好一次性插入，这样还可以用INSERT DELAYED让数据放在内存队列中，快速插入。 户当从一个文本文件装载一个表时，使用LOAD DATA 1NFILE。这通常比使用很多INSERT语句快20倍。 优化ORDER BY语句通过索引直接返回的已经是有序数据，尽量减少额外的排序。 #以下可用:# SELECT*FROM fiabname ORDER BY key_partl,key_part2； SELECT*FROM tabname WHERE key_partl=1 ORDER BY key_partl DESC, key_part2 DESC； SELE*FROM tabname ORDER BY key_partl oESC, key_part2 DESC； #以下勿用# SELECT * FROM tabname ORDER BY key_partl DESC, key_part2 ASC: --order by的字段混合ASC和ESC SELECT * FROM tabname WHERE key2=constant ORDER BY keyl; 一用于查询行的关键字与ORDER B丫中所使用的不相同 SELECT*FROM tabname ORDER BY keyl, key2; 一对不同的关键字使用ORDER BY 优化GROUP BY语句默认情况下，MySQL对所有GROUP BY coll,col2,…的字段进行排序。 例如：select payment_date, sum(amount) from payment group by payment_date； 优化之后：select payment_date, sum(amount) from payment group by payment_date order by null;禁止了排序 优化OR条件对于含有OR的查询子句，如果要利用索引，则OR之间的每个条件列都必须用到索引; 如果没有索引.则应该考虑增加索引。 如果or前后的字段是符合索引，则索引会失效，因为mysql是分别查询之后 再UNION在一起的。 优化分页查询\"limit 1000,20\" 前1000条记录都会被抛弃，查询和排序的代价非常高。 a: 先单独查询出分页记录对应的主键，再连表查询出主键加其他字段。（避免了全表扫描） 优化前：select film_id, description from film order by title limit 50,5; 优化后：select a.film_id, a.description from film a inner join (select film_id from film order by title limit 50,5) b on a.film_id=b.film_id； 使用SQL提示索引提示：select count(*) from rental use index (idx_rental date)； 索引忽略：select count(*) from rental ignore index (idx_rental date); 强制索引：select * from rental force index (idx_fk_inventory_id) where inventory_id&gt;1; 常用sql技巧1：使用正则表达式 2：巧用RAND()提取随机行 select * from category order by rand() limit 5；随机排序之后去前5条记录。","permalink":"https://codermino.github.io/2020/09/20/mysql%E4%BC%98%E5%8C%96%E4%B8%80%E8%88%AC%E6%AD%A5%E9%AA%A4/","photos":[]},{"tags":[{"name":"mysql查询某时间范围的数据","slug":"mysql查询某时间范围的数据","permalink":"https://codermino.github.io/tags/mysql%E6%9F%A5%E8%AF%A2%E6%9F%90%E6%97%B6%E9%97%B4%E8%8C%83%E5%9B%B4%E7%9A%84%E6%95%B0%E6%8D%AE/"}],"title":"mysql查询某时间范围的数据","date":"2020/09/20","text":"根据时间范围查询对应的数据-- 查询今天的数据 select * from daily where to_days(createtime) = to_days(CURDATE()); -- 查询昨天的数据 select * from daily where to_days(CURDATE()) - to_days(createtime)&lt;=1; -- 查询最近7天的数据 select * from daily where createtime &gt; DATE_SUB(CURDATE(),INTERVAL 7 DAY); -- 查询最近一个季度的数据 select * from daily where createtime &gt; DATE_SUB(CURDATE(), INTERVAL 3 MONTH) -- 最近一年的数据 select * from daily where createtime &gt; DATE_SUB(CURDATE(), INTERVAL 1 YEAR); -- 本季度的数据 select * from daily where quarter(createtime) = quarter(CURDATE()); -- 上季度的数据 select * from daily where quarter(createtime) = quarter(DATE_SUB(CURDATE(), INTERVAL 1 QUARTER)); -- 查询今年的数据 select * from daily where year(CURDATE()) - year(createtime) = 28 ; -- 查询第几月的数据 select * from daily where month(createtime) = 8 ; -- 查询某年某月某日的数据 select * from daily where date_format(createtime,'%Y-%m-%d')='2017-07-07'; -- 查询制定时间段内的数据（只写到月，会出错） select * from daily where createtime between '1888-5-1 00:00:00' and '2017-9-3 00:00:00'; -- 查询制定时间段内的数据（只写到月，会出错） select * from daily where createtime &gt; '1989-5-1' and createtime &lt; '2017-5-1';","permalink":"https://codermino.github.io/2020/09/20/mysql%E6%9F%A5%E8%AF%A2%E6%9F%90%E6%97%B6%E9%97%B4%E8%8C%83%E5%9B%B4%E7%9A%84%E6%95%B0%E6%8D%AE/","photos":[]},{"tags":[{"name":"vue路由调转传递参数","slug":"vue路由调转传递参数","permalink":"https://codermino.github.io/tags/vue%E8%B7%AF%E7%94%B1%E8%B0%83%E8%BD%AC%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0/"}],"title":"vue路由调转传递参数","date":"2020/09/15","text":"第一种方式todetail(id) &#123; this.$router.push(&#123; path: &#96;&#x2F;detail&#x2F;$&#123;id&#125;&#96;, &#125;) &#125; &#x2F;&#x2F; 第一种方式传参 &#123; path: &#39;&#x2F;detail&#x2F;:id&#39;, name: &#39;detail&#39;, meta:&#123; title:&#39;新闻详情&#39; &#125;, component: () &#x3D;&gt; import(&#x2F;* webpackChunkName: &quot;about&quot; *&#x2F; &#39;@&#x2F;components&#x2F;detail&#x2F;detail.vue&#39;) &#125; 接收 &#x2F;&#x2F; this.id &#x3D; this.$route.params.id; 第二种方式&#x2F;&#x2F;第二种方式 todetail(id)&#123; this.$router.push(&#123; name: &#39;detail&#39;, params: &#123; id: id &#125; &#125;) &#125; &#x2F;&#x2F;第二种方式 &#123; path: &#39;&#x2F;detail&#39;, name: &#39;detail&#39;, meta:&#123; title:&#39;新闻详情&#39; &#125;, component: () &#x3D;&gt; import(&#x2F;* webpackChunkName: &quot;about&quot; *&#x2F; &#39;@&#x2F;components&#x2F;detail&#x2F;detail.vue&#39;) &#125; 接收 &#x2F;&#x2F; this.id &#x3D; this.$route.params.id; 第三种方式&#x2F;&#x2F;第三种方式 todetail(id)&#123; this.$router.push(&#123; path: &#39;&#x2F;detail&#39;, query: &#123; id: id &#125; &#125;) &#125; &#123; path: &#39;&#x2F;detail&#39;, name: &#39;detail&#39;, meta:&#123; title:&#39;新闻详情&#39; &#125;, component: () &#x3D;&gt; import(&#x2F;* webpackChunkName: &quot;about&quot; *&#x2F; &#39;@&#x2F;components&#x2F;detail&#x2F;detail.vue&#39;) &#125; &#x2F;&#x2F;接收 this.id &#x3D; this.$route.query.id;","permalink":"https://codermino.github.io/2020/09/15/vue%E8%B7%AF%E7%94%B1%E8%B0%83%E8%BD%AC%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0/","photos":[]},{"tags":[{"name":"vue中引入本地文件的方式","slug":"vue中引入本地文件的方式","permalink":"https://codermino.github.io/tags/vue%E4%B8%AD%E5%BC%95%E5%85%A5%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E5%BC%8F/"}],"title":"vue中引入本地文件的方式","date":"2020/09/13","text":"第一种方式使用import进行引入import detail from &#39;@&#x2F;json&#x2F;learn.json&#39; import data from &#39;@&#x2F;assets&#x2F;data.json&#39; import detail from &#39;..&#x2F;json&#x2F;learn.json&#39; import &#39;..&#x2F;assets&#x2F;js&#x2F;SCIT0039_map&#39; import italydata from &#39;..&#x2F;assets&#x2F;json&#x2F;italy20200301&#39; 第二种使用axios进行引入 npm install axiosimport axios from &#39;axios&#39; Vue.prototype.$http&#x3D;axios this.$http.get(&#39;..&#x2F;..&#x2F;static&#x2F;data.json&#39;).then((response) &#x3D;&gt; &#123; console.log(response); &#125;); &#125;","permalink":"https://codermino.github.io/2020/09/13/vue%E4%B8%AD%E5%BC%95%E5%85%A5%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E5%BC%8F/","photos":[]},{"tags":[{"name":"iview多级抽屉优化","slug":"iview多级抽屉优化","permalink":"https://codermino.github.io/tags/iview%E5%A4%9A%E7%BA%A7%E6%8A%BD%E5%B1%89%E4%BC%98%E5%8C%96/"}],"title":"iview多级抽屉优化","date":"2020/09/13","text":"多级抽屉优化 可能出现的问题: 使用两个mask切换的时候会出现闪动的现象 如果只使用一级抽屉的mask的时候，二级抽屉的closeable的叉号无法点击(层级关系) 如果使用二级抽屉的mask的时候，会出现一级抽屉没有mask(效果不好) 如果不调整二级抽屉和一级抽屉的层级的时候，二级抽屉默认的是会从一级抽屉的上方滑出(效果不好) 解决方案，目前想出两种 共同的改动：将二级抽屉的层级改为比一级抽屉的层级第一级，例如：一级抽屉的层级为1002，二级抽屉的层级为1001 使用一个变量来进行一级抽屉和二级抽屉的mask的显示和隐藏。并且一级抽屉的bcakground-color: transparent 二级抽屉的background-color: rgba(55,55,55,.6) !important; 自定义一个div.mask幕布来进行遮盖，并且自定义幕布的层级比内容区域的层级高。但是比一级抽屉和二级抽屉的层级 低。并且使用定位的方式进行布局和背景颜色设置等。监听自定义幕布的点击事件。来进行抽屉的关闭。 代码&lt;template&gt; &lt;div class&#x3D;&quot;layout&quot; style&#x3D;&quot;height: 100%;&quot;&gt; &lt;Layout&gt; &lt;Header&gt; &lt;Icon type&#x3D;&quot;ios-paper&quot; @click&#x3D;&quot;showDrawer&#x3D;true&quot;&gt;&lt;&#x2F;Icon&gt; &lt;&#x2F;Header&gt; &lt;Layout&gt; &lt;Sider hide-trigger :style&#x3D;&quot;&#123;background: &#39;#fff&#39;&#125;&quot;&gt; &lt;Menu active-name&#x3D;&quot;1-2&quot; theme&#x3D;&quot;light&quot; width&#x3D;&quot;auto&quot; :open-names&#x3D;&quot;[&#39;1&#39;]&quot;&gt; &lt;Submenu name&#x3D;&quot;1&quot;&gt; &lt;template slot&#x3D;&quot;title&quot;&gt; &lt;Icon type&#x3D;&quot;ios-navigate&quot;&gt;&lt;&#x2F;Icon&gt; Item 1 &lt;&#x2F;template&gt; &lt;MenuItem name&#x3D;&quot;1-1&quot;&gt;Option 1&lt;&#x2F;MenuItem&gt; &lt;MenuItem name&#x3D;&quot;1-2&quot;&gt;Option 2&lt;&#x2F;MenuItem&gt; &lt;MenuItem name&#x3D;&quot;1-3&quot;&gt;Option 3&lt;&#x2F;MenuItem&gt; &lt;&#x2F;Submenu&gt; &lt;Submenu name&#x3D;&quot;2&quot;&gt; &lt;template slot&#x3D;&quot;title&quot;&gt; &lt;Icon type&#x3D;&quot;ios-keypad&quot;&gt;&lt;&#x2F;Icon&gt; Item 2 &lt;&#x2F;template&gt; &lt;MenuItem name&#x3D;&quot;2-1&quot;&gt;Option 1&lt;&#x2F;MenuItem&gt; &lt;MenuItem name&#x3D;&quot;2-2&quot;&gt;Option 2&lt;&#x2F;MenuItem&gt; &lt;&#x2F;Submenu&gt; &lt;Submenu name&#x3D;&quot;3&quot;&gt; &lt;template slot&#x3D;&quot;title&quot;&gt; &lt;Icon type&#x3D;&quot;ios-analytics&quot;&gt;&lt;&#x2F;Icon&gt; Item 3 &lt;&#x2F;template&gt; &lt;MenuItem name&#x3D;&quot;3-1&quot;&gt;Option 1&lt;&#x2F;MenuItem&gt; &lt;MenuItem name&#x3D;&quot;3-2&quot;&gt;Option 2&lt;&#x2F;MenuItem&gt; &lt;&#x2F;Submenu&gt; &lt;&#x2F;Menu&gt; &lt;&#x2F;Sider&gt; &lt;!-- 方案一--&gt; &lt;!-- &lt;div class&#x3D;&quot;drawer&quot;&gt;--&gt; &lt;!-- &lt;Drawer :mask-closable&#x3D;&quot;!showSubDrawer&quot; :mask&#x3D;&quot;!showSubDrawer&quot; title&#x3D;&quot;Multi-level drawer&quot; width&#x3D;&quot;256&quot; :closable&#x3D;&quot;false&quot; v-model&#x3D;&quot;showDrawer&quot; placement&#x3D;&quot;left&quot; :transfer&#x3D;&quot;false&quot; :inner&#x3D;&quot;true&quot;&gt;--&gt; &lt;!-- &lt;Button @click&#x3D;&quot;showSubDrawer &#x3D; !showSubDrawer&quot; type&#x3D;&quot;primary&quot;&gt;Two-level Drawer&lt;&#x2F;Button&gt;--&gt; &lt;!-- &lt;&#x2F;Drawer&gt;--&gt; &lt;!-- &lt;div class&#x3D;&quot;subDrawer&quot;&gt;--&gt; &lt;!-- &lt;Drawer @on-close&#x3D;&quot;drawerClose&quot; :mask&#x3D;&quot;showSubDrawer&quot; class&#x3D;&quot;subdrawer-inner&quot; placement&#x3D;&quot;left&quot; title&#x3D;&quot;Two-level Drawer&quot; v-model&#x3D;&quot;showSubDrawer&quot; :transfer&#x3D;&quot;false&quot; :inner&#x3D;&quot;true&quot;&gt;--&gt; &lt;!-- This is two-level drawer.--&gt; &lt;!-- &lt;&#x2F;Drawer&gt;--&gt; &lt;!-- &lt;&#x2F;div&gt;--&gt; &lt;!-- &lt;&#x2F;div&gt;--&gt; &lt;!-- 方案一结束--&gt; &lt;!-- 方案二--&gt; &lt;div class&#x3D;&quot;drawer&quot;&gt; &lt;Drawer :mask&#x3D;&quot;false&quot; title&#x3D;&quot;Multi-level drawer&quot; width&#x3D;&quot;256&quot; :closable&#x3D;&quot;false&quot; v-model&#x3D;&quot;showDrawer&quot; placement&#x3D;&quot;left&quot; :transfer&#x3D;&quot;false&quot; :inner&#x3D;&quot;true&quot;&gt; &lt;Button @click&#x3D;&quot;showSubDrawer &#x3D; !showSubDrawer&quot; type&#x3D;&quot;primary&quot;&gt;Two-level Drawer&lt;&#x2F;Button&gt; &lt;&#x2F;Drawer&gt; &lt;div class&#x3D;&quot;subDrawer&quot;&gt; &lt;Drawer :mask&#x3D;&quot;false&quot; @on-close&#x3D;&quot;drawerClose&quot; class&#x3D;&quot;subdrawer-inner&quot; placement&#x3D;&quot;left&quot; title&#x3D;&quot;Two-level Drawer&quot; v-model&#x3D;&quot;showSubDrawer&quot; :transfer&#x3D;&quot;false&quot; :inner&#x3D;&quot;true&quot;&gt; This is two-level drawer. &lt;&#x2F;Drawer&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div v-show&#x3D;&quot;showDrawer&quot; class&#x3D;&quot;mask&quot; @click&#x3D;&quot;drawerClose&quot;&gt;&lt;&#x2F;div&gt; &lt;!-- 方案二结束--&gt; &lt;Layout :style&#x3D;&quot;&#123;padding: &#39;0 24px 24px&#39;&#125;&quot;&gt; &lt;Breadcrumb :style&#x3D;&quot;&#123;margin: &#39;24px 0&#39;&#125;&quot;&gt; &lt;BreadcrumbItem&gt;Home&lt;&#x2F;BreadcrumbItem&gt; &lt;BreadcrumbItem&gt;Components&lt;&#x2F;BreadcrumbItem&gt; &lt;BreadcrumbItem&gt;Layout&lt;&#x2F;BreadcrumbItem&gt; &lt;&#x2F;Breadcrumb&gt; &lt;Content :style&#x3D;&quot;&#123;padding: &#39;24px&#39;, minHeight: &#39;280px&#39;, background: &#39;#fff&#39;&#125;&quot;&gt; Content &lt;&#x2F;Content&gt; &lt;&#x2F;Layout&gt; &lt;&#x2F;Layout&gt; &lt;&#x2F;Layout&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default &#123; data() &#123; return &#123; showSubDrawer: false, showDrawer: false &#125; &#125;, methods: &#123; drawerClose()&#123; this.showDrawer &#x3D; false this.showSubDrawer &#x3D; false &#125; &#125;, &#125; &lt;&#x2F;script&gt; &lt;style scoped lang&#x3D;&quot;scss&quot;&gt; &#x2F;deep&#x2F; .ivu-layout-has-sider&#123; position: relative; &#125; &#x2F;deep&#x2F; .ivu-layout&#123; height: 100%; &#125; .layout&#123; border: 1px solid #d7dde4; background: #f5f7f9; position: relative; border-radius: 4px; overflow: hidden; &#125; .layout-logo&#123; width: 100px; height: 30px; background: #5b6270; border-radius: 3px; float: left; position: relative; top: 15px; left: 20px; &#125; .layout-nav&#123; width: 420px; margin: 0 20px 0 auto; &#125; &#x2F;*方案一*&#x2F; &#x2F;*.drawer&#123;*&#x2F; &#x2F;* div:first-child&#123;*&#x2F; &#x2F;* &#x2F;deep&#x2F; .ivu-drawer-wrap&#123;*&#x2F; &#x2F;* z-index: 1002;*&#x2F; &#x2F;* &#125;*&#x2F; &#x2F;* &#x2F;deep&#x2F; .ivu-drawer-mask&#123;*&#x2F; &#x2F;* background-color: transparent;*&#x2F; &#x2F;* &#125;*&#x2F; &#x2F;* &#125;*&#x2F; &#x2F;* .subDrawer&#123;*&#x2F; &#x2F;* div:first-child&#123;*&#x2F; &#x2F;* &#x2F;deep&#x2F; .ivu-drawer-wrap&#123;*&#x2F; &#x2F;* z-index: 1001;*&#x2F; &#x2F;* &#125;*&#x2F; &#x2F;* &#x2F;deep&#x2F; .ivu-drawer-mask&#123;*&#x2F; &#x2F;* background-color: rgba(55,55,55,.6) !important;*&#x2F; &#x2F;* &#125;*&#x2F; &#x2F;* &#125;*&#x2F; &#x2F;* &#125;*&#x2F; &#x2F;*&#125;*&#x2F; &#x2F;*方案二*&#x2F; &#x2F;*&#x2F;deep&#x2F; .ivu-menu&#123;*&#x2F; &#x2F;* z-index: 9;*&#x2F; &#x2F;*&#125; *&#x2F; .drawer&#123; div:first-child&#123; &#x2F;deep&#x2F; .ivu-drawer-wrap&#123; z-index: 1002; &#125; &#125; .subDrawer&#123; div:first-child&#123; &#x2F;deep&#x2F; .ivu-drawer-wrap&#123; z-index: 1001; &#125; &#125; &#125; &#125; .mask&#123; position: absolute; top: 0; right: 0; left: 0; bottom: 0; z-index: 1000; background-color: rgba(55,55,55,.6); &#125; .subdrawer-inner&#123; &#x2F;deep&#x2F; .ivu-drawer&#123; margin-left: 256px; &#125; &#125; &lt;&#x2F;style&gt;","permalink":"https://codermino.github.io/2020/09/13/iview%E5%A4%9A%E7%BA%A7%E6%8A%BD%E5%B1%89%E4%BC%98%E5%8C%96/","photos":[]},{"tags":[{"name":"iview可编辑表格","slug":"iview可编辑表格","permalink":"https://codermino.github.io/tags/iview%E5%8F%AF%E7%BC%96%E8%BE%91%E8%A1%A8%E6%A0%BC/"}],"title":"iview可编辑表格","date":"2020/09/13","text":"Demo1点击按钮进行编辑和保存&lt;template&gt; &lt;i-table border :columns&#x3D;&quot;columns2&quot; :data&#x3D;&quot;data3&quot;&gt;&lt;&#x2F;i-table&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default &#123; data () &#123; return &#123; columns2: [ &#123; title: &#39;Name&#39;, key: &#39;name&#39;, render: (h, params) &#x3D;&gt; &#123; if (params.row.$isEdit) &#123; return h(&#39;input&#39;, &#123; domProps: &#123; value: params.row.name &#125;, on: &#123; input: function (event) &#123; params.row.name &#x3D; event.target.value &#125; &#125; &#125;); &#125; else &#123; return h(&#39;div&#39;, params.row.name); &#125; &#125; &#125;, &#123; title: &#39;Age&#39;, key: &#39;age&#39;, render: (h, params) &#x3D;&gt; &#123; if (params.row.$isEdit) &#123; return h(&#39;input&#39;, &#123; domProps: &#123; value: params.row.age &#125;, on: &#123; input: function (event) &#123; params.row.age &#x3D; event.target.value &#125; &#125; &#125;); &#125; else &#123; return h(&#39;div&#39;, params.row.age); &#125; &#125; &#125;, &#123; title: &#39;Address&#39;, key: &#39;address&#39; &#125;, &#123; title: &#39;Action&#39;, key: &#39;action&#39;, render: (h, params) &#x3D;&gt; &#123; return h(&#39;Button&#39;, &#123; props: &#123; type: &#39;primary&#39;, size: &#39;small&#39; &#125;, on: &#123; click: () &#x3D;&gt; &#123; if (params.row.$isEdit) &#123; this.handleSave(params.row) &#125; else &#123; this.handleEdit(params.row) &#125; &#125; &#125; &#125;, params.row.$isEdit ? &#39;保存&#39; : &#39;编辑&#39;) &#125; &#125; ], data3: [ &#123; name: &#39;哈哈&#39;, age: 18, address: &#39;上海&#39;, $isEdit: false &#125;, &#123; name: &#39;啦啦&#39;, age: 24, address: &#39;北京&#39;, $isEdit: false &#125; ] &#125; &#125;, methods: &#123; handleEdit (row) &#123; this.$set(row, &#39;$isEdit&#39;, true) &#125;, handleSave (row) &#123; this.$set(row, &#39;$isEdit&#39;, false) &#125; &#125; &#125; &lt;&#x2F;script&gt; Demo2点击单元格编辑自动聚焦和可选择表格&lt;template&gt; &lt;i-table border :columns&#x3D;&quot;columns2&quot; :data&#x3D;&quot;data3&quot;&gt;&lt;&#x2F;i-table&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default &#123; data () &#123; return &#123; columns2: [ &#123; type: &#39;selection&#39;, width: 60, align: &#39;center&#39; &#125;, &#123; title: &#39;姓名&#39;, key: &#39;name&#39;, render: (h, params) &#x3D;&gt; &#123; let create &#x3D; this.$createElement let dom &#x3D; create(&#39;Input&#39;, &#123; ref: params.row.id+&#39;_name&#39;, props: &#123; type: &quot;text&quot;, value: params.row.name &#125;, on: &#123; &quot;on-blur&quot;: event &#x3D;&gt; &#123; params.row.name &#x3D; event.target.value; this.$set(params.row, &#39;$isEdit&#39;, false); &#125;, &#125; &#125;) let dom2 &#x3D; create(&#39;div&#39;, &#123; on: &#123; click: (e) &#x3D;&gt; &#123; this.$set(params.row, &#39;$isEdit&#39;, true); this.$nextTick( () &#x3D;&gt;&#123; this.$refs[params.row.id+&#39;_name&#39;].focus() &#125; ) &#125;, &#125; &#125;,params.row.name) if (params.row.$isEdit)&#123; return dom &#125; else&#123;return dom2&#125; &#125; &#125;, &#123; title: &#39;Age&#39;, key: &#39;age&#39;, render: (h, params) &#x3D;&gt; &#123; let create &#x3D; this.$createElement let dom &#x3D; create(&#39;Input&#39;, &#123; ref: params.row.id+&#39;_age&#39;, props: &#123; type: &quot;text&quot;, value: params.row.age &#125;, on: &#123; &quot;on-blur&quot;: event &#x3D;&gt; &#123; params.row.age &#x3D; event.target.value; this.$set(params.row, &#39;$isEdit&#39;, false); &#125;, &#125; &#125;) let dom2 &#x3D; create(&#39;div&#39;, &#123; on: &#123; click: (e) &#x3D;&gt; &#123; this.$set(params.row, &#39;$isEdit&#39;, true); this.$nextTick( () &#x3D;&gt;&#123; this.$refs[params.row.id+&#39;_age&#39;].focus() &#125; ) &#125;, &#125; &#125;,params.row.age) if (params.row.$isEdit)&#123; return dom &#125; else&#123;return dom2&#125; &#125; &#125;, &#123; title: &#39;Action&#39;, key: &#39;action&#39;, render: (h, params) &#x3D;&gt; &#123; return h(&#39;Button&#39;, &#123; props: &#123; type: &#39;primary&#39;, size: &#39;small&#39; &#125;, on: &#123; click: () &#x3D;&gt; &#123; if (params.row.$isEdit) &#123; this.handleSave(params.row) &#125; else &#123; this.handleEdit(params.row) &#125; &#125; &#125; &#125;, params.row.$isEdit ? &#39;保存&#39; : &#39;编辑&#39;) &#125; &#125; ], data3: [ &#123; id:1, name: &#39;王小明&#39;, age: 18, address: &#39;北京市朝阳区芍药居&#39;, date: &#39;2016-10-03&#39;, $isEdit: false &#125;, &#123; id:2, name: &#39;张小刚&#39;, age: 25, address: &#39;北京市海淀区西二旗&#39;, date: &#39;2016-10-01&#39;, $isEdit: false &#125;, &#123; id:3, name: &#39;李小红&#39;, age: 30, address: &#39;上海市浦东新区世纪大道&#39;, date: &#39;2016-10-02&#39;, $isEdit: false &#125;, &#123; id:4, name: &#39;周小伟&#39;, age: 26, address: &#39;深圳市南山区深南大道&#39;, date: &#39;2016-10-04&#39;, $isEdit: false &#125; ] &#125; &#125;, methods: &#123; handleEdit (row) &#123; this.$set(row, &#39;$isEdit&#39;, true) &#125;, handleSave (row) &#123; this.$set(row, &#39;$isEdit&#39;, false) &#125; &#125; &#125; &lt;&#x2F;script&gt; Demo3功能同Demo2，无操作按钮&lt;template&gt; &lt;i-table border :columns&#x3D;&quot;columns2&quot; :data&#x3D;&quot;data3&quot;&gt;&lt;&#x2F;i-table&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default &#123; data () &#123; return &#123; columns2: [ &#123; type: &#39;selection&#39;, width: 60, align: &#39;center&#39; &#125;, &#123; title: &#39;姓名&#39;, key: &#39;name&#39;, render: (h, params) &#x3D;&gt; &#123; let create &#x3D; this.$createElement let dom &#x3D; create(&#39;Input&#39;, &#123; ref: params.row.id+&#39;_name&#39;, props: &#123; type: &quot;text&quot;, value: params.row.name &#125;, on: &#123; &quot;on-blur&quot;: event &#x3D;&gt; &#123; params.row.name &#x3D; event.target.value; this.$set(params.row, &#39;$isEdit&#39;, false); &#125;, &#125; &#125;) let dom2 &#x3D; create(&#39;div&#39;, &#123; on: &#123; click: (e) &#x3D;&gt; &#123; this.$set(params.row, &#39;$isEdit&#39;, true); this.$nextTick( () &#x3D;&gt;&#123; this.$refs[params.row.id+&#39;_name&#39;].focus() &#125; ) &#125;, &#125; &#125;,params.row.name) if (params.row.$isEdit)&#123; return dom &#125; else&#123;return dom2&#125; &#125; &#125;, &#123; title: &#39;Age&#39;, key: &#39;age&#39;, render: (h, params) &#x3D;&gt; &#123; let create &#x3D; this.$createElement let dom &#x3D; create(&#39;Input&#39;, &#123; ref: params.row.id+&#39;_age&#39;, props: &#123; type: &quot;text&quot;, value: params.row.age &#125;, on: &#123; &quot;on-blur&quot;: event &#x3D;&gt; &#123; params.row.age &#x3D; event.target.value; this.$set(params.row, &#39;$isEdit&#39;, false); &#125;, &#125; &#125;) let dom2 &#x3D; create(&#39;div&#39;, &#123; on: &#123; click: (e) &#x3D;&gt; &#123; this.$set(params.row, &#39;$isEdit&#39;, true); this.$nextTick( () &#x3D;&gt;&#123; this.$refs[params.row.id+&#39;_age&#39;].focus() &#125; ) &#125;, &#125; &#125;,params.row.age) if (params.row.$isEdit)&#123; return dom &#125; else&#123;return dom2&#125; &#125; &#125; ], data3: [ &#123; id:1, name: &#39;王小明&#39;, age: 18, address: &#39;北京市朝阳区芍药居&#39;, date: &#39;2016-10-03&#39;, $isEdit: false &#125;, &#123; id:2, name: &#39;张小刚&#39;, age: 25, address: &#39;北京市海淀区西二旗&#39;, date: &#39;2016-10-01&#39;, $isEdit: false &#125;, &#123; id:3, name: &#39;李小红&#39;, age: 30, address: &#39;上海市浦东新区世纪大道&#39;, date: &#39;2016-10-02&#39;, $isEdit: false &#125;, &#123; id:4, name: &#39;周小伟&#39;, age: 26, address: &#39;深圳市南山区深南大道&#39;, date: &#39;2016-10-04&#39;, $isEdit: false &#125; ] &#125; &#125;, methods: &#123; handleEdit (row) &#123; this.$set(row, &#39;$isEdit&#39;, true) &#125;, handleSave (row) &#123; this.$set(row, &#39;$isEdit&#39;, false) &#125; &#125; &#125; &lt;&#x2F;script&gt; Demo4更改ref设置方式&lt;template&gt; &lt;i-table border :columns&#x3D;&quot;columns2&quot; :data&#x3D;&quot;data3&quot;&gt;&lt;&#x2F;i-table&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default &#123; data () &#123; return &#123; columns2: [ &#123; type: &#39;selection&#39;, width: 60, align: &#39;center&#39; &#125;, &#123; title: &#39;姓名&#39;, key: &#39;name&#39;, render: (h, params) &#x3D;&gt; &#123; let create &#x3D; this.$createElement let dom1 &#x3D; create(&#39;Input&#39;, &#123; ref: params.row[Object.keys(params.row)[Object.keys(params.row).length-2]]+&#39;_name&#39;, props: &#123; type: &quot;text&quot;, value: params.row.name &#125;, on: &#123; &quot;on-blur&quot;: event &#x3D;&gt; &#123; params.row.name &#x3D; event.target.value; this.$set(params.row, &#39;$isEdit&#39;, false); &#125;, &#125; &#125;) let dom2 &#x3D; create(&#39;div&#39;, &#123; on: &#123; click: (e) &#x3D;&gt; &#123; this.$set(params.row, &#39;$isEdit&#39;, true); this.$nextTick( () &#x3D;&gt;&#123; this.$refs[params.row[Object.keys(params.row)[Object.keys(params.row).length-2]]+&#39;_name&#39;].focus() &#125; ) &#125;, &#125; &#125;,params.row.name) if (params.row.$isEdit)&#123; return dom1 &#125; else&#123;return dom2&#125; &#125; &#125;, &#123; title: &#39;Age&#39;, key: &#39;age&#39;, render: (h, params) &#x3D;&gt; &#123; let create &#x3D; this.$createElement let dom3 &#x3D; create(&#39;Input&#39;, &#123; ref: params.row[Object.keys(params.row)[Object.keys(params.row).length-2]]+&#39;_age&#39;, props: &#123; type: &quot;text&quot;, value: params.row.age &#125;, on: &#123; &quot;on-blur&quot;: event &#x3D;&gt; &#123; params.row.age &#x3D; event.target.value; this.$set(params.row, &#39;$isEdit&#39;, false); &#125;, &#125; &#125;) let dom4 &#x3D; create(&#39;div&#39;, &#123; on: &#123; click: (e) &#x3D;&gt; &#123; this.$set(params.row, &#39;$isEdit&#39;, true); this.$nextTick( () &#x3D;&gt;&#123; this.$refs[params.row[Object.keys(params.row)[Object.keys(params.row).length-2]]+&#39;_age&#39;].focus() &#125; ) &#125;, &#125; &#125;,params.row.age) if (params.row.$isEdit)&#123; return dom3 &#125; else&#123;return dom4&#125; &#125; &#125; ], data3: [ &#123; name: &#39;王小明&#39;, age: 18, $isEdit: false &#125;, &#123; name: &#39;张小刚&#39;, age: 25, $isEdit: false &#125;, &#123; name: &#39;李小红&#39;, age: 30, $isEdit: false &#125;, &#123; name: &#39;周小伟&#39;, age: 26, $isEdit: false &#125; ] &#125; &#125;, methods: &#123; handleEdit (row) &#123; this.$set(row, &#39;$isEdit&#39;, true) &#125;, handleSave (row) &#123; this.$set(row, &#39;$isEdit&#39;, false) &#125; &#125; &#125; &lt;&#x2F;script&gt; Demo5增加回车事件&lt;template&gt; &lt;div&gt; &lt;i-table border :columns&#x3D;&quot;columns2&quot; :data&#x3D;&quot;data3&quot;&gt;&lt;&#x2F;i-table&gt; &lt;Divider orientation&#x3D;&quot;left&quot;&gt;Left Text&lt;&#x2F;Divider&gt; &#123;&#123;data3&#125;&#125; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default &#123; data () &#123; return &#123; columns2: [ &#123; type: &#39;selection&#39;, width: 60, align: &#39;center&#39; &#125;, &#123; title: &#39;姓名&#39;, key: &#39;name&#39;, render: (h, params) &#x3D;&gt; &#123; let create &#x3D; this.$createElement; let dom1 &#x3D; create(&#39;Input&#39;, &#123; ref: params.row[Object.keys(params.row)[Object.keys(params.row).length-2]]+&#39;_name&#39;, props: &#123; type: &quot;text&quot;, value: params.row.name, placeholder:&#39;请输入姓名&#39; &#125;, on: &#123; &quot;on-blur&quot;: event &#x3D;&gt; &#123; params.row.name &#x3D; event.target.value; this.data3[params.index].name &#x3D; event.target.value; this.$set(params.row, &#39;$isEdit&#39;, false); &#125;, &quot;on-enter&quot;:event&#x3D;&gt;&#123; params.row.name &#x3D; event.target.value; this.data3[params.index].name &#x3D; event.target.value; this.$set(params.row, &#39;$isEdit&#39;, false); &#125; &#125; &#125;) let dom2 &#x3D; create(&#39;div&#39;, &#123; on: &#123; click: (e) &#x3D;&gt; &#123; this.$set(params.row, &#39;$isEdit&#39;, true); this.$nextTick( () &#x3D;&gt;&#123; this.$refs[params.row[Object.keys(params.row)[Object.keys(params.row).length-2]]+&#39;_name&#39;].focus() &#125; ) &#125;, &#125; &#125;,params.row.name) if (params.row.$isEdit)&#123; return dom1 &#125; else&#123;return dom2&#125; &#125; &#125;, &#123; title: &#39;Age&#39;, key: &#39;age&#39;, render: (h, params) &#x3D;&gt; &#123; let create &#x3D; this.$createElement let dom3 &#x3D; create(&#39;Input&#39;, &#123; ref: params.row[Object.keys(params.row)[Object.keys(params.row).length-2]]+&#39;_age&#39;, props: &#123; type: &quot;text&quot;, value: params.row.age, placeholder:&#39;请输入年龄&#39; &#125;, on: &#123; &quot;on-blur&quot;: event &#x3D;&gt; &#123; params.row.age &#x3D; event.target.value; this.data3[params.index].age &#x3D; event.target.value; this.$set(params.row, &#39;$isEdit&#39;, false); &#125;, &quot;on-enter&quot;:event&#x3D;&gt;&#123; params.row.name &#x3D; event.target.value; this.data3[params.index].age &#x3D; event.target.value; this.$set(params.row, &#39;$isEdit&#39;, false); &#125; &#125; &#125;) let dom4 &#x3D; create(&#39;div&#39;, &#123; on: &#123; click: (e) &#x3D;&gt; &#123; this.$set(params.row, &#39;$isEdit&#39;, true); this.$nextTick( () &#x3D;&gt;&#123; this.$refs[params.row[Object.keys(params.row)[Object.keys(params.row).length-2]]+&#39;_age&#39;].focus() &#125; ) &#125;, &#125; &#125;,params.row.age) if (params.row.$isEdit)&#123; return dom3 &#125; else&#123;return dom4&#125; &#125; &#125;, &#123; title: &#39;Age&#39;, key: &#39;age&#39; &#125; ], data3: [ &#123; name: &#39;王小明&#39;, age: 18, address:&#39;123&#39;, $isEdit: false &#125;, &#123; name: &#39;张小刚&#39;, age: 25, address:&#39;123&#39;, $isEdit: false &#125;, &#123; name: &#39;李小红&#39;, age: 30, address:&#39;123&#39;, $isEdit: false &#125;, &#123; name: &#39;周小伟&#39;, age: 26, $isEdit: false, address:&#39;123&#39; &#125; ] &#125; &#125;, methods: &#123; handleEdit (row) &#123; this.$set(row, &#39;$isEdit&#39;, true) &#125;, handleSave (row) &#123; this.$set(row, &#39;$isEdit&#39;, false) &#125; &#125; &#125; &lt;&#x2F;script&gt;","permalink":"https://codermino.github.io/2020/09/13/iview%E5%8F%AF%E7%BC%96%E8%BE%91%E8%A1%A8%E6%A0%BC/","photos":[]},{"tags":[{"name":"better-scroll的使用","slug":"better-scroll的使用","permalink":"https://codermino.github.io/tags/better-scroll%E7%9A%84%E4%BD%BF%E7%94%A8/"}],"title":"better-scroll的使用","date":"2020/09/06","text":"滚动原理 绿色部分为 wrapper，也就是父容器，它会有固定的高度。 黄色部分为 content，它是父容器的第一个子元素，它的高度会随着内容的大小而撑高。 那么，当 content 的高度不超过父容器的高度，是不能滚动的，而它一旦超过了父容器的高度， 我们就可以滚动内容区了。横向滚动的原理一致就是将固定高度改为固定宽度。（这里就不啰嗦了） 纵向滚动&lt;template&gt; &lt;div class&#x3D;&quot;wrapper&quot; ref&#x3D;&quot;wrapper&quot;&gt; &lt;ul&gt; &lt;li v-for&#x3D;&quot;item in 8&quot;&gt;&#123;&#123;item&#125;&#125;&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; import BScroll from &#39;better-scroll&#39;; export default &#123; mounted() &#123; this.$nextTick(() &#x3D;&gt; &#123; this.scroll &#x3D; new BScroll(this.$refs.wrapper); &#125;); &#125; &#125;; &lt;&#x2F;script&gt; &lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt; .wrapper&#123; overflow:hidden; height:100vh; &#125; ul li&#123; height:400px; &#125; &lt;&#x2F;style&gt; 这是一个Vue BetterScroll纵向滚动demo,这里需要注意的有两点。 只能有一层父级div，也就是容器 父级div要设置溢出隐藏，并且固定高度 横向滚动横向滚动，相比纵向滚动需要动态的去获取滚动区的宽度，直接上代码。 &lt;template&gt; &lt;div class&#x3D;&quot;tab&quot; ref&#x3D;&quot;tab&quot;&gt; &lt;ul class&#x3D;&quot;tab_content&quot; ref&#x3D;&quot;tabWrapper&quot;&gt; &lt;li class&#x3D;&quot;tab_item&quot; v-for&#x3D;&quot;item in itemList&quot; ref&#x3D;&quot;tabitem&quot;&gt; &#123;&#123;item.title&#125;&#125; &lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; import BScroll from &#39;better-scroll&#39;; export default &#123; data() &#123; return&#123; itemList:[ &#123; &#39;title&#39;:&#39;关注&#39; &#125;, &#123; &#39;title&#39;:&#39;推荐&#39; &#125;, &#123; &#39;title&#39;:&#39;深圳&#39; &#125;, &#123; &#39;title&#39;:&#39;视频&#39; &#125;, &#123; &#39;title&#39;:&#39;音乐&#39; &#125;, &#123; &#39;title&#39;:&#39;热点&#39; &#125;, &#123; &#39;title&#39;:&#39;新时代&#39; &#125;, &#123; &#39;title&#39;:&#39;娱乐&#39; &#125;, &#123; &#39;title&#39;:&#39;头条号&#39; &#125;, &#123; &#39;title&#39;:&#39;问答&#39; &#125;, &#123; &#39;title&#39;:&#39;图片&#39; &#125;, &#123; &#39;title&#39;:&#39;科技&#39; &#125;, &#123; &#39;title&#39;:&#39;体育&#39; &#125;, &#123; &#39;title&#39;:&#39;财经&#39; &#125;, &#123; &#39;title&#39;:&#39;军事&#39; &#125;, &#123; &#39;title&#39;:&#39;国际&#39; &#125; ] &#125; &#125;, created() &#123; this.$nextTick(() &#x3D;&gt; &#123; this.InitTabScroll(); &#125;); &#125;, methods:&#123; InitTabScroll()&#123; let width&#x3D;0 for (let i &#x3D; 0; i &lt;this.itemList.length; i++) &#123; width+&#x3D;this.$refs.tabitem[0].getBoundingClientRect().width; &#x2F;&#x2F;getBoundingClientRect() 返回元素的大小及其相对于视口的位置 &#125; this.$refs.tabWrapper.style.width&#x3D;width+&#39;px&#39; this.$nextTick(()&#x3D;&gt;&#123; if (!this.scroll) &#123; this.scroll&#x3D;new BScroll(this.$refs.tab, &#123; startX:0, click:true, scrollX:true, scrollY:false, eventPassthrough:&#39;vertical&#39; &#125;); &#125;else&#123; this.scroll.refresh() &#125; &#125;); &#125; &#125; &#125;; &lt;&#x2F;script&gt; &lt;style lang&#x3D;&quot;scss&quot; scoped&gt; .tab&#123; width: 100vw; overflow: hidden; padding:5px; .tab_content&#123; line-height: 2rem; display: flex; .tab_item&#123; flex: 0 0 60px; width:60px; &#125; &#125; &#125; &lt;&#x2F;style&gt; 横向滚动需要注意。 只能有一层父级div，也就是容器 父容器要设置溢出隐藏并固定宽度 动态获取滚动区的宽度 无法滚动的原因一、 DOM层级关系 &lt;div class&#x3D;&quot;wrapper&quot;&gt; &lt;div class&#x3D;&quot;content&quot;&gt; content... &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; wrapper里面不能存在多个同级div，如果你这样写： &lt;div class&#x3D;&quot;classifyTitle&quot; ref&#x3D;&quot;wrapper&quot;&gt; &lt;div class&#x3D;&quot;&quot;&gt; ss &lt;&#x2F;div&gt; &lt;ul&gt; &lt;li v-for&#x3D;&quot;(item,index) in classifyData.products&quot;&gt; &lt;router-link :to&#x3D;&quot;&#123;name:&#39;详情&#39;&#125;&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;&#x2F;router-link&gt; &lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;&#x2F;div&gt; 那么ul中的元素将不能滚动 二、content是否被成功添加滚动相关style &lt;div class&#x3D;&quot;classifyTitle&quot; ref&#x3D;&quot;wrapper&quot;&gt; &lt;ul&gt; &lt;li v-for&#x3D;&quot;(item,index) in classifyData.products&quot;&gt; &lt;router-link :to&#x3D;&quot;&#123;name:&#39;详情&#39;&#125;&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;&#x2F;router-link&gt; &lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;&#x2F;div&gt; 审查元素可以看到：这样即添加成功的 三、wrapper 与 content 高度问题只有content的高度大于wrapper高度时候，才可以滚动。如何看？ this.$nextTick(() &#x3D;&gt; &#123; if (!this.scroll) &#123; this.scroll &#x3D; new BScroll(this.$refs.wrapper, &#123;&#125;) console.log(this.scroll) &#125; &#125;) F12就可以看到打印结果： 以上就是可以滚动的情况，wrapperHeight(616) &lt; scrollHeight(750)，hasVerticalScroll为true； 那如果这些数据不对，检查是否dom没有更新完就初始化BScroll了，要等dom更新完才能初始化 四、wrapper样式.wrapper元素上要给定位 position: absolute; left: 0; top: 0; overflow: hidden; 封装better-scroll&lt;template&gt; &lt;div ref&#x3D;&quot;wrapper&quot; :class&#x3D;&quot;&#123;wrapper:hasClass,wrapper2:!hasClass&#125;&quot;&gt; &lt;div class&#x3D;&quot;content&quot;&gt; &lt;slot&gt;&lt;&#x2F;slot&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; import BScroll from &#39;better-scroll&#39; export default &#123; name: &quot;Scroll&quot;, props:&#123; &#x2F;&#x2F; 当默认值是一个对象或者是数组的时候，default必须是一个函数 probeType:&#123; type:Number, default:0 &#125;, pullUpLoad:&#123; type:Boolean, default:false &#125;, hasClass:&#123; type:Boolean, default:false &#125; &#125;, data()&#123; return&#123; scroll:null &#125; &#125;, mounted() &#123; this.$nextTick(()&#x3D;&gt;&#123; this.scroll&#x3D;new BScroll(this.$refs.wrapper,&#123; click:true, probeType:this.probeType, pullUpLoad:this.pullUpLoad &#125;); &#x2F;&#x2F; console.log(this.scroll); &#x2F;&#x2F; new BScroll().on() &#x2F;&#x2F; 监听滚动事件 if(this.probeType&#x3D;&#x3D;&#x3D;2||this.probeType&#x3D;&#x3D;&#x3D;3)&#123; this.scroll.on(&#39;scroll&#39;,(position)&#x3D;&gt;&#123; &#x2F;&#x2F; console.log(position); &#x2F;&#x2F; 将scroll滚动的位置传递出去，因为真正使用的地方不是在这个组件中使用 this.$emit(&#39;scroll&#39;,position); &#125;); &#125; &#x2F;&#x2F; 监听上拉事件 if(this.pullUpLoad)&#123; this.scroll.on(&#39;pullingUp&#39;,()&#x3D;&gt;&#123; &#x2F;&#x2F; console.log(&#39;上拉&#39;); this.$emit(&#39;pullingUp&#39;); &#125;) &#125; &#125;) &#125;, methods:&#123; scrollTo(x,y,time&#x3D;300)&#123; this.scroll&amp;&amp;this.scroll.scrollTo(x,y,time); &#125;, finishPullUp()&#123; this.scroll&amp;&amp;this.scroll.finishPullUp(); &#125;, refresh()&#123; &#x2F;&#x2F; console.log(&#39;图片加载&#39;); this.scroll&amp;&amp;this.scroll.refresh(); &#125;, getScrollY()&#123; &#x2F;&#x2F; return this.scroll&amp;&amp;this.scroll.y; return this.scroll?this.scroll.y:0; &#125; &#125; &#125; &lt;&#x2F;script&gt; &#x2F;&#x2F;一定要给wrapper一个滚动区域的高度并且overflow:hidden &lt;style scoped lang&#x3D;&quot;scss&quot;&gt; .wrapper&#123; width: 100%; overflow: hidden; margin-top: 44px+35px; height: calc(100vh - 44px - 40px); &#125; .wrapper2&#123; width: 100%; overflow: hidden; margin-top: 44px; height: calc(100vh - 44px); &#125; &lt;&#x2F;style&gt; Demo1&lt;!-- 内容区域--&gt; &lt;scroll ref&#x3D;&quot;scroll&quot; :probe-type&#x3D;&quot;3&quot; :pull-up-load&#x3D;&quot;true&quot; @scroll&#x3D;&quot;contentScroll&quot; @pullingUp&#x3D;&quot;loadMore&quot; :hasClass&#x3D;&quot;true&quot;&gt; &lt;content-com :datalist&#x3D;&quot;datalist&quot;&gt;&lt;&#x2F;content-com&gt; &lt;&#x2F;scroll&gt; &#x2F;&#x2F;相关methods loadMore()&#123; debounce(() &#x3D;&gt; &#123; this.addData(); &#125;,1000); &#125;, addData() &#123; this.showMask &#x3D; true; this.urlTime -&#x3D; 86400; this.getData(); this.$nextTick(()&#x3D;&gt;&#123; setTimeout(()&#x3D;&gt;&#123; this.showMask &#x3D; false; &#125;,2000); this.$refs.scroll.finishPullUp(); &#125;) &#125;, contentScroll(position)&#123; &#x2F;&#x2F; 1.判断backTop是否显示 this.isShowBackTop&#x3D; (-position.y)&gt;1000; &#125;, &#x2F;&#x2F;contentCom组件内容 &lt;template&gt; &lt;div class&#x3D;&quot;container&quot;&gt; &lt;div class&#x3D;&quot;u-f-ajc&quot; v-for&#x3D;&quot;(item,index) in datalist&quot; :key&#x3D;&quot;index&quot; style&#x3D;&quot;border-bottom: 1px solid #ccc;padding: 5px 0&quot;&gt; &lt;div class&#x3D;&quot;left u-f2&quot;&gt; &lt;img class&#x3D;&quot;u-f-noshrink&quot; :src&#x3D;&quot;item.thumb&quot; alt&#x3D;&quot;&quot; style&#x3D;&quot;height: 50px;width: 100%;margin-left: 3px&quot;&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;right&quot; style&#x3D;&quot;margin-left: 5px;flex: 7;&quot; @click&#x3D;&quot;toDetail(item)&quot;&gt; &lt;div class&#x3D;&quot;right-top&quot; style&#x3D;&quot;padding-bottom: 10px;font-weight: 700;font-size: 17px;&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;right-bottom u-f u-f-liangduan&quot; style&#x3D;&quot;font-size: 13px;color: #bcbcbc;&quot;&gt; &lt;div class&#x3D;&quot;time u-f-ajc&quot;&gt; &#123;&#123;item.ctime|timeFormat&#125;&#125; &lt;div v-limit&#x3D;&quot;3&quot; v-for&#x3D;&quot;(item2,index2) in item.labels_show&quot; :key&#x3D;&quot;index2&quot; style&#x3D;&quot;padding-left: 3px&quot;&gt;&#123;&#123;item2&#125;&#125;&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;icon&quot; style&#x3D;&quot;font-size: 13px;color: #bcbcbc;padding-right: 10px&quot;&gt; &gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default &#123; name: &quot;contentCom&quot;, props: &#123; datalist: &#123; type: Array, default: [] &#125;, &#125;, methods: &#123; toDetail(item) &#123; this.$router.push(&#123; name: &#39;detail&#39;, params: &#123; item &#125; &#125;) &#125; &#125;, &#125; &lt;&#x2F;script&gt; Demo2&#x2F;&#x2F;滚动内容区域 &lt;scroll ref&#x3D;&quot;scroll&quot; :probe-type&#x3D;&quot;3&quot; :pull-up-load&#x3D;&quot;true&quot;&gt; &lt;div class&#x3D;&quot;container&quot; style&#x3D;&quot;padding: 0 3%;&quot;&gt; &lt;div class&#x3D;&quot;content&quot; v-if&#x3D;&quot;hot_list.length&amp;&amp;cmntlist.length&quot;&gt; &lt;detail-content :item&#x3D;&quot;item&quot;&gt;&lt;&#x2F;detail-content&gt; &lt;&#x2F;div&gt; &lt;comment :cmntlist&#x3D;&quot;hot_list&quot; title&#x3D;&quot;最热评论&quot; v-if&#x3D;&quot;hot_list.length&amp;&amp;cmntlist.length&quot;&gt;&lt;&#x2F;comment&gt; &lt;comment :cmntlist&#x3D;&quot;cmntlist&quot; title&#x3D;&quot;最新评论&quot; v-if&#x3D;&quot;hot_list.length&amp;&amp;cmntlist.length&quot;&gt;&lt;&#x2F;comment&gt; &lt;&#x2F;div&gt; &lt;&#x2F;scroll&gt; &#x2F;&#x2F;在组件中有图片，如果图片没有加载完，那么图片加载之后将会有部分内容区域无法滚动 &lt;template v-if&#x3D;&quot;item.thumbs&quot;&gt; &lt;img :src&#x3D;&quot;item.thumbs[0]&quot; alt&#x3D;&quot;&quot; class&#x3D;&quot;u-f-jc&quot; style&#x3D;&quot;width: 100%;padding-bottom: 10px&quot; @load&#x3D;&quot;imgLoad&quot;&gt; &lt;&#x2F;template&gt; &#x2F;&#x2F;添加@load方法 methods: &#123; imgLoad() &#123; this.$parent.scroll.refresh(); &#125; &#125;,","permalink":"https://codermino.github.io/2020/09/06/better-scroll%E7%9A%84%E4%BD%BF%E7%94%A8/","photos":[]},{"tags":[{"name":"vue自定义属性","slug":"vue自定义属性","permalink":"https://codermino.github.io/tags/vue%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7/"}],"title":"vue自定义属性","date":"2020/09/04","text":"标签元素&lt;div id&#x3D;&quot;test&quot;&gt; &lt;button :data-num&#x3D;&quot;num&quot; ref&#x3D;&quot;dataNum&quot; @click&#x3D;&quot;getsum($event)&quot;&gt;点我&lt;&#x2F;button&gt; &lt;&#x2F;div&gt; js部分data()&#123; return&#123; num : 100 &#125; &#125;, methods: &#123; &#x2F;&#x2F;获取 getsum: function(e) &#123; console.log(e); &#x2F;&#x2F; 自定义属性绑定的元素 console.log(e.target); &#x2F;&#x2F; 自定义元素绑定的元素的dataset console.log(e.target.dataset); console.log(e.target.dataset.num); &#x2F;&#x2F;方法一：操作DOM console.log(this.$refs.dataNum.dataset.num); &#x2F;&#x2F;100 &#x2F;&#x2F;方法二：通过e.target.getAttribute console.log(e.target.getAttribute(&#39;data-num&#39;));&#x2F;&#x2F;100 &#125; &#125;","permalink":"https://codermino.github.io/2020/09/04/vue%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7/","photos":[]},{"tags":[{"name":"vue自定义指令","slug":"vue自定义指令","permalink":"https://codermino.github.io/tags/vue%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/"}],"title":"vue自定义指令","date":"2020/09/03","text":"注册自定义指令Vue自定义指令和组件一样存在着全局注册和局部注册两种方式。 先来看看注册全局指令的方式，通过 Vue.directive( id, [definition] ) 方式注册全局指令， 第一个参数为自定义指令名称（指令名称不需要加 v- 前缀，默认是自动加上前缀的，使用指令的时候一定要加上前缀）， 第二个参数可以是对象数据，也可以是一个指令函数。 &lt;div id&#x3D;&quot;app&quot; class&#x3D;&quot;demo&quot;&gt; &lt;!-- 全局注册 --&gt; &lt;input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;我是全局自定义指令&quot; v-focus&gt; &lt;&#x2F;div&gt; &lt;script&gt; Vue.directive(&quot;focus&quot;, &#123; inserted: function(el)&#123; el.focus(); &#125; &#125;) new Vue(&#123; el: &quot;#app&quot; &#125;) &lt;&#x2F;script&gt; 这个简单案例当中，我们通过注册一个 v-focus 指令，实现了在页面加载完成之后自动让输入框获取到焦点的小功能。其中 inserted 是自定义指令的钩子函数，后面的内容会详细讲解。 全局注册好了，那么再来看看如何注册局部自定义指令，通过在Vue实例中添加 directives 对象数据注册局部自定义指令。 &lt;div id&#x3D;&quot;app&quot; class&#x3D;&quot;demo&quot;&gt; &lt;!-- 局部注册 --&gt; &lt;input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;我是局部自定义指令&quot; v-focus2&gt; &lt;&#x2F;div&gt; &lt;script&gt; new Vue(&#123; el: &quot;#app&quot;, directives: &#123; focus2: &#123; inserted: function(el)&#123; el.focus(); &#125; &#125; &#125; &#125;) &lt;&#x2F;script&gt; 钩子函数一个指令定义对象可以提供如下几个钩子函数 (均为可选)： bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置 inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。 update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变， 也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 。 componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。 unbind：只调用一次，指令与元素解绑时调用。 假设这样的看一个场景：当你在阅览某网站的图片时，可能会由于图片资源比较大而加载缓慢，需要消耗一小段时间来呈现到眼前，这个体验肯定是不太友好的（就像网站切换页面，有时候会加载资源比较慢，为了给用户较好的体验，一般都会先出一个正在加载的友好提示页面），所以这个案例的功能就是在图片资源还没加载出来时，先显示默认背景图，当图片资源真正加载出来了之后，再把真实图片放置到对应的位置上并显示出来。 &lt;div id&#x3D;&quot;app2&quot; class&#x3D;&quot;demo&quot;&gt; &lt;div v-for&#x3D;&quot;item in imageList&quot;&gt; &lt;img src&#x3D;&quot;..&#x2F;assets&#x2F;image&#x2F;bg.png&quot; alt&#x3D;&quot;默认图&quot; v-image&#x3D;&quot;item.url&quot;&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;script&gt; Vue.directive(&quot;image&quot;, &#123; inserted: function(el, binding) &#123; &#x2F;&#x2F;为了真实体现效果，用了延时操作 setTimeout(function()&#123; el.setAttribute(&quot;src&quot;, binding.value); &#125;, Math.random() * 1200) &#125; &#125;) new Vue(&#123; el: &quot;#app2&quot;, data: &#123; imageList: [ &#123; url: &quot;http:&#x2F;&#x2F;consumer-img.huawei.com&#x2F;content&#x2F;dam&#x2F;huawei-cbg-site&#x2F;greate-china&#x2F;cn&#x2F;mkt&#x2F;homepage&#x2F;section4&#x2F;home-s4-p10-plus.jpg&quot; &#125;, &#123; url: &quot;http:&#x2F;&#x2F;consumer-img.huawei.com&#x2F;content&#x2F;dam&#x2F;huawei-cbg-site&#x2F;greate-china&#x2F;cn&#x2F;mkt&#x2F;homepage&#x2F;section4&#x2F;home-s4-watch2-pro-banner.jpg&quot; &#125;, &#123; url: &quot;http:&#x2F;&#x2F;consumer-img.huawei.com&#x2F;content&#x2F;dam&#x2F;huawei-cbg-site&#x2F;en&#x2F;mkt&#x2F;homepage&#x2F;section4&#x2F;home-s4-matebook-x.jpg&quot; &#125; ] &#125; &#125;) &lt;&#x2F;script&gt; 钩子区别update 和 componentUpdated 共同点：组件更新都会调用，update在componentUpdated之前 不同点： update 组件更新前的状态 componentUpdated 组件更新后的状态 场景：点击事件，div的内容追加 ！； update(el, binding,vnode,oldVnode)&#123; console.log(el.innerHTML); &#x2F;&#x2F; &lt;div&gt;！&lt;&#x2F;div&gt; &#125; componentUpdated(el, binding,vnode,oldVnode)&#123; console.log(el.innerHTML); &#x2F;&#x2F; &#x2F;&#x2F;&lt;div&gt;！！&lt;&#x2F;div&gt; &#125; &#x2F;&#x2F; 注意： 区别是div里面的！数量 bind 和 inserted 共同点： dom插入都会调用，bind在inserted之前 不同点： bind 时父节点为 null inserted 时父节点存在。 bind是在dom树绘制前调用，inserted在dom树绘制后调用 bind: function (el) &#123; console.log(el.parentNode) &#x2F;&#x2F; null console.log(&#39;bind&#39;) &#125;, inserted: function (el) &#123; console.log(el.parentNode) &#x2F;&#x2F; &lt;div class&#x3D;&quot;directive-box&quot;&gt;...&lt;&#x2F;div&gt; console.log(&#39;inserted&#39;) &#125; Demo&lt;template&gt; &lt;div&gt; 首页 &lt;input v-for&#x3D;&quot;item in list&quot; :key&#x3D;&quot;item&quot; v-test&#x3D;&quot;item&quot; type&#x3D;&quot;text&quot;&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default &#123; name:&#39;demo&#39;, data() &#123; return &#123; list:[1,2] &#125; &#125;, mounted()&#123; setTimeout(()&#x3D;&gt;&#123; console.log(&#39;-----------------------------------splice的分割线------------------------------------------&#39;) this.list.splice(1,1) &#125;,2000) setTimeout(()&#x3D;&gt;&#123; console.log(&#39;----------------------------------------push的分割线---------------------------------------------&#39;) this.list.push(2) &#125;,3000) &#125;, directives:&#123; test:&#123; &#x2F;&#x2F; 只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 bind(el,bingding,vnode,oldVnode)&#123; console.log(&#39;bing&#39;,el,bingding,vnode,oldVnode) &#125;, &#x2F;&#x2F; inserted 被绑定元素插入父节点时调用（仅保证父节点存在，但不一定已被插入文档中） inserted(el,bingding,vnode,oldVnode)&#123; console.log(&#39;inserted&#39;,el,bingding,vnode,oldVnode) &#125;, &#x2F;&#x2F; update 所在组件的VNode更新时调用，但是可能发生在其子VNode更新之前。指令的值可能发生了改变，也可能没有。 update(el,bingding,vnode,oldVnode)&#123; console.log(&#39;update&#39;,el,bingding,vnode,oldVnode) &#125;, &#x2F;&#x2F; 指令所在组件的VNode及其子VNode全部更新后调用 componentUpdated(el,bingding,vnode,oldVnode)&#123; console.log(&#39;componentUpdated&#39;,el,bingding,vnode,oldVnode) &#125;, &#x2F;&#x2F; 只调用一次，指令与元素解绑时调用 unbind(el,bingding,vnode,oldVnode)&#123; console.log(&#39;unbind&#39;,el,bingding,vnode,oldVnode) &#125; &#125; &#125; &#125; &lt;&#x2F;script&gt; tip 注意： 自定义指令的钩子里面没有vue实例，this指向undefined； 总结1 初始化先执行bing钩子函数，被绑定元素插入父节点时调用inserted钩子函数2 节点移除后会执行update和componentUpdate钩子函数，然后执行解绑的钩子函数unbind3 有节点插入会先执行节点的更新和节点更新完毕的钩子函数，然后执行绑定和inserted 钩子函数","permalink":"https://codermino.github.io/2020/09/03/vue%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/","photos":[]},{"tags":[{"name":"vue修改网站标题title的三种方法","slug":"vue修改网站标题title的三种方法","permalink":"https://codermino.github.io/tags/vue%E4%BF%AE%E6%94%B9%E7%BD%91%E7%AB%99%E6%A0%87%E9%A2%98title%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/"}],"title":"vue修改网站标题title的三种方法","date":"2020/09/03","text":"方法一调用Vue.directive() main.js里面添加一个全局指令Vue.directive(&#39;title&#39;, &#123; inserted: function (el, binding) &#123; &#x2F;&#x2F; el是自定义属性绑定的元素 document.title &#x3D; el.dataset.title &#125; &#125;) 调用的组件里面，随便找一个div加入，v-title data-title=”你的标题”&lt;template&gt; &lt;div v-title data-title&#x3D;&quot;标题&quot;&gt; ...... &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; 方法二利用路由的导航守卫beforeEach在每次页面跳转前更改对应的title router中给每个路由加上meta属性&#123; path: &#39;&#x2F;login&#39;, name: &#39;login&#39;, component(resolve) &#123; require([&#39;.&#x2F;views&#x2F;login.vue&#39;], resolve) &#125;, meta: &#123; title: &#39;登录页&#39;, keepAlive: true, &#x2F;&#x2F; 需要被缓存 &#125; &#125; 在main.js里面加上导航守卫router.beforeEach((to, from, next) &#x3D;&gt; &#123; &#x2F;&#x2F;路由发生改变时,触发 window.document.title &#x3D; to.meta.title &#x3D;&#x3D; undefined ? &#39;默认标题&#39; : to.meta.title if (to.meta.requireAuth) &#123; let token &#x3D; Cookies.get(&#39;access_token&#39;); let anonymous &#x3D; Cookies.get(&#39;user_name&#39;); if (token) &#123; next(&#123; path: &#39;&#x2F;login&#39;, query: &#123; redirect: to.fullPath &#125; &#125;) &#125; &#125; next(); &#125;) 方法三使用插件 安装插件 npm install vue-wechat-title –save 引入插件，main.js中importimport VueWechatTitle from &#39;vue-wechat-title&#39; Vue.use(VueWechatTitle) 路由配置文件router.js里面配置的页面标题routers: [&#123; path: &#39;&#x2F;&#39;, name: &#39;index&#39;, component: Index, meta: &#123; title: &#39;title&#39; &#125; &#125;] app.vue里面添加指令v-wechat-title即可 &lt;!-- 任意元素中加 v-wechat-title 指令 建议将标题放在 route 对应meta对象的定义中 --&gt;&lt;div v-wechat-title&#x3D;&quot;$route.meta.title&quot;&gt;&lt;&#x2F;div&gt; &lt;!--或者--&gt; &lt;router-view v-wechat-title&#x3D;&quot;$route.meta.title&quot;&gt;&lt;&#x2F;router-view&gt; &#x2F;&#x2F;来自官方npm页面","permalink":"https://codermino.github.io/2020/09/03/vue%E4%BF%AE%E6%94%B9%E7%BD%91%E7%AB%99%E6%A0%87%E9%A2%98title%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/","photos":[]},{"tags":[{"name":"keepalive的使用","slug":"keepalive的使用","permalink":"https://codermino.github.io/tags/keepalive%E7%9A%84%E4%BD%BF%E7%94%A8/"}],"title":"keepalive的使用","date":"2020/09/03","text":"Vue中keep-alive的深入理解和使用什么是keep-alive?在平常开发中，有部分组件没有必要多次初始化，这时，我们需要将组件进行持久化，使组件的状态维持不变， 在下一次展示时，也不会进行重新初始化组件。 也就是说，kee-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染 。 也就是所谓的组件缓存 基本用法&#x2F;&#x2F;被keep-alive包含的组件会被缓存 &lt;keep-alive&gt; &lt;component &#x2F;&gt; &lt;&#x2F;keep-alive&gt; 被keep-alive包含的组件不会被再次初始化，也就意味着不会重走生命周期函数但是有时候是希望我们缓存的组件可以能够再次进行渲染，这时Vue为我们解决了这个问题被包含在 keep-alive 中创建的组件，会多出两个生命周期的钩子: activated 与 deactivated： activated 当 keep-alive 包含的组件再次渲染的时候触发 deactivated 当 keep-alive 包含的组件销毁的时候触发 keep-alive是一个抽象的组件，缓存的组件不会被mounted,为此提供activated和deactivated钩子函数在2.1.0 版本后keep-alive新加入了两个属性: include(包含的组件缓存生效) 与exclude(排除的组件不缓存，优先级大于include) 。 参数理解keep-alive可以接收3个属性做为参数进行匹配对应的组件进行缓存: include包含的组件(可以为字符串，数组，以及正则表达式,只有匹配的组件会被缓存) exclude排除的组件(以为字符串，数组，以及正则表达式,任何匹配的组件都不会被缓存) max缓存组件的最大值(类型为字符或者数字,可以控制缓存组件的个数) 注：当使用正则表达式或者数组时，一定要使用v-bind代码示例: &#x2F;&#x2F; 只缓存组件name为a或者b的组件 &lt;keep-alive include&#x3D;&quot;a,b&quot;&gt; &lt;component &#x2F;&gt; &lt;&#x2F;keep-alive&gt; &#x2F;&#x2F; 组件name为c的组件不缓存(可以保留它的状态或避免重新渲染) &lt;keep-alive exclude&#x3D;&quot;c&quot;&gt; &lt;component &#x2F;&gt; &lt;&#x2F;keep-alive&gt; &#x2F;&#x2F; 如果同时使用include,exclude,那么exclude优先于include， 下面的例子只缓存a组件 &lt;keep-alive include&#x3D;&quot;a,b&quot; exclude&#x3D;&quot;b&quot;&gt; &lt;component &#x2F;&gt; &lt;&#x2F;keep-alive&gt; &#x2F;&#x2F; 如果缓存的组件超过了max设定的值5，那么将删除第一个缓存的组件 &lt;keep-alive exclude&#x3D;&quot;c&quot; max&#x3D;&quot;5&quot;&gt; &lt;component &#x2F;&gt; &lt;&#x2F;keep-alive&gt; 配合router使用router-view也是一个组件，如果直接被包在keepalive里面，那么所有路径匹配到的视图组件都会被缓存，如下： &lt;keep-alive&gt; &lt;router-view&gt; &lt;!-- 所有路径匹配到的视图组件都会被缓存！ --&gt; &lt;&#x2F;router-view&gt; &lt;&#x2F;keep-alive&gt; 如果只想要router-view里面的某个组件被缓存，怎么办？ 使用 include/exclude 使用 meta 属性 1.使用 include (exclude例子类似) &#x2F;&#x2F;只有路径匹配到的 name 为 a 组件会被缓存 &lt;keep-alive include&#x3D;&quot;a&quot;&gt; &lt;router-view&gt;&lt;&#x2F;router-view&gt; &lt;&#x2F;keep-alive&gt; 2.使用 meta 属性 &#x2F;&#x2F; routes 配置 export default [ &#123; path: &#39;&#x2F;&#39;, name: &#39;home&#39;, component: Home, meta: &#123; keepAlive: true &#x2F;&#x2F; 需要被缓存 &#125; &#125;, &#123; path: &#39;&#x2F;profile&#39;, name: &#39;profile&#39;, component: Profile, meta: &#123; keepAlive: false &#x2F;&#x2F; 不需要被缓存 &#125; &#125; ] &lt;keep-alive&gt; &lt;router-view v-if&#x3D;&quot;$route.meta.keepAlive&quot;&gt; &lt;!-- 这里是会被缓存的视图组件，比如 Home！ --&gt; &lt;&#x2F;router-view&gt; &lt;&#x2F;keep-alive&gt; &lt;router-view v-if&#x3D;&quot;!$route.meta.keepAlive&quot;&gt; &lt;!-- 这里是不会被缓存的视图组件，比如 Profile！ --&gt; &lt;&#x2F;router-view&gt; 防坑指南 keep-alive 先匹配被包含组件的 name 字段，如果 name 不可用，则匹配当前组件 components 配置中的注册名称。 keep-alive 不会在函数式组件中正常工作，因为它们没有缓存实例。 当匹配条件同时在 include 与 exclude 存在时，以 exclude 优先级最高(当前vue 2.4.2 version)。比如：包含于排除同时匹配到了组件A，那组件A不会被缓存。 包含在 keep-alive 中，但符合 exclude ，不会调用activated和 deactivated。","permalink":"https://codermino.github.io/2020/09/03/keepalive%E7%9A%84%E4%BD%BF%E7%94%A8/","photos":[]},{"tags":[{"name":"js传递多个参数","slug":"js传递多个参数","permalink":"https://codermino.github.io/tags/js%E4%BC%A0%E9%80%92%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0/"}],"title":"js传递多个参数","date":"2020/08/25","text":"在es6之前，一半使用arguments作为不定数参数传输的参数获取途径function abc() &#123; let len = arguments.length; for(let j = 0; j &lt;len ; j++) &#123; console.log(arguments[i]); &#125; &#125; abc(1,2,3); 在es6中可以用…来命名不定数参数名，这样比之前版本比可以起一个更有意义的参数名需要注意的是不定参数只能是最后一个参数，且一个函数定义中只能有一个不定参数 function abc1(...vars) &#123; let len = vars.length; for(let j = 0; j &lt;len ; j++) &#123; console.log(vars[i]); &#125; &#125; function abc2(name,...vars) &#123; let len = vars.length; for(let j = 0; j &lt;len ; j++) &#123; console.log(name); console.log(vars[i]); &#125; &#125; abc1(1,2,3); abc2('zhangsan',1,2,3,4);","permalink":"https://codermino.github.io/2020/08/25/js%E4%BC%A0%E9%80%92%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0/","photos":[]},{"tags":[{"name":"Math.max.apply和Math.max的区别","slug":"Math-max-apply和Math-max的区别","permalink":"https://codermino.github.io/tags/Math-max-apply%E5%92%8CMath-max%E7%9A%84%E5%8C%BA%E5%88%AB/"}],"title":"Math.max.apply和Math.max的区别","date":"2020/08/24","text":"Javascript中的Math.max方法可以求出给定参数中最大的数。Math.max('1','2','3.1','3.2') //3.2 Math.min(1,0,-1) //-1 但如果是数组，就不能这样调用了。此时就用到了apply方法： apply 方法 (Function) (JavaScript) //调用函数，并用指定对象替换函数的 this 值，同时用指定数组替换函数的参数。 apply([thisObj[,argArray]]) //thisObj //可选。 要用作 this 对象的对象。 //argArray //可选。 要传递到函数的一组参数。 巧妙地使数组也可以调用Math.max和Math.min。 Math.max.apply(null, ['1','2','3.1','3.2']) // 3.2 Math.min.apply(null, [1,0,-1]) // -1 Math.min.apply(Math, [1,0,-1])","permalink":"https://codermino.github.io/2020/08/24/Math-max-apply%E5%92%8CMath-max%E7%9A%84%E5%8C%BA%E5%88%AB/","photos":[]},{"tags":[{"name":"created和mounted中请求数据区别","slug":"created和mounted中请求数据区别","permalink":"https://codermino.github.io/tags/created%E5%92%8Cmounted%E4%B8%AD%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%88%AB/"}],"title":"created和mounted中请求数据区别","date":"2020/08/24","text":"JavaScript 的 EventLoop 。 vue 生命周期钩子函数中的异步操作会放在事件队列中，也就是说不会在这个钩子函数中执行。 所以在 created 和 mounted 中请求异步数据是一样的，两者都不会立即进行数据更新，所以不会导致虚拟 DOM 的重载， 更不会影响到真实视图。 vue 生命周期钩子函数中异步数据的赋值，是不会在该钩子函数中执行的，而是在一遍流程结束后，才会处理其中的异步操作。 所以本阶段不会触发数据更新，也不会触发虚拟 DOM 重新载入，更不存在找不到 DOM 元素渲染。 例子const app = new Vue(&#123; el: '#app', data: &#123; num: 0 &#125;, async created() &#123; console.log('created') this.num = await this.getData('created') console.log('获取异步数据结束') console.timeEnd('created获取异步数据完成时长') &#125;, beforeMount() &#123; console.log('beforeMounted') &#125;, async mounted() &#123; console.log('mounted') this.num = await this.getData('mounted') console.log('获取异步数据结束') console.timeEnd('mounted获取异步数据完成时长') &#125;, updated() &#123; console.log('updated') &#125;, methods: &#123; // 模拟异步请求 getData(lifecycle) &#123; console.log(`$&#123;lifecycle&#125;开始获取异步数据`) if (lifecycle === 'created') &#123; console.time('created获取异步数据完成时长') &#125; else &#123; console.time('mounted获取异步数据完成时长') &#125; const genRandomNum = (min, max) =&gt; (Math.random() * (max - min + 1) | 0) + min return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve(genRandomNum(100, 3000)) &#125;, 2000) &#125;) &#125; &#125;, &#125;) 以上代码运行结果如下图所示，可以看到，在 created 和 mounted 中请求异步数据， 都不会立即触发数据的更新，并且在这两个生命周期中获取异步数据更新的时长可以说是几乎一致的。 vue 生命周期的钩子函数中的异步操作，都会在一遍流程走完之后，才会进行数据赋值操作，触发 update ， 此外 DOM 的更新也是异步的，监听数据变化时，启动一个队列，进行视图更新。 在 created 或 mounted 钩子函数中请求数据都是可以的。 在 vue ssr 中，vue 的生命周期中没有 mounted 这个钩子函数，所以 ssr 中无法在 mounted 获取异步数据。 宏任务之后是微任务，微任务过后是布局渲染，此时再执行请求后的回调并完成赋值。created 和 mounted 的区别就出现了，这样相比，created 中请求比 mounted 更快一点。 也要考虑业务场景，需要 DOM 触发的请求，放在 created 中去，怎么放都请求不到。","permalink":"https://codermino.github.io/2020/08/24/created%E5%92%8Cmounted%E4%B8%AD%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%88%AB/","photos":[]},{"tags":[{"name":"localstorage和sessionstorage区别","slug":"localstorage和sessionstorage区别","permalink":"https://codermino.github.io/tags/localstorage%E5%92%8Csessionstorage%E5%8C%BA%E5%88%AB/"}],"title":"localstorage和sessionstorage区别","date":"2020/08/24","text":"概述localStorage和sessionStorage一样都是用来存储客户端临时信息的对象。 他们均只能存储字符串类型的对象（虽然规范中可以存储其他原生类型的对象，但是目前为止没有浏览器对其进行实现）。 localStorage生命周期是永久，这意味着除非用户主动在浏览器上清除localStorage信息，否则这些信息将永远存在。 sessionStorage生命周期为当前窗口或标签页，一旦窗口或标签页被永久关闭了，那么所有通过sessionStorage存储的数据也就被清空了。 sessionStoragesessionStorage 是HTML5新增的一个会话存储对象,用于临时保存同一窗口(或标签页)的数据, 在关闭窗口或标签页之后将会删除这些数据。 使用 setItem 存储 value用途：将 value 存储到 key 字段 用法：.setItem( key, value) 代码示例： sessionStorage.setItem(\"key\", \"value\"); localStorage.setItem(\"site\", \"js8.in\"); getItem 获取 value 用途：获取指定 key 本地存储的值 用法： .getItem(key) 代码示例： var value = sessionStorage.getItem(\"key\"); var site = localStorage.getItem(\"site\"); //滚动时保存滚动位置 $(window).scroll(function()&#123; if($(document).scrollTop()!=0)&#123; sessionStorage.setItem(\"offsetTop\", $(window).scrollTop());//保存滚动位置 &#125; &#125;); //onload时，取出并滚动到上次保存位置 window.onload = function() &#123; var _offset = sessionStorage.getItem(\"offsetTop\"); $(document).scrollTop(offsetTop); &#125;; localStorage不同浏览器无法共享localStorage或sessionStorage中的信息。 相同浏览器的不同页面间可以共享相同的 localStorage（页面属于相同域名和端口）， 但是不同页面或标签页间无法共享sessionStorage的信息。这里需要注意的是，页面及标 签页仅指顶级窗口， 如果一个标签页包含多个iframe标签且他们属于同源页面，那么他们之间是可以共享sessionStorage的。 同源的判断规则：www.test.com www.test.com （不同源，因为协议不同） my.test.com（不同源，因为主机名不同） www.test.com:8080（不同源，因为端口不同） localStorage和sessionStorage使用时使用相同的API： localStorage.setItem(\"key\",\"value\"); //以“key”为名称存储一个值“value” localStorage.getItem(\"key\"); //获取名称为“key”的值 枚举localStorage的方法： for(var i=0;i&lt;localStorage.length;i++)&#123; var name = localStorage.key(i); var value = localStorage.getItem(name); &#125; 删除localStorage中存储信息的方法： localStorage.removeItem(\"key\"); //删除名称为“key”的信息。 localStorage.clear(); //清空localStorage中所有信息 例如： localStorage.key = JSON.stringify(&#123;value1:\"value1\"&#125;); localStorage.key.value1='a'; // 无效 这里是无法对实际存储的值产生作用的，下面的写法也不可以： localStorage.getItem(\"key\").value1=\"a\"; localStorage 中的键值对总是以字符串的形式存储。这意味着数值类型、复杂数据类型会自动转化为字符串类型。","permalink":"https://codermino.github.io/2020/08/24/localstorage%E5%92%8Csessionstorage%E5%8C%BA%E5%88%AB/","photos":[]},{"tags":[{"name":"客户端渲染和服务端渲染","slug":"客户端渲染和服务端渲染","permalink":"https://codermino.github.io/tags/%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93/"}],"title":"客户端渲染和服务端渲染","date":"2020/08/21","text":"服务端渲染 vs 客户端渲染服务端渲染服务端在返回 html 之前，在特定的区域，符号里用数据填充，再给客户端，客户端只负责解析 HTML 。 服务端渲染也被称为 fat-server, thin-client 模式 客户端渲染html 仅仅作为静态文件，客户端端在请求时， 服务端不做任何处理，直接以原文件的形式返回给客户端客户端， 然后根据 html 上的 JavaScript，生成 DOM 插入 html。 客户端渲染也被称为 fat-client, thin-server 模式 异同 渲染本质一样，都是字符串拼接，将数据渲染进一些固定格式的html代码中形成最终的html展示在用户页面上。 拼接字符串必然引起性能的消耗。服务端渲染性能消耗在服务端，当用户量比较多时，缓存部分数据以避免过多数据重复渲染。客户端渲染，如当下火热的 spa 框架，Angular、React、Vue，在首次渲染时，大多是将原 html 中的数据标记（如 ）替换。客户端渲染较难的一点是数据更新以后，页面响应式更新时如何节省资源，直接 DOM 的读写，是很消耗性能的。Vue 2.0 + 有 Vnode，进行 diff 后，渲染到页面上。 利弊","permalink":"https://codermino.github.io/2020/08/21/%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93/","photos":[]},{"tags":[{"name":"win10快捷键","slug":"win10快捷键","permalink":"https://codermino.github.io/tags/win10%E5%BF%AB%E6%8D%B7%E9%94%AE/"}],"title":"win10快捷键","date":"2020/08/19","text":"切换窗口：Alt + Tab； 任务视图：Win + Tab(松开键盘界面不会消失)； 创建新的虚拟桌面：Win + Ctrl + D； 关闭当前虚拟桌面：Win + Ctrl + F4 切换虚拟桌面：Win + Ctrl + 左/右； Win快捷键组合快捷键大全(Win7/8以及Win10通用) Win + ←：最大化窗口到左侧的屏幕上 Win + →：最大化窗口到右侧的屏幕上 Win+ ↑：最大化窗口 Win+ ↓：最小化窗口 Win+ SHIFT +↑：垂直拉伸窗口，宽度不变 Win+ SHIFT +↓：垂直缩小窗口，宽度不变 Win+SHIFT+←：将活动窗口移至左侧显示器 Win+SHIFT+→：将活动窗口移至右侧显示器 Win+ Home：最小化所有窗口，第二次键击恢复窗口 Win + R 打开运行对话框 Win + I 快速打开Win10设置 Win+ P：演示设置 Win+ 数字键：打开或切换位于任务栏指定位置的程序 Win+B：光标移至通知区域 Win+Break：显示“系统属性”对话框 Win+D：显示桌面，第二次键击恢复桌面 Win+E：打开我的电脑 Win+G：循环切换侧边栏小工具 Win+L：锁住电脑或切换用户 Win+M：最小化所有窗口 Win+Shift+M：在桌面恢复所有最小化窗口 Win+T：切换任务栏上的程序 Win+Alt+回车：打开Windows媒体中心 Win+U：打开轻松访问中心 Win+F1：打开Windows帮助和支持 Win+N：插件新笔记(OneNote) Win+S：打开屏幕截图工具(OneNote) Win+Q：打开Lync，Windows 8搜索功能移除了该快捷键 Win+A：接受所有来电 (在microsoft Lync中) Win+X：拒绝来电(在microsoft Lync中)，如果Windows移动中心存在，该快捷键不起作用 Win+减号：缩小(放大镜) Win+加号：放大(放大镜) Win+Esc：关闭放大镜 Win+空格键：切换输入语言和键盘布局 Win键 + O 开启或关闭屏幕方向锁定 Win键 + V 在屏幕上的通知中循环切换 Win+，：临时查看桌面 Win+Shift+V：反向切换系统通知信息 Win+回车：打开“讲述人” Win+Shift+.：将应用移至左侧 Win+.：将应用移至右侧 Win+C：打开Charms栏(提供设置、设备、共享和搜索等选项) Win+K：打开连接显示屏 Win+H：打开共享栏 Win+W：打开“设置搜索”应用 Win+F：打开“文件搜索”应用 Win + Ctrl + F 搜索计算机(如果已连接到网络) Win+Z：打开“应用栏” Win+Tab：循环切换应用 Win+Shift+Tab：反向循环切换应用 Win+Ctrl+Tab：循环切换应用，切换时手动选择应用 Win+/：恢复默认输入法 Win+J：显示之前操作的应用 Win+X：快捷菜单 Win + 数字键 “启动锁定到任务栏中的由该数字所表示位置处的程序 Win + Pause 显示“系统属性”对话框 Win + Shift + 加号(+) 打开放大镜并放大桌面 Win + Shift + 减号(-) 打开放大镜并缩小桌面 Win + Shift + 向上键 将窗口拉伸到屏幕的顶部和底部 Win + Shift + 向左键或向右键 将窗口从一个监视器移动到另一个监视器 Win + Page Up 在多监视器设置中将开始屏幕移动至左监视器 Win + Page Down 在多监视器设置中将开始屏幕移动至右监视器 Win + ‘ 当您将应用程序向一侧对齐时，此热键将切换屏幕上应用程序的中心 Win + . 当您将应用程序向一侧对齐时，此热键会将拆分栏移动至右侧 Win + Shift + . 当您将应用程序向一侧对齐时，此热键会将拆分栏移动至左侧 Win+ Shift + 数字 启动锁定到任务栏中的由该数字所表示位置处的程序的新实例 Win+ Ctrl + 数字 切换到锁定到任务栏中的由该数字所表示位置处的程序的最后一个活动窗口 Win+Alt + 数字 打开锁定到任务栏中的由该数字所表示位置处的程序的跳转列表 (Jump List) Win键 +Ctrl + Tab 通过 Aero Flip 3-D 使用箭头键循环切换任务栏上的程序 Win键 +Ctrl + B 切换到在通知区域中显示消息的程序 Alt+F4 关闭当前窗口，如已经没有任何窗口，则弹出关机对话框 Alt+Enter 显示所选项的属性 Alt+空格键 为活动窗口打开快捷方式菜单 Alt+Esc 以项目打开的顺序循环切换项目 Alt+加下划线的字母 显示相应的菜单 Alt+加下划线的字母 执行菜单命令(或其他有下划线的命令)Alt+向上键在 Win资源管理器中查看上一级文 Alt+F 在文件目录窗口时按下：打开快捷菜单 Ctrl+Esc 打开“开始”菜单 Ctrl 加任意箭头键+空格键 选择窗口中或桌面上的多个单个项目 Ctrl+Alt+Tab 使用箭头键在打开的项目之间切换 Ctrl+鼠标滚轮 更改桌面上的图标大小 Ctrl+F4 关闭活动文档(在允许同时打开多个文档的程序中) Ctrl+Alt+Del 快速打开任务管理器 Ctrl+Shift+Esc 打开任务管理器 Ctrl+A 全选 Ctrl+C(或 Ctrl+Insert) 复制选择的项目 Ctrl+X 剪切选择的项目 Ctrl+V(或 Shift+Insert) 粘贴选择的项目 Ctrl+Z 撤消操作 Ctrl+Y 重新执行某项操作 Delete(或 Ctrl+D) 删除所选项目并将其移动到“回收站” Ctrl+向右键 将光标移动到下一个字词的起始处 Ctrl+向左键 将光标移动到上一个字词的起始处 Ctrl+向下键 将光标移动到下一个段落的起始处 Ctrl+向上键 将光标移动到上一个段落的起始处 Shift 加任意箭头键 在窗口中或桌面上选择多个项目，或者在文档中选择文本 Shift+Delete 不先将所选项目移动到“回收站”而直接将其删除 Shift+F10 显示选定项目的快捷菜单 插入 CD 时按住 Shift 阻止 CD 自动播放 左 Alt+Shift 在启用多种输入语言时切换输入语言 Ctrl+Shift 在启用多个键盘布局时切换键盘布局 右或左 Ctrl+Shift 更改从右到左阅读语言的文本阅读方向 F1 显示帮助 F2 重命名选定项目 F3 搜索文件或文件夹 F4 在 Win资源管理器中显示地址栏列表 F5(或 Ctrl+R) 刷新活动窗口 F6 在窗口中或桌面上循环切换屏幕元素 F10 激活活动程序中的菜单栏 F11 最大化或最小化活动窗口","permalink":"https://codermino.github.io/2020/08/19/win10%E5%BF%AB%E6%8D%B7%E9%94%AE/","photos":[]},{"tags":[{"name":"mongoose操作数组","slug":"mongoose操作数组","permalink":"https://codermino.github.io/tags/mongoose%E6%93%8D%E4%BD%9C%E6%95%B0%E7%BB%84/"}],"title":"mongoose操作数组","date":"2020/08/19","text":"简单查询 模糊查询 指定下标查询 精确查询 半精确查询($all) 半精确查询($in) 范围条件查询 数组内嵌文档查询，模糊查询 数组内嵌文档查询，指定下标查询 数组元素操作符$elemMatch 数组元素操作符$size 数组元素操作符$slice，完整 数组元素操作符$slice，正数 数组元素操作符$slice，负数 $占位符 数组单项改变 数组操作符$push 数组操作符$pull 样本数据：[ &#123; className: '1', name: 'a', detail: &#123;age: 20&#125;, region: ['安徽', '宿州'], score: [ 5, 11 ], box: [ &#123;book: '语文', num: 5, status: 2&#125;, &#123;book: '数学', num: 3, status: 0&#125; ] &#125;, &#123; className: '1', name: 'b', detail: &#123;age: 22&#125;, region: ['宿州', '安徽', '灵璧'], score: [ 14, 6 ], box: [ &#123;book: '英语', num: 8, status: 1&#125;, &#123;book: '地理', num: 2, status: 3&#125; ] &#125;, &#123; className: '2', name: 'c', detail: &#123;age: 24&#125;, region: ['江苏', '苏州'], score: [ 18, 12 ], box: [ &#123;book: '语文', num: 10, status: 5&#125;, &#123;book: '政治', num: 12, status: 1&#125; ] &#125; ] 简单查询// 例：返回《region包含‘安徽’的文档》 var condition = &#123;region: '安徽'&#125; dbs.find(condition, 'region name -_id') // 结果 [ &#123; region: [ '安徽', '宿州' ], name: 'a' &#125;, &#123; region: [ '宿州', '安徽', '灵璧' ], name: 'b' &#125; ] 模糊查询// 例：返回《region数组项包含“州”的文档》 var condition = &#123;region: /州/&#125; dbs.find(condition, 'region name -_id') // 结果 [ &#123; region: [ '安徽', '宿州' ], name: 'a' &#125;, &#123; region: [ '宿州', '安徽', '灵璧' ], name: 'b' &#125;, &#123; region: [ '江苏', '苏州' ], name: 'c' &#125; ] 指定下标查询// 例：返回《region数组下标2数据是“灵璧”的文档》 var condition = &#123;'region.2': '灵璧'&#125; dbs.find(condition, 'region name -_id') // 结果 [ &#123; region: [ '宿州', '安徽', '灵璧' ], name: 'b' &#125; ] 精确查询// 例：返回《region和condition一样的文档，顺序也要相同》 var conditionArr = [ '安徽', '宿州' ] dbs.find(&#123;region: conditionArr&#125;) // 结果 [ &#123; region: [ '安徽', '宿州' ], name: 'a' &#125; ] 半精确查询($all)// 例：返回《region包含所有condition项的文档，不关注顺序》 var conditionArr = [ '安徽', '宿州' ] await dbs.find(&#123;region: &#123;$all: conditionArr&#125;&#125;, 'region name -_id') // 结果 [ &#123; region: [ '安徽', '宿州' ], name: 'a' &#125;, &#123; region: [ '宿州', '安徽', '灵璧' ], name: 'b' &#125; ] 半精确查询($in)// 例：返回《region包含condition中任意项，的文档，不关注顺序》 var conditionArr = [ '灵璧', '苏州' ] dbs.find(&#123;region: &#123;$in: conditionArr&#125;&#125;, 'region name -_id') // 结果 [ &#123; region: [ '宿州', '安徽', '灵璧' ], name: 'b' &#125;, &#123; region: [ '江苏', '苏州' ], name: 'c' &#125; ] 范围条件查询// 例：返回《score数组中包含该类元素的文档：大于13且小于20》(有一个数组项满足就会返回) var condition = &#123;score: &#123; $gt: 13, $lt: 20&#125;&#125; dbs.find(condition, 'score name -_id') // 结果 [ &#123; score: [ 14, 6 ], name: 'b' &#125;, &#123; score: [ 18, 12 ], name: 'c' &#125; ] 数组内嵌文档查询，模糊查询// 例：返回《box数组项中的book属性有包含‘语文’》的文档 var condition = &#123;'box.book': '语文'&#125; dbs.find(condition, 'box name -_id') // 结果 [ &#123; name: 'a', box: [ &#123;book: '语文', num: 5, status: 2&#125;, &#123;book: '数学', num: 3, status: 0&#125; ] &#125;, &#123; name: 'c', box: [ &#123;book: '语文', num: 10, status: 5&#125;, &#123;book: '政治', num: 12, status: 1&#125; ] &#125; ] 数组内嵌文档查询，指定下标查询// 例：返回《book数组下标为1的那项值为‘数学’》的文档 var condition = &#123;'box.1.book': '数学'&#125; dbs.find(condition, 'box name -_id') // 结果 [ &#123; name: 'a', box: [ &#123;book: '语文', num: 5, status: 2&#125;, &#123;book: '数学', num: 3, status: 0&#125; ] &#125; ] 数组元素操作符$elemMatch// 例：返回《box数组项中的num属性大于6》的文档 var condition = &#123;'box': &#123;$elemMatch: &#123;num: &#123;$gt: 6&#125;&#125;&#125;&#125; dbs.find(condition, 'box name -_id') // 结果 [ &#123; name: 'b', box: [ &#123;book: '英语', num: 8, status: 1&#125;, &#123;book: '地理', num: 2, status: 3&#125; ] &#125;, &#123; name: 'c', box: [ &#123;book: '语文', num: 10, status: 5&#125;, &#123;book: '政治', num: 12, status: 1&#125; ] &#125; ] 数组元素操作符$size说明：$size不支持指定范围，而是一个具体的值。此外针对$size，没有相关可用的索引来提高性能 // 例：返回《region数组length等于2》的文档 var condition = &#123;region: &#123;$size: 2&#125;&#125; dbs.find(condition, 'region name -_id') // 结果 [ &#123; region: [ '安徽', '宿州' ], name: 'a' &#125;, &#123; region: [ '江苏', '苏州' ], name: 'c' &#125; ] 数组元素操作符$slice，完整// 例如：返回《region数组的 0-2项（包前不包后）》 dbs.find(&#123;name: 'b'&#125;, &#123;region: &#123;$slice: [0, 2]&#125;, name: 1, _id: -1&#125;) // 结果 [ &#123; region: [ '宿州', '安徽' ], _id: '5eaa6041698d9224dc181ab6', name: 'b' &#125; ] 数组元素操作符$slice，正数// 相当于：[0, 2] dbs.find(&#123;name: 'b'&#125;, &#123;region: &#123;$slice: 2&#125;, name: 1, _id: -1&#125;) // 结果 [ &#123; region: [ '宿州', '安徽' ], _id: '5eaa6041698d9224dc181ab6', name: 'b' &#125; ] 数组元素操作符$slice，负数// 相当于[-2, length] dbs.find(&#123;name: 'b'&#125;, &#123;region: &#123;$slice: -2&#125;, name: 1, _id: -1&#125;) // 结果 [ &#123; region: [ '安徽', '灵璧' ], _id: '5eaa6041698d9224dc181ab6', name: 'b' &#125; ] $占位符请记住，位置$操作符充当更新文档查询中第一个匹配的占位符。 // 例如：返回数组中第一个匹配的数组元素值 dbs.find(&#123;score: &#123; $lte: 6&#125;&#125;, &#123;'score.$': 1, name: 1&#125;) // 结果 [ &#123; _id: '5eaa6041698d9224dc181ab3', score: [ 5 ], name: 'a' &#125;, &#123; _id: '5eaa6041698d9224dc181ab6', score: [ 6 ], name: 'b' &#125; ] 数组单项改变// 例如：修改《box.book值为“语文”的那个数组项，将该项的status值改为100》 dbs.updateOne(&#123;'box.book': '语文'&#125;, &#123;'box.$.status': 100&#125;) // 结果 dbs.findOne(&#123;'box.book': '语文'&#125;, &#123;'box': 1, name: 1&#125;) // ---&gt;&gt; &#123; _id: '5eaa6041698d9224dc181ab3', name: 'a', box: [ &#123; _id: '5eaa6041698d9224dc181ab4', book: '语文', num: 5, status: 100 &#125;, &#123; _id: '5eaa6041698d9224dc181ab5', book: '数学', num: 3, status: 0 &#125; ] &#125; 数组操作符$push// 例如：修改，向name为a的文档的region数组尾部添加一项“中国” dbs.updateOne(&#123;name: 'a'&#125;, &#123;$push: &#123;region: '中国'&#125;&#125;) // 结果 dbs.findOne(&#123;name: 'a'&#125;, &#123;region: 1, name: 1&#125;) // ---&gt;&gt; &#123; region: [ '安徽', '宿州', '中国' ], _id: '5eaa6041698d9224dc181ab3', name: 'a' &#125; 数组操作符$pull// 例如：将name为a的文档的region数组中 '安徽' 删除 dbs.updateOne(&#123;name: 'a'&#125;, &#123;$pull: &#123;region: '安徽'&#125;&#125;) // 结果 dbs.findOne(&#123;name: 'a'&#125;, &#123;region: 1, name: 1&#125;) // ---&gt;&gt; &#123; region: [ '宿州', '中国' ], _id: '5eaa6041698d9224dc181ab3', name: 'a' &#125; $占位符详解一、更新数组中的值看如下students文档中的数据： db.students.insert(&#123;_id:NumberInt(1),grades:[NumberInt(80),NumberInt(85),NumberInt(90)]&#125;) db.students.insert(&#123;_id:NumberInt(2),grades:[NumberInt(88),NumberInt(90),NumberInt(92)]&#125;) db.students.insert(&#123;_id:NumberInt(3),grades:[NumberInt(85),NumberInt(100),NumberInt(90)]&#125;) &#123;\"_id\" : 1,\"grades\" : [ 80, 85, 90]&#125; &#123; \"_id\" : 2,\"grades\" : [ 88, 90, 92 ]&#125; &#123;\"_id\" : 3,\"grades\" : [ 85, 100, 90] 将第一个文档中grade字段中值为80更新为82，如果不知道数组中元素的位置，可以使用位置$操作符。匹配到的第一个符合条件的元素请记住，位置$操作符充当更新文档查询中第一个匹配的占位符。 db.students.update(&#123;_id:1, grades:80&#125;,&#123;$set:&#123;'grades.$':NumberInt(82)&#125;&#125;) 二、使用位置操作符$访问数组中嵌套的字段db.collection.update( &#123; &lt;query selector&gt; &#125;, &#123; &lt;update operator&gt;: &#123; \"array.$.field\" : value &#125; &#125; ) 看如下students文档集合中grades的嵌套文档集合 &#123; _id: 4, grades: [ &#123; grade: 80, mean: 75, std: 8 &#125;, &#123; grade: 85, mean: 90, std: 5 &#125;, &#123; grade: 90, mean: 85, std: 3 &#125; ] &#125; 更新集合文档的嵌套文档的grade值为85的文档的std字段的值为6 db.students.update( &#123; _id: 4, \"grades.grade\": 85 &#125;, &#123; $set: &#123; \"grades.$.std\" : 6 &#125; &#125; ) 三、使用多个字段匹配更新嵌入式文档位置操作符$能够更新第一个匹配的数组元素通过$elemMatch()操作符匹配多个内嵌文档的查询条件考虑如下的students集合文档grades字段是一个嵌套字段的文档 &#123; _id: 4, grades: [ &#123; grade: 80, mean: 75, std: 8 &#125;, &#123; grade: 85, mean: 90, std: 5 &#125;, &#123; grade: 90, mean: 85, std: 3 &#125; ] &#125; 如下语句会更新嵌套文档中的std值为6，条件是文档的主键是4，字段grades的嵌套文档字段grade字段值小于等于90mean字段值大于80 db.students.update( &#123; _id: 4, grades: &#123; $elemMatch: &#123; grade: &#123; $lte: 90 &#125;, mean: &#123; $gt: 80 &#125; &#125; &#125; &#125;, &#123; $set: &#123; \"grades.$.std\" : 6 &#125; &#125; ) 上面的操作语句会更新掉第一个匹配的嵌套文档集合，如下： &#123; _id: 4, grades: [ &#123; grade: 80, mean: 75, std: 8 &#125;, &#123; grade: 85, mean: 90, std: 6 &#125;, &#123; grade: 90, mean: 85, std: 3 &#125; ] &#125;","permalink":"https://codermino.github.io/2020/08/19/mongoose%E6%93%8D%E4%BD%9C%E6%95%B0%E7%BB%84/","photos":[]},{"tags":[{"name":"mongoose操作","slug":"mongoose操作","permalink":"https://codermino.github.io/tags/mongoose%E6%93%8D%E4%BD%9C/"}],"title":"mongoose操作","date":"2020/08/19","text":"mongoose是一个在Node中方便操作mongodb数据库的工具。主要形式是以对象安装：npm install mongoose –save 引入Demo1// 连接数据库 const mongoose =require('mongoose'); mongoose.connect('mongodb://localhost/2020',&#123; useNewUrlParser: true,useUnifiedTopology: true,useCreateIndex:true,useFindAndModify:false &#125;); //连接数据库 const db = mongoose.connection;//数据库的连接对象 db.on('error', console.error.bind(console, 'connection error:')); db.once('open', function() &#123; console.log('db ok') &#125;); Demo2// 本例以《连接本地名为myDB的数据库》为例 // 1.无账号密码： const mongoose = require('mongoose');// 引入mongoose模块 // 连接mongodb。填入mongodb所在服务器地址。和path，path代表了数据库名称 mongoose.connect('mongodb://127.0.0.1:27017/myDB', &#123; useNewUrlParser: true, useCreateIndex: true&#125;, function(err) &#123; if(err) &#123;console.log(err);return;&#125; console.log('数据库连接成功'); &#125;); // ---------------------分割线---------------------- // 2.有账号密码： const mongoose = require('mongoose');// 引入mongoose模块 // 连接mongodb。填入mongodb所在服务器地址。和path，path代表了数据库名称 // 并且地址之前使用@分割，@左面填写账号密码。账号密码之间以:隔开 mongoose.connect('mongodb://eggadmin:123456@localhost:27017/myDB', &#123; useNewUrlParser: true, useCreateIndex: true&#125;, function(err) &#123; if(err) &#123;console.log(err);return;&#125; console.log('数据库连接成功'); &#125;); tip 然后在需要的地方引入对应的文件，即可连接成功 定义模式模式决定了：1.数据库中行的字段。2.通过Mongoose的Api存储这些字段时的限制和验证 // 开始 // 1.获取 Schema模式构造函数 const Schema = mongoose.Schema; // 2.定义模式 let schema = new Schema(&#123; title: &#123; type: String,// 存储行之前，会自动将行内title字段转化成String类型 default: 'baidu.com',// 存储行时如果行内不存在title字段。则使用默认值 &#125;, list: &#123; type: Array, default: '', &#125;, &#125;); 根据模式获取模型模型可以对数据库进行《删/改/查》操作。 // 开始 // 1.获取 model模型构造函数 const model = mongoose.model; // model是构造函数。接受三个参数。 // 模式名：&lt;String&gt;任意取，但不可重复 // 模式对象：&lt;Object&gt; 上面定义的模式 // 要操作的集合的名称：&lt;String&gt; 如没有传入此参数。则默认操作《模式名的复数集合》 // 2.获取模型 // 例：不传入第三个参数 let Col_user = new model('Col_user', schema);// 获取集合实例 // 结果：Col_user模型将默认操作《col_users集合》 // -----------------分割线------------------ // 例：传入第三个参数 let Col_user = new model('Col_user', schema, 'abc');// 获取集合实例 // 结果：Col_user模型将默认操作《abc集合》 Demo1const mongoose=require('mongoose'); const fangjiaSchema = new mongoose.Schema(&#123; xiaoqu_name:&#123;type:String&#125;, position:&#123;type:String&#125;, price:&#123;type:Number&#125;, picture:&#123;type:Array,default:[]&#125;, price_type:&#123;type:Number,default:'0'&#125;, price_rate:&#123;type:String, default:'0%'&#125;, floor_area_ratio:&#123;type:String,default:'暂无数据'&#125;, total_hu:&#123;type:String, default:\"暂无数据\"&#125;, greening_rate:&#123;type:String, default:\"暂无数据\"&#125;, property_type:&#123;type:String, default:\"公寓住宅\"&#125;, developer:&#123;type:String, default:\"暂无数据\"&#125;, property_company:&#123;type:String, default:\"暂无数据\"&#125;, creminal_circle:&#123;type:String, default:\"暂无数据\"&#125;, l_time:&#123;type:String,default:Date.now&#125; &#125;); // 将schema 对象转化为数据模型 const Fangjia = mongoose.model('fangjia', fangjiaSchema);//该数据对象和集合关联('集合名',schema对象) module.exports=Fangjia; 增加const newUser = &#123; username, mail, password: hash &#125;; const result = await User.insertMany(newUser); 修改const result = await User.findOneAndUpdate(&#123; $and: [ &#123; username &#125;, &#123; mail &#125; ] &#125;,&#123;password:newpassword&#125;,&#123;new:true&#125;); 删除const result = await Data.findByIdAndDelete(&#123;_id: id&#125;); 查找// find // 接受两个参数(常用的是两个。其实还有一个options。但是基本用不到) // 参数1：query &lt;Object&gt; // 参数2：callback &lt;Function&gt; // 参数1：err &lt;Object&gt; 默认为null，报错时将变成Object // 参数2：docs &lt;Array&gt;装着《所有符合条件的行》的数组 // 例如，这里将查询《abc集合》中name为zs且年龄大于20的所有行,且不返回age字段，并以height排序 Data.find(&#123;name: 'zs', age: &#123;$gt: 20&#125;&#125;, &#123;age:0&#125;, &#123;$sort: &#123;height: -1, _id: -1&#125;&#125;, function(err, docs)&#123; if(err)&#123;console.log(err);return;&#125; console.log(docs, '查询结果的，数组'); &#125;) // ---------------------分割线--------------------- // findOne和find类似。但是只返回符合条件的第一个行。docs仍然是数组 获取符合条件的文档的数量const count = await Data.estimatedDocumentCount(); 修饰符/数据验证// 索引将增加《以该字段》为查询条件的————查询速度 // 1.用作任意类型的修饰符： let UserSchema = mongoose.Schema(&#123; abc: &#123; required: true,// 表示这个数据必须传入 set(params) &#123;// 自定义修饰符set， // ......做一些处理或者判断。 return new_params // 返回出被处理过后的params &#125; &#125;, // 下面三个为索引类型 uid: &#123; unique: true // 为uid字段创建不可以重复的唯一索引，从此以后uid不会出现重复 &#125;, age:&#123; index: true // 为age字段创建普通索引 &#125;, title: &#123; sparse: true // 为title属性创建稀疏索引 &#125; &#125;) // 2.用作String类型的修饰符 let UserSchema = mongoose.Schema(&#123; name: &#123; type: String, // 预定义修饰符，如果增加数据时类型不为String，则转换成String类型 trim: true,// 预定义修饰符，去除值两边空格，此修饰符只作用于type:String类型的数据 lowercase: true,// 预定义修饰符，将值转换为小写，此修饰符只作用于type:String类型的数据 uppercase: true,// 预定义修饰符，将值转换为大写，此修饰符只作用于type:String类型的数据 enum: true,// 枚举类型，要求数据必须满足枚举值 enum:['0','1','2'] match: /正则/, //增加的数据必须符合 match（正则）的规则 maxlength: 20, // 最大长度，length最大20 minlength: 10 // 最小长度，length最小10 &#125; &#125;) // 3.用作Number类型的修饰符： let UserSchema = mongoose.Schema(&#123; age: &#123; max: 110 ,// 用于 Number 类型数据，最大值 min: 1 ,// 用于 Number 类型数据，最小值 &#125; &#125;) // 4.字符串和数字都可以用的 let UserSchema = mongoose.Schema(&#123; equipment: &#123;// 设备信息 type: String,// 必须加这条来指定数据类型，否则报错 enum: ['pc', 'mobile'],// 可取的值。意为：非该数组内包含的值都是不可取的值，都不会通过验证 default: 'mobile' &#125;, &#125;) 操作符// $lt 小于： query = &#123;age: &#123;$lt: 20&#125;&#125; --- age &lt; 20 // $gt 大于： query = &#123;age: &#123;$gt: 20&#125;&#125; --- age &gt; 20 // $eq 等于： query = &#123;age: &#123;$eq: 20&#125;&#125; --- age = 20或者query = &#123;age: 20&#125; // $ne 不等于： query = &#123;age: &#123;$ne: 20&#125;&#125; --- age != 20 // $lte 小于等于 query = &#123;age: &#123;$lte: 20&#125;&#125; --- age &lt;= 20 // $gte 大于等于 query = &#123;age: &#123;$gte: 20&#125;&#125; --- age &gt;= 20 // $or 或 query = &#123;$or: [&#123;name: 'xx'&#125;, &#123;age:&#123;$lt &lt; 20&#125;]&#125; --- (name === 'xx' || age &lt; 20) // 正则 // 例：title中包含服装的 // .find(&#123;title:/服装/) // 例：title中以服装开头 // .find(&#123;title:/^服装/) // $inc 用来操作数字(用来增加指定字段的数量) 在update函数第二个参数中可以这样写，&#123;$inc:&#123;\"price\": +20&#125;&#125; ---- 在原price基础上增加20 // 关于$set操作符------------------------------------------------------------ // $set 在update类函数中，用来声明本次update是更新数据。而不是直接覆盖所有数据 // 例子：MongoDB原生语法：将name是zhangsan的数据的age改为15 // db.集合名.update(&#123;name:'zhangsan'&#125;,&#123;$set:&#123;age:15&#125;&#125;) // 例子：MongoDB原生语法：将name是zhangsan的那整条数据直接替换为&#123;age:15&#125; // db.集合名.update(&#123;name:'zhangsan'&#125;,&#123;age:15&#125;) // 说明：其实Mongoose的update类函数不再需要显式标明$set也可以只更新，不覆盖。写了也不会有影响。 // 但MongoDB必须显示使用$set操作符。否则将直接覆盖 聚合管道(高级查询) $project指定返回的列，也就是指定返回哪些字段 $match指定返回符合条件的字段 $group分组和统计 $limit指定只返回最多多少条数据 $skip跳过多少条数据 $lookup表关联查询 $sort排序，指定以什么字段排序，并指定正反序 细节 // 1. // 如果只有一个操作符，则可以单独使用对象包裹 // 例如： myModel.aggregate(&#123;$project:&#123;_id:false&#125;&#125;) // --------------分割线---------- // 如果多个操作符，则必须必须使用数组包裹 // 例如： myModel.aggregate([&#123;$project:&#123;_id:false&#125;&#125;,&#123;$limit:2&#125;]) // 2. // aggregate参数数组中的管道顺序会影响最终结果 // 3.sort字段的排序，尽量使用双(或以上)字段来排序。否则在分页时很容易会出现重复数据 $project// 指定返回的列，也就是指定返回哪些字段 // 例如：目标：查询order表数据，并且返回的行中字段。只有order_id/name/age三个 let Order = mongoose.model('Order',UserSchema,'order'); Order.aggregate([ &#123;$project:&#123;order_id:1, name: 1, age: 1&#125;&#125; ],function(err,docs)&#123; if(err) &#123;console.log(err);return&#125; console.log(docs);// 返回最终查询到的数据 &#125;) $match// 指定返回符合条件的字段 // 例如：目标：查询order表数据，并且只返回all_price值大于等于90的行 let Order = mongoose.model('Order',UserSchema,'order'); Order.aggregate([ &#123;$match: &#123;\"all_price\": &#123;$gte:90&#125;&#125;&#125; ],function(err,docs)&#123; if(err) &#123;console.log(err);return&#125; console.log(docs);// 返回最终查询到的数据 &#125;) $group// 分组和统计 // 例如：目标：查询order表数据，并以name字段分组，且统计每个组中的age之和 // 样本数据： // &#123; \"name\" : \"a\", \"age\" : 22 &#125; // &#123; \"name\" : \"a\", \"age\" : 22 &#125; // &#123; \"name\" : \"a\", \"age\" : 22 &#125; // &#123; \"name\" : \"b\", \"age\" : 22 &#125; // &#123; \"name\" : \"a\", \"age\" : 22 &#125; // &#123; \"name\" : \"b\", \"age\" : 22 &#125; // &#123; \"name\" : \"c\", \"age\" : 22 &#125; // &#123; \"name\" : \"c\", \"age\" : 22 &#125; // &#123; \"name\" : \"b\", \"age\" : 23 &#125; let Order = mongoose.model('Order',UserSchema,'order'); Oorder.aggregate([ &#123;$group: &#123;_id: \"$name\", my_num: &#123;$sum: \"$age\"&#125;&#125;&#125; ],function(err,docs)&#123; if(err) &#123;console.log(err);return&#125; console.log(docs);// 返回最终查询到的数据 &#125;) // docs返回数据： // &#123; \"_id\" : \"b\", \"my_num\" : 67 &#125; // &#123; \"_id\" : \"c\", \"my_num\" : 44 &#125; // &#123; \"_id\" : \"a\", \"my_num\" : 88 &#125; $limit// 指定只返回最多多少条数据 // 例如：目标：查询order表数据，并最多只返回2条数据 let Order = mongoose.model('Order',UserSchema,'order'); Order.aggregate([ &#123;$limit: 2&#125; ],function(err,docs)&#123; if(err) &#123;console.log(err);return&#125; console.log(docs);// 返回最终查询到的数据 &#125;) $skip// 跳过多少条数据 // 例如：目标：查询order表数据，并跳过前三条数据，只返回除了前三条以外的所有数据。 let Order = mongoose.model('Order',UserSchema,'order'); Order.aggregate([ &#123;$skip: 3&#125; ],function(err,docs)&#123; if(err) &#123;console.log(err);return&#125; console.log(docs);// 返回最终查询到的数据 &#125;) $lookup// 表关联查询 // 例如：将col表和test表关联，以《col表中uid字段》和《test表中ab字段》相关联。将test被关联的行，放到col表的myList数组中 let Col = mongoose.model('Col',UserSchema,'col'); // col表数据： // &#123;name:'zs',age:'20',uid:1&#125; // &#123;name:'li',age:'20',uid:2&#125; // &#123;name:'wa',age:'20',uid:1&#125; // &#123;name:'xh',age:'20',uid:3&#125; // test表数据： // &#123;u:'fd',price:'20',ab:1&#125; // &#123;u:'afd',price:'20',ab:2&#125; // &#123;u:'yt',price:'30',ab:2&#125; // 执行操作 Col.aggregate([ &#123; $lookup: &#123; from: 'test', // 这里意味和test集合关联 localField: 'uid',// 这里意为用col表中的uid字段和test表中的id字段关联。 foreignField: 'ab', as: 'myList' // 这里意为，将返回的最终数据，放在一个数组中。并且给该数组key设置为myList &#125; &#125; ], function(err, docs)&#123; if(err) &#123;console.log(err);return&#125; console.log(docs);// 返回最终查询到的数据 &#125;); // 返回结果，将test表中《ab值》和《col表中uid值》相同的test表数据放到col表的myList数组中 // [ // &#123; // \"_id\": ObjectId(\"5d3c603d8cbf5184d6763b4c\"), // \"name\": \"zs\", // \"age\": \"20\", // \"uid\": 1, // \"myList\": [ // &#123; // \"_id\": ObjectId(\"5d3c62888cbf5184d6763b53\"), // \"u\": \"fd\", // \"price\": \"20\", // \"ab\": 1 // &#125; // ] // &#125;, // &#123; // \"_id\": ObjectId(\"5d3c603d8cbf5184d6763b4d\"), // \"name\": \"li\", // \"age\": \"20\", // \"uid\": 2, // \"myList\": [ // &#123; // \"_id\": ObjectId(\"5d3c62888cbf5184d6763b54\"), // \"u\": \"afd\", // \"price\": \"20\", // \"ab\": 2 // &#125;, // &#123; // \"_id\": ObjectId(\"5d3c62888cbf5184d6763b55\"), // \"u\": \"yt\", // \"price\": \"30\", // \"ab\": 2 // &#125; // ] // &#125;, // &#123; // \"_id\": ObjectId(\"5d3c603d8cbf5184d6763b4e\"), // \"name\": \"wa\", // \"age\": \"20\", // \"uid\": 1, // \"myList\": [ // &#123; // \"_id\": ObjectId(\"5d3c62888cbf5184d6763b53\"), // \"u\": \"fd\", // \"price\": \"20\", // \"ab\": 1 // &#125; // ] // &#125;, // &#123; // \"_id\": ObjectId(\"5d3c603d8cbf5184d6763b4f\"), // \"name\": \"xh\", // \"age\": \"20\", // \"uid\": 3, // \"myList\": [] // &#125; // ] $sort// 排序，指定以什么字段排序，并指定正反序 let Order = mongoose.model('Order',UserSchema,'order'); // 样本数据： // &#123; \"name\" : \"a\", \"age\" : 36 &#125; // &#123; \"name\" : \"b\", \"age\" : 18 &#125; // &#123; \"name\" : \"c\", \"age\" : 22 &#125; // &#123; \"name\" : \"d\", \"age\" : 15 &#125; Order.aggregate([ &#123;$sort: &#123;\"age\": -1, _id: -1&#125;&#125;;// 注意，无论以什么排序，最好用双字段进行排序。防止查询出重复数据 ],function(err,doc)&#123; if(err) &#123;console.log(err);return&#125; console.log(doc);// 返回最终查询到的数据 &#125;); // -1结果是倒序： // &#123; \"name\" : \"a\", \"age\" : 36 &#125; // &#123; \"name\" : \"c\", \"age\" : 22 &#125; // &#123; \"name\" : \"b\", \"age\" : 18 &#125; // &#123; \"name\" : \"d\", \"age\" : 15 &#125; // 1则结果为正序。 小结用aggregate写一个分页 // node中分页接口 async function getList(request, response, next) &#123; let &#123;page = 1, size = 8, category_type = '', condition = ''&#125; = request.body; let reg = new RegExp(condition, 'gi'); let match = &#123;category_type: category_type, $or:[&#123;title: reg&#125;]&#125;; userModel.countDocuments(match, function (err, count) &#123; size = size &gt; 30 ? 30 : parseInt(size); size = size &lt; 8 ? 8 : parseInt(size); let maxPage = Math.ceil(count / size); page = page &gt; maxPage ? maxPage : parseInt(page); page = page - 1; page = page &lt; 0 ? 0 : parseInt(page); // 注意管道顺序，会影响结果 dbs.aggregate([ &#123;$match: match&#125;, &#123;$sort: &#123; href: -1, _id: 1&#125;&#125;, &#123;$project: &#123;href: false&#125;&#125;, &#123;$skip: page * size * 1&#125;, &#123;$limit: size * 1 &#125; ],function(err,doc)&#123; if(err) &#123;console.log(err);return&#125; return response.json(&#123;status: 1, msg: '数据获取成功', data: &#123;page: page+1, size, maxPage, condition, list: doc&#125;&#125;); &#125;); &#125;) &#125; 分页exports.getpagination = async function (req, res) &#123; const pageSize = parseInt(req.query.pageSize) || 5; const currentPage = parseInt(req.query.currentPage) || 1; let keyword =req.query.keyword || ''; let reg=new RegExp(keyword); const sorttype = req.query.sort; let sort = &#123;&#125;; if (sorttype)&#123; const isDesc = sorttype === '升序' ? 1 : -1; sort = &#123;'price':isDesc&#125;; //排序（按价格倒序） &#125; const condition = &#123; $or:[&#123;xiaoqu_name:&#123;$regex:reg&#125;&#125;,&#123;position:&#123;$regex:reg&#125;&#125;,&#123;creminal_circle:&#123;$regex:reg&#125;&#125;] &#125;; const skipnum = (currentPage - 1) * pageSize; //跳过数 const count = await Data.estimatedDocumentCount(); if (sorttype)&#123; const result = await Data.find(condition).skip(skipnum).limit(pageSize).sort(sort).exec(); res.send(&#123;code:200,msg:'查询ok',info:&#123;list:result,count,allpage:Math.ceil(count/pageSize)&#125;&#125;) &#125; else&#123; const result = await Data.find(condition).skip(skipnum).limit(pageSize).sort(&#123;_id:-1&#125;).exec(); res.send(&#123;code:200,msg:'查询ok',info:&#123;list:result,count,allpage:Math.ceil(count/pageSize)&#125;&#125;) &#125; &#125;;","permalink":"https://codermino.github.io/2020/08/19/mongoose%E6%93%8D%E4%BD%9C/","photos":[]},{"tags":[{"name":"scss语法","slug":"scss语法","permalink":"https://codermino.github.io/tags/scss%E8%AF%AD%E6%B3%95/"}],"title":"scss语法","date":"2020/08/19","text":"嵌套/*1.直接嵌套*/ .box &#123; font-size:25px; .per &#123; color:#f60; &#125; &amp;&gt;.abc &#123; background-color: #666; &#125; &#125; /*1结果*/ .box &#123; font-size:25px; &#125; .box .per &#123; color:#f60; &#125; .box&gt;.abc &#123; background-color: #666; &#125; // -----------------------------分割线---------------------- /* 2. 使用font@at-root */ .box &#123; font-size:25px; @at-root&#123; .per &#123; color:#f60; &#125; &amp;&gt;.abc &#123; background-color: #666; &#125; &#125; &#125; // 2结果 .box &#123; font-size:25px; &#125; .per &#123; color:#f60; &#125; .box&gt;.abc &#123; background-color: #666; &#125; 变量关键字(以$开头)： $ 变量名： 自定义 赋值符号： : 变量值： css样式值 // 声明变量 $myFontSize: 50px; // 使用 div &#123; width: $myFontSize; &#125; // 编译结果 div &#123; width: 50px; &#125; 混合宏@mixin关键字： @mixin 名称： 自定义 // 1.不带参数 // 声明一个混合宏@mixin @mixin myBorderRadius&#123; -webkit-border-radius:5px; border-radius:5px; &#125; // 使用 .box &#123; @include myBorderRadisu; &#125; // 1编译结果 .box &#123; -webkit-border-radius:5px; border-radius:5px &#125; // 2. // 声明一个带有参数的宏： @mixin 宏名称($abc,$w,$h)&#123; // ————此处可以设置默认值$abc:5px; -webkit-border-radius:$abc; border-radius:$abc; margin-top: -($h) / 2; // ———— 可以使用运算 margin-left: -($w) / 2; // ———— 可以使用运算 &#125; // 如果参数过多可以使用： ... @mixin box-shadow($shadows...)&#123; @if length($shadows) &gt;= 1 &#123; // —— 如果参数的length大于1 -webkit-box-shadow: $shadows; box-shadow: $shadows; &#125; @else &#123; $shadow: 0 0 2px rgba(#000,.25); -webkit-box-shadow: $shadow; box-shadow: $shadow; &#125; &#125; @extend继承// 例如 .box &#123; color:#f60; &#125; // .per类名继承.box类名 .per &#123; font-size:16px; @extend .box; &#125; // 编译结果 .box,.per &#123; color:#f60; &#125; .per &#123; font-size:16px; &#125; %占位符关键字： % // 声明一个占位符空间 %mt5 &#123; margin-top: 5px; &#125; // 用@extend使用占位符 .btn &#123; font-size:25px; @extend %mt5; &#125; .per &#123; @extend %mt5; &#125; // 编译结果 .btn,.per &#123; margin-top: 5px; &#125; .btn &#123; font-size:25px; &#125; 在vue中使用SCSS在vue中安装： npm install node-sass sass-loader –save-devnpm安装sass时的注意： 1 __ 如果安装过慢。 切换npm源，可大幅度提升速度 npm install -g mirror-config-china --registry=http://registry.npm.taobao.org 2 __如果安装完毕依赖后。项目编译错误。 则将package.json中将sass-loader的版本改为7.3.1，官方解释为版本过高导致的编译错误，并重新npm i \"sass-loader\": \"^7.3.1\", 使用// 将style标签上添加属性 lang=\"scss\" &lt;style lang=\"scss\" scoped&gt; @import \"../../../../static/css/common.scss\"; div &#123; width: 120px; .abc &#123; font-size: 16px; &#125; &#125; &lt;/style&gt; 在webstorm中使用SCSS在webstorm中配置自动编译： 英文版：依次点开 file--&gt;&gt;Settings--&gt;&gt;tool--&gt;&gt;File--Watchers--&gt;&gt;右上角加号--&gt;&gt;scss 中文版：依次点开 文件--&gt;&gt;设置--&gt;&gt;工具--&gt;&gt;File--Watchers--&gt;&gt;右上角加号--&gt;&gt;scss 配置： 更改Programs输入框内容： 改成ruby地址中的bin目录内的scss.bat的路径，如果安装ruby 时没有更改安装路径则默认地址如下： C:\\Ruby26-x64\\bin\\sass.bat 复制本条地址替换 --&gt;&gt;点击应用--&gt;&gt;点击确认 《完成》 下次使用webstorm编写scss文件时。将自动在同级目录下实时生成同名的.css文件","permalink":"https://codermino.github.io/2020/08/19/scss%E8%AF%AD%E6%B3%95/","photos":[]},{"tags":[{"name":"冷门且有用的css","slug":"冷门且有用的css","permalink":"https://codermino.github.io/tags/%E5%86%B7%E9%97%A8%E4%B8%94%E6%9C%89%E7%94%A8%E7%9A%84css/"}],"title":"冷门且有用的css","date":"2020/08/18","text":"多选按钮自定义背景色input[type=checkbox]&#123; box-sizing: border-box; padding: 0; margin: 0; cursor: pointer; position: relative; width: 20px; height: 20px; font-size: 12px; overflow: visible; &amp;:after&#123; box-sizing: border-box; padding: 0; margin: 0; width: calc(100% + 2px); height: calc(100% + 2px); color: transparent; position: absolute; top: calc(50% - 1px); left: calc(50% - 1px); font-size: 12px; line-height: 20px; font-weight: bold; transform: translateX(calc(-50% + 1px)) translateY(calc(-50% + 1px)); background-color: #1F253D; text-align: center; content: \" \"; border-radius: 4px; &#125; &amp;:checked::after&#123; content: \"✓\"; color: #fff; &#125; &#125; 更改“自动联想的input”样式input[type=text], input[type=password], input[type=number] &#123; /* 字体色 */ &amp;:-internal-autofill-previewed, &amp;:-internal-autofill-selected &#123; -webkit-text-fill-color: #fff; &#125; /* 背景色 */ &amp;:-webkit-autofill &#123; box-shadow: 0 0 0px 1000px #2d3a4b inset !important; &#125; &#125; 隐藏，input[type=number]的右面角标input[type='number']&#123; -moz-appearance:textfield; &amp;::-webkit-inner-spin-button, &amp;::-webkit-outer-spin-button &#123; -webkit-appearance: none; margin: 0; &#125; &#125; 设置滚动条样式/* 示例： */ /* 滚动条样式 */ .abc::-webkit-scrollbar &#123; width: 4px; &#125; /* 滑块样式 */ .abc::-webkit-scrollbar-thumb &#123; border-radius: 10px; -webkit-box-shadow: inset 0 0 5px rgba(0,0,0,0.2); background: rgba(0,0,0,0.2); &#125; /* 滑块的轨道样式 */ .abc::-webkit-scrollbar-track &#123; -webkit-box-shadow: inset 0 0 5px rgba(0,0,0,0.2); border-radius: 5px; background: rgba(0,0,0,0.1); &#125; /* ------------------------------------------------------- */ /* 具体含义及其他设置项： */ ::-webkit-scrollbar &#123;&#125; /* 滚动条整体部分 */ ::-webkit-scrollbar-thumb &#123;&#125; /* 滚动条里面的滑块 */ ::-webkit-scrollbar-track &#123;&#125; /* 滑块的轨道 */ ::-webkit-scrollbar-button &#123;&#125; /* 滚动条的轨道的两端按钮 */ /* ------------------------------------------------------- */ /* 他们的关系是: */ // scrollbar包含三个直接子元素： // start-button // track // end-button // track包含一个直接子元素： // thumb /* ------------------------------------------------------- */ /* 使用伪类： */ // scrollbar、track、thumb、button都可以使用:hover和active等伪类 /* 例如： */ .abc::-webkit-scrollbar-thumb:hover &#123; background-color: #fff; &#125; /*-------------------------------------------------------*/ /* 常用设置：*/ /* 滚动条样式, 主要作用 可以设置条的宽度(垂直条的宽度)，高度(水平条高度) */ .abc::-webkit-scrollbar &#123; width: 4px; height: 4px; &#125; /* 只设置垂直滚动条样式，可以轨道的宽度，背景色 */ .abc::-webkit-scrollbar:vertical &#123;&#125; /* 只设置水平滚动条样式，可以轨道的高度，背景色 */ .abc::-webkit-scrollbar:horizontal &#123;&#125; /* 滑块样式 */ .abc::-webkit-scrollbar-thumb &#123;&#125; /* 滑块的轨道条样式，只可以控制背景色圆角之类样式，不可以控制宽高 */ .abc::-webkit-scrollbar-track &#123;&#125; /* 设置条两边按钮样式 */ .abc::-webkit-scrollbar-button &#123;&#125; /* 只设置上/左按钮样式 */ .abc::-webkit-scrollbar-button:start &#123;&#125; /* 只设置下/右按钮样式 */ .abc::-webkit-scrollbar-button:end &#123;&#125; /* ------------------------------------------------------- */","permalink":"https://codermino.github.io/2020/08/18/%E5%86%B7%E9%97%A8%E4%B8%94%E6%9C%89%E7%94%A8%E7%9A%84css/","photos":[]},{"tags":[{"name":"js学习笔记Promise","slug":"js学习笔记Promise","permalink":"https://codermino.github.io/tags/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0Promise/"}],"title":"js学习笔记Promise","date":"2020/08/18","text":"Promise构造函数的基础使用Promise对象可以帮我们监听异步任务(函数)的执行结果。并通过两种标记来通知我们任务的状态 举一个简单的小栗子：目标：我们在做一个登录功能。向服务端发起请求。我们需要服务端给我们响应200(yes)或者非200(no)未知：由于网络因素。无法知道什么时候才可以得到回应。(异步任务)已知：无论是yes还是no 当我们接收到响应时，都必须立刻马上使用alert来给用户反馈结果。 代码：// 将登录任务交给Promise管理。并返回Promise实例 pro var pro = new Promise(function (resolve, reject) &#123; $.ajax(&#123; success: function(res) &#123; if(res.status === 200)&#123; // 调用resolve或reject，会告诉标记任务完成。（标记并不会直接终止后续代码。如下面的console.log(111)仍然会执行） // 标记任务完成。并通知Promise实例立即执行then的第一个回调函数 resolve('yes'); console.log(111); &#125;else &#123; // 标记任务完成。并通知Promise实例立即执行catch的回调函数，或者then的第二个回调函数 reject('no') &#125; &#125;, error: function(err)&#123; // 标记任务完成。并通知Promise实例立即执行catch的回调函数，或者then的第二个回调函数 reject('错误'); &#125; &#125;) &#125;); // pro是Promise实例。它会在任务标记完成时执行then或者catch // 具体执行then还是catch。取决于 是通过resolve标记还是reject标记 var pro2 = pro.then(function (p) &#123; // 如果任务调用了resolve，则执行这里代码 // 形参p接收resolve传来的值 alert('登录成功'); &#125;).catch(function (e) &#123; // 如果任务调用了reject，则执行这里代码 // 形参e接收reject传来的值 alert('登录失败，请重试'); if (e === '错误')&#123; console.log('代码可能写错了。或者网路错误'); &#125; &#125;) // -----------------分割线---------------------- // 实例调用then和catch，也是有返回值的。返回值仍然是一个Promise所构造的对象。所以依然可以调用then // 比如上面我们用pro2接受了这种对象 pro2.then(function()&#123; // 这里的代码仍然会执行。可以理解为回调函数 &#125;);// pro2.then仍然会返回一个Promise对象........... 《《注意！：如果任务调用了reject来标记任务完成。但是实例并没有监听catch。那么代码将会报错》》catch的另一种写法：给then传两个回调函数 pro.then(function () &#123; // 这里，相当于上面的then &#125;, function () &#123; // 这里相当于上面的catch &#125;) Promise构造函数的静态方法 resolve和reject all race resolve和rejectresolve和reject用法一样。这里只拿reject来讲解，他们都是用来直接标记。并返回一个Promise对象 例如： var pro = Promise.reject('一个惊喜'); pro.then(function () &#123; // 由于pro接收到的标记不是resolve，所以这里代码不会执行 &#125;, function (e) &#123; // 由于pro接收到的标记是reject，所以这里会执行 console.log(e === '一个惊喜');// ---&gt;&gt; true &#125;) all // Promise.all接收一个参数：&lt;Array&gt; 这个数组中元素都必须是Promise实例。 // Promise.all会在数组中所有实例都标记了resolve时。并执行then，且then回调的参数是所有resolve所传的值组成的数组 // 如果有任何一个实例标记了reject，则执行catch，且catch回调的参数是reject返回传来的参数。同时不再接受标记(意思是then // 和catch只有一个会执行。且只执行一次) // 简介：必须全部resolve才能执行then。否则执行catch。then回调形参接收数组，该数组是所有resolve值集合。catch是reject传来的值 var pro1 = new Promise(function (res, rej) &#123; setTimeout(function () &#123; if (Math.random() &gt; 0.5)&#123; res(111111); &#125;else &#123; rej(1); &#125; &#125;, 100); &#125;); var pro2 = new Promise(function (res, rej) &#123; setTimeout(function () &#123; if (Math.random() &gt; 0.5)&#123; res(222222); &#125;else &#123; rej(2); &#125; &#125;, 200); &#125;); // 只有接收到标记就开始then或catch。 // 同时不再接收标记(意思是then和catch只有一个会执行。且只执行一次) Promise.all([pro1, pro2]).then(function (data) &#123; console.log('真幸运，你连续两次都中奖了：', data);// [&lt;Number&gt;, &lt;Number&gt;] &#125;).catch(function (e) &#123; console.log('很遗憾，你有至少一次未中奖：', e);// &lt;Number&gt; &#125;) race // Promise.race接收一个参数：&lt;Array&gt; 这个数组中元素都必须是Promise实例。 // Promise.race会接收到第一个标记时执行then或catch。 // 同时不再接受标记(意思是then和catch只有一个会执行。且只执行一次) var pro1 = new Promise(function (res, rej) &#123; setTimeout(function () &#123; if (Math.random() &gt; 0.5)&#123; res(111111); &#125;else &#123; rej(1); &#125; &#125;, 100); &#125;); var pro2 = new Promise(function (res, rej) &#123; setTimeout(function () &#123; if (Math.random() &gt; 0.5)&#123; res(222222); &#125;else &#123; rej(2); &#125; &#125;, 200); &#125;); // 只有接收到标记就开始then或catch。 // 同时不再接收标记(意思是then和catch只有一个会执行。且只执行一次) Promise.race([pro1, pro2]).then(function (data) &#123; console.log('真幸运，你跑的很快。而且中将了：', data); &#125;).catch(function (e) &#123; console.log('虽然你跑的很快，但是并未中奖：', e); &#125;)","permalink":"https://codermino.github.io/2020/08/18/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0Promise/","photos":[]},{"tags":[{"name":"js学习笔记回收机制","slug":"js学习笔记回收机制","permalink":"https://codermino.github.io/tags/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"}],"title":"js学习笔记回收机制","date":"2020/08/18","text":"JS何时回收一个内存满足以下两个条件的《变量》的内存会被回收1.该变量是在局部作用域(函数作用域)内声明，而非全局作用域下声明。2.没有《任何别域下的变量》可以通过间接或直接的方式访问到它。 例1：function f1()&#123; var a = 1; var b = 2 c = 3; return function()&#123; return a &#125; &#125; var x = f1(); // 本次f1执行所产生的执行期上下文中有 // a 变量 // b 变量 // 一个匿名函数function // 在这里f1执行完毕。开始进行垃圾内存检测 // a 可以被 x() 访问到，所以不会被回收 // b没有《任何别域下的变量》可以访问到，会被回收 // 匿名函数function被x访问到。所以不会被回收 // c 相当于在全局window.c上，所以不会被回收 例2：function f1()&#123; var a = 1; return &#123; num: a++ &#125; &#125; var x = f1(); // 本次f1执行所产生的执行期上下文中有 // a 变脸 // 一个对象匿名对象object // a 可以被 x.num 访问到，所以当f1执行完后不会被回收 // 匿名对象被x访问到。所以不会被回收","permalink":"https://codermino.github.io/2020/08/18/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/","photos":[]},{"tags":[{"name":"js学习笔记正则reg","slug":"js学习笔记正则reg","permalink":"https://codermino.github.io/tags/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%AD%A3%E5%88%99reg/"}],"title":"js学习笔记正则reg","date":"2020/08/18","text":"创建正则表达式// 1. 通过构造函数生成。好处是可以支持变量 // 参数1 模式，描述了表达式的模式 // 参数2 修饰符，用于指定全局匹配、区分大小写的匹配和多行匹配 var suffix = 'js'; var reg = new RegExp(`[\\\\w\\\\.]+(?=\\\\.$&#123;suffix&#125;)`, 'igm'); // reg ---&gt;&gt; /[\\w\\.]+(?=\\.js)/gim // 2.字面量，更为简单。但是无法支持变量。 var patt = /[\\w\\.]+(?=\\.js)/gim; // 注意，无论是第一种还是第二种。当需要&lt;模式&gt;匹配&lt;存在特殊含义的字符&gt;时，需要使用转义字符进行转义 var reg1 = new RegExp(\"\\\\w+\"); var reg2 = /\\w+/; // 这里两种得出的表达式等价 修饰符 修饰符 描述 i 执行对大小写不敏感的匹配。 g 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。 m 执行多行匹配。 方括号 修饰符 描述 [abc] 查找方括号之间的任何字符 [^abc] 查找任何不在方括号之间的字符。 [0-9] 查找任何从 0 至 9 的数字。 [a-z] 查找任何从小写 a 到小写 z 的字符。 [A-Z] 查找任何从大写 A 到大写 Z 的字符。 [A-z] 查找任何从大写 A 到小写 z 的字符。 [adgk] 查找给定集合内的任何字符。 [^adgk] 查找给定集合外的任何字符。 (red|blue|green) 查找任何指定的选项。小括号包裹的也叫子表达式，后面在子表达式与$和replace的妙用中会详细讲到 元字符 元字符 描述 . 查找单个字符，除了换行和行结束符。相当于 [^\\r\\n] 只要不包含换行和行结束符。 \\w 查找单词字符。相当于 [0-9A-z_] 。 \\W 查找非单词字符。相当于 [^\\w] 。 \\d 查找数字。相当于 [0-9] 。 \\D 查找非数字字符。相当于 [^\\d] 。 \\s 查找空白字符。相当于 [ \\n\\r\\v\\f ] (注意这里末尾有个空格)。 \\S 查找非空白字符。相当于 [^\\s] 。 \\b 匹配单词边界。 \\B 匹配非单词边界。 \\0 查找 NUL 字符。 \\n 查找换行符。 \\f 查找换页符。 \\r 查找回车符。 查找制表符。 \\v 查找垂直制表符。 \\xxx 查找以八进制数 xxx 规定的字符。 \\xdd 查找以十六进制数 dd 规定的字符。 \\uxxxx 查找以十六进制数 xxxx 规定的 Unicode 字符。 量词 量词 描述 n+ 匹配任何包含至少一个 n 的字符串。 n* 匹配任何包含零个或多个 n 的字符串。 n? 匹配任何包含零个或一个 n 的字符串。（取消贪婪匹配） n{X} 匹配包含 X 个 n 的序列的字符串。 n{X,Y} 匹配包含 X 至 Y 个 n 的序列的字符串。例如： /^\\w{5,8}$/ 字符串必须是单词字符。且是5-8位。 n{X,} 匹配包含至少 X 个 n 的序列的字符串。 n$ 匹配任何结尾为 n 的字符串。 ^n 匹配任何开头为 n 的字符串。 ?=n 匹配任何其后紧接指定字符串 n 的字符串。 ?!n 匹配任何其后没有紧接指定字符串 n 的字符串。 RegExp对象的方法 方法 描述 compile 编译正则表达式。 exec 检索字符串中指定的值。返回找到的值，并确定其位置。返回值为类数组 test 检索字符串中指定的值。返回 true 或 false。 支持正则表达式的字符串方法 方法 描述 search 检索与正则表达式相匹配的值。会自动忽略g修饰符 match 找到一个或多个正则表达式的匹配。返回数组 replace 替换与正则表达式匹配的子串。如正则表达式无g修饰符。则只替换找到的第一个符合条件的字符串 split 把字符串分割为字符串数组。 exec没有g修饰符，reg.lastIndex无变化，示例 var str = 'a12a12'; var reg = /[a-z]/; console.log(reg.exec(str), reg.lastIndex);// [\"a\", index: 0, input: \"a12a12\", groups: undefined] console.log(reg.exec(str), reg.lastIndex);// [\"a\", index: 0, input: \"a12a12\", groups: undefined] // ...一直打印相同的值 有g修饰符，reg.lastIndex变化，示例 var str = 'a12a12'; var reg = /[a-z]/g; console.log(reg.exec(str), reg.lastIndex);// [\"a\", index: 0, input: \"a12a12\", groups: undefined] 1 console.log(reg.exec(str), reg.lastIndex);// [\"a\", index: 3, input: \"a12a12\", groups: undefined] 4 console.log(reg.exec(str), reg.lastIndex);// null 0 console.log(reg.exec(str), reg.lastIndex);// [\"a\", index: 0, input: \"a12a12\", groups: undefined] 1 console.log(reg.exec(str), reg.lastIndex);// [\"a\", index: 3, input: \"a12a12\", groups: undefined] 4 console.log(reg.exec(str), reg.lastIndex);// null 0 // ...循环上面结果 // 结论 // 值会更改。且reg.lastIndex显示：《下次匹配&lt;a12a12&gt;字符串时的起始下标》，index属性则记录了当前匹配结果在字符串中的起始下标 // 就是说。不会对已经匹配过的字符重复匹配。除非匹配到字符串尽头以至于从头开始了 test没有g修饰符，reg.lastIndex无变化，示例 var str = 'a12a12'; var reg = //; console.log(reg.test(str), reg.lastIndex);// true 0 console.log(reg.test(str), reg.lastIndex);// true 0 // ...一直打印相同的值 有g修饰符，reg.lastIndex变化，示例 var str = 'a12a12'; var reg = /[a-z]/g; console.log(reg.test(str), reg.lastIndex);// true 1 console.log(reg.test(str), reg.lastIndex);// true 4 console.log(reg.test(str), reg.lastIndex);// false 0 console.log(reg.test(str), reg.lastIndex);// true 1 console.log(reg.test(str), reg.lastIndex);// true 4 console.log(reg.test(str), reg.lastIndex);// false 0 // ...循环上面结果 // 结论 // 值会更改。且reg.lastIndex显示：《下次匹配&lt;a12a12&gt;字符串时的起始下标》 // 就是说。不会对已经匹配过的字符重复匹配。除非匹配到字符串尽头以至于从头开始了 search// 返回《第一个符合正则的字符串下标》，不会对reg.lastIndex造成影响 var str = '12a12'; var reg = /[a-z]/g;// 这里g修饰符会被忽略 console.log(str.search(reg), reg.lastIndex);// 2 0 match没有g修饰符，返回值类数组，且类数组内只有第一个符合条件的字符换 // 返回《类数组》，且类数组内只有第一个符合条件的字符换，不会对reg.lastIndex造成影响 var str = 'a12a12'; var reg = /[a-z]/; console.log(str.match(reg), reg.lastIndex);// [\"a\", index: 0, input: \"a12a12\", groups: undefined] 0 有g修饰符，返回数组，数组内包含字符串中所有符合正则的字符串 // 返回《数组》，数组内包含字符串中所有符合正则的字符串，不会对reg.lastIndex造成影响 var str = 'a12a12'; var reg = /[a-z]/g; console.log(str.match(reg), reg.lastIndex);// [\"a\", \"a\"] 0 replace没有g修饰符，只替换第一个 // 只替换第一个符合正则的字符串 var str = 'a12a12'; var reg = /[a-z]/; console.log(str.replace(reg, '='));// =12a12 有g修饰符。替换所有符合正则的字符串 // 替换所有符合正则的字符串 var str = 'a12a12'; var reg = /[a-z]/g; console.log(str.replace(reg, '='));// =12=12 split// 将符合正则的字符串当作数组中的逗号分隔，返回分割后的数组 var str = 'a12a12'; var reg = /[a-z]/g;// 此处忽略g修饰符 console.log(str.split(reg));// [\"\", \"12\", \"12\"] 子表达式与$和replace的妙用正则中的小括号不仅仅可以将局部正则变的独立。还可以变成子表达式，享有子表达的特有api。 被()包裹的正则表达式。被称为正则子表达式。正则子表达式的值可以在replace第二个参数中用$1、$2….来接收结果 例子1：当《replace的第二个参数》是函数时，在此函数中使用// 子1 子2 var reg = /b(\\w\\d)(\\d)/g; var str = \"abc19k\"; str.replace(reg,function($, $1, $2)&#123; console.log($, ' $');// 代表整个正则表达式匹配的值 console.log($1, ' $1');// 第一个子表达式匹配的值 console.log($2, ' $2');// 第二个子表达式匹配的值 &#125;); // console.log所打印结果如下 // bc19 $ // c1 $1 // 9 $2 例子2：当《replace的第二个参数》是字符串时，在此字符串中使用// 子1 子2 var reg = /b(\\w\\d)(\\d)/g; var str = \"abc19k\"; // 此处$1是第一个子表达式结果----&gt;&gt; c1 // $2则是第二个子表达式结果 -----&gt;&gt; 9 // 单纯的$只是一个字符串，且也是一个特殊的转义字符 console.log(str.replace(reg, \"$2\"));// ---&gt;&gt; a9k // -------------分割线----------- // 如果想要将结果替换成$字符，那么需要用$来转义，而不是\\ // 错误转义用 \\ console.log(str.replace(reg, \"\\$2\"));// ---&gt;&gt; a9k 失败了，函数仍然将$2理解为一个特殊值 // 正确转义用 $ 以暴制暴 console.log(str.replace(reg, \"$$2\"));// ---&gt;&gt; a$2k 转义成功 例子3：在正则中使用var str = 'aaabbbccccccccaaa'; // 这里 \\1 代表第一个子表达式所匹配的《结果》，(如果有第二个子表达式的话，\\2则代表第二个子表达式的匹配结果....) var reg = /(\\w)\\1*/g; console.log(str.replace(reg, '$1'));// abca 经典示例从后往前数，每三位添加一个 . // 例如将 1234567 变成 1.234.567 var str = '1234567'; var reg = /(?=(\\B)(\\d&#123;3&#125;)+$)/g; console.log(str.replace(reg, '.'));// ---&gt;&gt;&gt; 1.234.567 排除某类字符： // 匹配《不包含 aaa，bbb，c2》的字符串 var reg = /^((?!aaa|bbb|c2).)*$/g; // 例如： var str1 = 'aaqwer'; console.log(reg.test(str1));// true str1不包含 aaa var str2 = 'qwc2er'; console.log(reg.test(str2));// false str2包含了c2 将驼峰单词变成连字符单词 var str = 'theFirstName'; var reg = /([A-Z])/g; str.replace(reg, function($)&#123; return '-'+$.toLowerCase() &#125;);// ---&gt;&gt;&gt; \"the-first-name\" 将连字符单词变成驼峰单词 var str = 'the-first-name'; var reg = /-(\\w)/g; str.replace(reg, function($, $1)&#123; return $1.toUpperCase(); &#125;);// ---&gt;&gt;&gt; \"theFirstName\"","permalink":"https://codermino.github.io/2020/08/18/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%AD%A3%E5%88%99reg/","photos":[]},{"tags":[{"name":"js学习笔记数组array","slug":"js学习笔记数组array","permalink":"https://codermino.github.io/tags/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B0%E7%BB%84array/"}],"title":"js学习笔记数组array","date":"2020/08/18","text":"创建数组// 1 var arr1 = new Array();// ---&gt;&gt; [] // 2 var arr2 = new Array(0);// ----&gt;&gt; [] // 3 var arr3 = new Array(2);// ----&gt;&gt; [empty, empty];// 初始长度为2的空内容数组 // 4 var arr4 = new Array(1,2);// ----&gt;&gt; [1,2];// 初始就包含元素1和2的数组 // 5 字面量直接定义，！推荐 var arr = [];// ----&gt;&gt; [] // 或初始就有元素 var arr = [1, 2];// ----&gt;&gt; [1, 2]; 数组遍历// 现有变量： var arr = [1,2,3]; var len = arr.length; // 通用遍历方法示例1 --- 《for》 for(var i = 0; i &lt; len; i++)&#123; console.log(arr[i]); &#125; // 通用遍历方法示例2 --- 《while》 while(len &gt;= 0)&#123; console.log(arr[len]); len--; &#125; // ...for in 或者for of以及forEach或者别的语义的filter和map等也可以遍历。不多赘述。写法一样 数组方法* pop 删除并返回数组的最后一个元素 * push 向数组的末尾添加一个或更多元素，并返回新数组的长度 * shift 删除并返回数组的第一个元素 * unshift 向数组的开头添加一个或更多元素，并返回新的长度 * concat 拼接数组，返回全新数组。 * splice 剪切并添加新元素，返回被剪切的元素集合 * join 将数组转成字符串，每个元素间用参数分隔 * toString 将数组转成字符串，元素间用逗号隔开 * sort 排序数组，参数可以是自定义的函数 * filter 过滤数组， 返回符合条件的数组 * forEach 遍历数组，无返回值 * map 修改数组，返回新结果数组 * reduce 将数组值按照某种自定义的规则汇总 * includes 检查数组是否存在某元素。返回true或false * some 检测数组中是否至少存在一个指定元素。如存在则终止并返回true，否则false * every 检测数组所有元素是否都符合指定条件（通过函数提供），如出现一个不符合，则返回false * find 参数为函数，返回满足条件的第一个数据，并终止查找 * findIndex 参数为函数，满足条件的第一个数据的下标，并终止查找 * reverse 将数组倒置 * fill 填充数组 * copyWithin 从数组的指定位置拷贝元素到数组的另一个指定位置中 pop// 删除并返回数组的最后一个元素 var arr = [1, 5, 6]; console.log(arr.pop());// 6 console.log(arr);// [1, 5] push// 向数组的末尾添加一个或更多元素，并返回新数组的长度 var arr = [1, 5]; console.log(arr.push(6));// 3 console.log(arr);// [1, 5, 6] shift// 删除并返回数组的第一个元素 var arr = [1, 5, 6]; console.log(arr.shift());// 1 console.log(arr);// [5, 6] unshift// 向数组的开头添加一个或更多元素，并返回新的长度 var arr = [5, 6]; console.log(arr.unshift(1));// 3 console.log(arr);// [1, 5, 6] concat// 拼接数组，返回全新数组。参数可以是元素，也可是数组 // 1参数为元素 var arr = [1, 5]; console.log(arr.concat(6, 8));// [1, 5, 6, 8] console.log(arr);// [1, 5] // 2参数为数组， var arr = [1, 5]; console.log(arr.concat([6, [8, 9]]));// [1, 5, 6, [8, 9]]; console.log(arr);// [1, 5] splice// 剪切并添加新元素，返回被剪切的元素集合 var arr = [1, 5, 6, 7, 8]; console.log(arr.splice(1,2,\"abc\"));// [5, 6] console.log(arr);// [1, \"abc\", 7, 8] join// 将数组转成字符串，每个元素间用参数分隔 var arr = [1, 5]; console.log(arr.join);// \"1,5\" console.log(arr);// [1, 5] toString// 将数组转成字符串，元素间用逗号隔开 var arr = [1, 5]; console.log(arr.toString);// \"1,5\" console.log(arr);// [1, 5] sort// 将数组排序 // 1排序数字数组 var arr = [5,9,3]; console.log(arr.sort());// [3, 5, 9] console.log(arr);// [3, 5, 9] // 2排序字符串数组，根据unicode码排序。 var arr = ['bd','ba','c', 'a']; console.log(arr.sort());// [\"a\", \"ba\", \"bd\", \"c\"] // 3排序复杂数组，参数为自定义的函数。函数内部接收两个参数 ，代表前一个元素和后一个元素。函数的返回值是正或负数，决定了元素的前后位置 var arr = [&#123;age: 20&#125;, &#123;age: 16&#125;, &#123;age: 18&#125;]; console.log(arr.sort(function(a,b)&#123; return a.age-b.age &#125;));// [&#123;age: 16&#125;, &#123;age: 18&#125;, &#123;age: 20&#125;]; filter// 过滤数组， 返回符合条件的数组 // 例如，筛选出数组中，age大于18的元素集合 var arr = [&#123;age: 20&#125;, &#123;age: 16&#125;, &#123;age: 18&#125;, &#123;age: 17&#125;]; console.log(arr.filter(function(prop, index ,arr)&#123; return prop.age&gt;17 &#125;));// [&#123;age: 20&#125;, &#123;age: 18&#125;] console.log(arr);// 未变 forEach// 遍历数组，参数为函数，函数有三个参数，分别是值,下标,源数组 var arr = [&#123;age: 20&#125;, &#123;age: 16&#125;]; console.log(arr.forEach(function(prop, index ,arr)&#123; // prop---&gt;&gt;当前元素 // index---&gt;&gt;当前元素的下标 // arr---&gt;&gt;源数组的引用 // 此处可以更改数组当前项内容。但如果执行了return会提前终止遍历 console.log(prop, index, arr); &#125;));// 无返回值---&gt;&gt;undefined map// 更改数组 var arr = [&#123;age: 20&#125;, &#123;age: 16&#125;] console.log(arr.map(function(prop, index, arr)&#123; prop.age+=1; return prop; &#125;));// [&#123;age: 21&#125;, &#123;age: 17&#125; console.log(arr);// [&#123;age: 21&#125;, &#123;age: 17&#125; reduce// reduce接受两个参数。第一个参数是规则函数，第二个是规则运行时的初始值initivalValue，reduce会返回规则最终汇总的结果 // 如果没有传入initivalValue参数，则reduce会将数组的第一个元素当作initivalValue // 例1，做一个简单的累加器 var arr = [1, 5]; var initivalValue = 0; var num = arr.reduce(function(x, y)&#123; return x+y; &#125;, initivalValue ); console.log(num);// 6 如果initivalValue值为5，则num最终值为11 // 例2，计算value总和以及age总和。 var arr1 = [ &#123;value: 1, age: '30'&#125;, &#123;value: '5', age: 20&#125; ] var ZH = arr1.reduce(function(pre, next)&#123; var value = parseFloat(pre.value)+parseFloat(next.value); var age = parseFloat(pre.age)+parseFloat(next.age); return &#123;value: value, age: age&#125; &#125;, &#123;value: '0', age: 0&#125;); console.log(ZH);// ---&gt;&gt; &#123;value: 6, age: 50&#125; // 提示：与reduce类似的还有一个叫reduceRight的函数。原理一样。只不过是从后往前开始汇总计算 includes// 检测数组中是否存在某元素,参数1是需要查找的元素。参数2是从下标几开始查找 var arr = [6, 'a', 'b']; arr.includes('a');// true arr.includes('a', 1);// true arr.includes('a', 2);// false some// 检测数组所有元素是否有至少一个符合指定条件，返回true或false，如遇到符合的 则立刻终止查询并返回true // 参数必须是函数 var arr = [6, 'a', 'd']; arr.some(function(prop, index)&#123; // console.log(index);// 当前下标 return prop === 'a' &#125;);// true every// 用于检测数组所有元素是否都符合指定条件，如有一个不满足。则立即终止查询并返回false // 参数必须是函数 var arr = [6, 'a', 'd']; arr.every(function(prop, index)&#123; // console.log(index);// 当前下标 return prop === 'a';// 是否全都是'a' &#125;);// false find// 参数为函数，满足条件的第一个数据，并终止查找 var arr = [&#123;age: 20&#125;, &#123;age: 26&#125;]; arr.find(function(prop, index)&#123; // console.log(index);// 当前下标 return prop.age &gt; 26;// 年龄大于26的第一个元素 &#125;);// ---&gt;&gt;&gt; &#123;age: 26&#125; findIndex// 参数为函数，满足条件的第一个数据，并终止查找 var arr = [&#123;age: 20&#125;, &#123;age: 26&#125;]; arr.findIndex(function(prop, index)&#123; // console.log(index);// 当前下标 return prop.age &gt; 26;// 年龄大于26的第一个元素 &#125;);// ---&gt;&gt;&gt; 1 reverse// 倒置数组 var arr = [1, 5, 6]; console.log(arr.reverse());;;// [6, 5, 1] console.log(arr);// [6, 5, 1] fill// 填充数组 // 参数1，需要用来替换的值 // 参数2，起始下标(包含该下标) // 参数3，截至下标(不包含该下标) // 例1，不传参数2和参数3 var arr = [1, 5, 6, 8]; console.log(arr.fill('a'));// 全部替换 [\"a\", \"a\", \"a\", \"a\"] console.log(arr); [\"a\", \"a\", \"a\", \"a\"] // 例2，传入参数2和3 var arr = [1, 5, 6, 8]; console.log(arr.fill('a',1,3));// [1, \"a\", \"a\", 8] console.log(arr);// [1, \"a\", \"a\", 8] copyWith// 从数组的指定位置拷贝元素到数组的另一个指定位置中 // 参数1，放置的位置下标，包含该下标 // 参数2，复制时的起始下标，复制时包含该下标 // 参数3，复制终止的下标，复制时不包含该下标 var arr = [\"a\", \"b\", \"c\", \"d\", \"e\"]; arr.copyWithin(2, 0, 2);// [\"a\", \"b\", \"a\", \"b\", \"e\"]","permalink":"https://codermino.github.io/2020/08/18/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B0%E7%BB%84array/","photos":[]},{"tags":[{"name":"js学习笔记对象object","slug":"js学习笔记对象object","permalink":"https://codermino.github.io/tags/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%AF%B9%E8%B1%A1object/"}],"title":"js学习笔记对象object","date":"2020/08/18","text":"对象默认特性* 对象的属性是唯一的。定义多个重复属性时，只有最后一个会生效。也就是后来居上覆盖前面的。 * 对象的属性值可以是基础数据类型中任意类型值。 * 对象是引用值。实际上一个对象变量仅代表了一个空间的引用。相当于一个地址。而非数据 对象基本使用1.创建对象// 1通过构造函数创建 var o1 = new Object();// &#123;&#125; // 2通过字面量 var o2 = &#123;&#125;;// &#123;&#125; 2.向对象添加属性var o = &#123;&#125;;// 创建一个对象 o.name = \"xiaoxie\"; console.log(o);// ---&gt;&gt;&gt; &#123;name: \"xiaoxie\"&#125; 3.读取对象属性值var o = &#123;name: 'xiaoxie'&#125;; // 读取o的name属性的值 o.name或o[\"name\"] 4.修改对象属性值var o = &#123;name: 'xx'&#125;; console.log(o);// &#123;name: 'xx'&#125; // 修改name为xiaoxie o.name = \"xiaoxie\"; // 或者 o[\"name\"] = \"xiaoxie\"; console.log(o);// &#123;name: \"xiaoxie\"&#125; 5.删除对象的属性var o = &#123;name: \"xx\"&#125;; console.log(o);// &#123;o&#125; delete o.name;// true console.log(o);// &#123;&#125; 6.对象的遍历var o = &#123;name: 'xiaoxie', sex: '男'&#125;; for (var i in o)&#123; console.log(i);// 属性名 console.log(o[i]);// 属性值 &#125; Object构造函数的一些常用api* is将两个值以《类似===的比较》进行对比。返回值true或false，这个函数神奇的地方是：Object.is(NaN, NaN);//---&gt;&gt;true assign合并别的对象的值到第一个对象中。并且相同属性，将使用别的对象提供的 * defineProperty更改单个属性特性 * defineProperties更改多个属性特性 * getOwnPropertyDescriptor(o ,\"name\")返回o对象的name属性的特性信息 * getOwnPropertyDescriptors(o)返回o对象的所有自由属性的特性信息 * keys(o)返回o自有属性中的可枚举key数组。[\"name\", \"age\"] * getOwnPropertyNames(o)返回o的所有自有属性key数组，包括不可枚举属性 * values(o)返回o自有属性中的可枚举key所对应的值数组[\"xiaoxie\", \"23\"] * entries(o)返回o的可迭代key和value数组----&gt;&gt;&gt;[[\"x\", \"1\"],[\"y\", \"2\"]] * getPrototypeOf(o)获取o对象的原型 * isExtensible(o)检测o对象是否是---&gt;&gt;《可扩展的》(不可扩展意为不可以新增属性)，返回true或false * preventExtensions(o)将o变为不可扩展对象，并返回o对象的引用，此法只针对o，对于o的属性没有影响 * isSealed(o)获取o是否是----&gt;&gt;《不可扩展，且所有自有属性也都是不可配置》，返回true或false * seal(o)将o变为不可扩展对象，且将o的所有自有属性的特性设置为不可配置。并返回对象的引用 * isFreeze(o)获取o是否是----&gt;&gt;《不可扩展，且所有自有属性也都是不可配置和只读》，返回true或false * freeze(o)将o变为不可扩展对象，且将o的所有自有属性的特性设 置为不可配置和只读。但是存取器属性setter依然可以通过 赋值来调用，但是setter函数内的修改属性值的语句不会生效； is// 接受两个参数，比较两个值是否相等，并返回布尔值 Object.is(1, '1');// false Object.is(1, 1);// true Object.is(NaN, NaN);// true 《在这个函数出现以前，NaN是不等于任何值的，包括NaN自身》 assign// 接受多个参数。参数都必须是对象，返回第一个参数的引用。且所有参数中。只有第一个参数的值会被更改 var a = &#123;name: 'a', age: 20&#125;; var b = &#123;name: 'b', sex: 'n'&#125;; var c = &#123;name: 'c', sex: 'hh'&#125;; Object.assign(a, b, c);// ---&gt;&gt;&gt; &#123;name: \"c\", age: 20, sex: \"hh\"&#125; // a ---&gt;&gt; &#123;name: \"c\", age: 20, sex: \"hh\"&#125; // b ---&gt;&gt; &#123;name: \"b\", sex: \"n\"&#125; // c ---&gt;&gt; &#123;name: \"c\", sex: \"hh\"&#125; definePropertyObject.defineProperty(o, propKey, attr) Object.defineProperty不但可以定义属性特性。在定义时也可以修改属性值 Object.defineProperty的attr配置中，关于读取操作。有两种描述符，分别是《数据描述符》和《存取描述符》 // 描述符对象的默认值 // 数据描述符的默认值 &#123; value: \"初始值\", writable: false,// 可写性 enumerable: false,// 可枚举性 configurable: false// 特性的可配置性。为false，表示自此以后不可以修改任何特性 &#125; // 存取描述符的默认值 &#123; get: function()&#123;return '默认值'&#125;, set: undefined,// 可写性 enumerable: false,// 可枚举性 configurable: false// 特性的可配置性。为false，表示自此以后不可以修改任何特性 &#125; // 数据描述符 var o = &#123;name: 'xx'&#125;; Object.defineProperty(o, 'name', &#123; value: 'xiaoxie',// 属性值 writable: true,// 是否可写，意为属性值是覅偶可以更改 enumerable: true,// 是否可以被枚举。true时在for in循环中可以被枚举到 configurable: false// 特性是否可以被修改，false时则不可逆,也就是之后无法再次更改任何特性信息 &#125;) // 存取描述符 var store = &#123;name: 'xx'&#125;; var o = &#123;&#125;; Object.defineProperty(o, 'name', &#123; get: function() &#123;// 定义属性值，读取o.name时执行的函数 return store.name; &#125;, set: function(v) &#123; // 在这里可以搞事情，做一些判断。来决定是否进行赋值更改 store.name = v;// 定义赋值操作。在给o.name赋值时执行的函数。 &#125;, enumerable: true,// 是否可以被枚举。true时在for in循环中可以被枚举到 configurable: false// 特性是否可以被修改，如值是false，则不可逆，也就是之后无法再次更改任何特性信息 &#125;) definePropertiesObject.defineProperties(o, attr) Object.defineProperties允许同时定义多个属性。但是其实并不如defineProperty好用灵活 var o = &#123;&#125;; Object.defineProperties(o, &#123; name: &#123; value: 'xiaoxie' // 这里写着描述符 &#125;, sex: &#123; get: function() &#123;// 定义属性值，读取o.name时执行的函数 return '男'; &#125;, set: function(v) &#123; alert('sex属性不可以更改'); return '此值不可以更改' &#125; // 这里写描述符 &#125; &#125;) console.log(o.name);// \"xiaoxie\" console.log(o.sex);// \"男\" getOwnPropertyDescriptor// 返回o对象的name属性的特性信息, 接受两个参数，分别是对象和它的一个属性名字符串 // 例如： // 先定义一个o对象，并配置属性值 var o = &#123;&#125;; Object.defineProperties(o, &#123; name: &#123; value: 'xiaoxie' // 这里写着描述符 &#125; &#125;) // 返回o对象的name属性的特性信息 Object.getOwnPropertyDescriptor(o, 'name'); //---&gt;&gt;&gt; &#123;value: \"xiaoxie\", writable: false, enumerable: false, configurable: false&#125; getOwnPropertyDescriptors// 返回o对象的所有属性的特性信息, 接收一个参数——对象 // 例如： // 先定义一个o对象，并配置属性值 var o = &#123;&#125;; Object.defineProperties(o, &#123; name: &#123; value: 'xiaoxie' // 这里写着描述符 &#125;, sex: &#123; get: function() &#123;// 定义属性值，读取o.name时执行的函数 return '男'; &#125;, set: function(v) &#123; alert('sex属性不可以更改'); return '此值不可以更改' &#125; // 这里写描述符 &#125; &#125;) // 返回o对象的所有属性的特性信息 Object.getOwnPropertyDescriptors(o); &#123; name: &#123;value: \"xiaoxie\", writable: false, enumerable: false, configurable: false&#125; sex: &#123;enumerable: false, configurable: false, get: ƒ, set: ƒ&#125; &#125; keys// 返回对象的所有自有属性中《可枚举的属性》组成的数组 var o = &#123;&#125;; Object.defineProperties(o, &#123; name: &#123; value: 'xiaoxie', enumerable: true// 设置为可枚举 &#125;, sex: &#123; get: function() &#123; return '男'; &#125;, set: function(v) &#123; &#125;, enumerable: false// 设置为不可枚举 &#125; &#125;) Object.keys(o); //---&gt;&gt;[\"name\"] getOwnPropertyNames// 返回对象的所有自有属性数组。无论是否可枚举 var o = &#123;&#125;; Object.defineProperties(o, &#123; name: &#123; value: 'xiaoxie', enumerable: true// 设置为可枚举 &#125;, sex: &#123; get: function() &#123; return '男'; &#125;, set: function(v) &#123; &#125;, enumerable: false// 设置为不可枚举 &#125; &#125;) Object.getOwnPropertyNames(o);// [\"name\", \"sex\"] values// 返回对象中所有自有属性《可枚举的属性》的值 组成的数组 // 例1 var o = &#123;&#125;; Object.defineProperties(o, &#123; name: &#123; value: 'xiaoxie', enumerable: true// 设置为可枚举 &#125;, sex: &#123; get: function() &#123; return '男'; &#125;, set: function(v) &#123; &#125;, enumerable: false// 设置为不可枚举 &#125; &#125;) Object.values(o);// [\"xiaoxie\"] // 例2 var o = &#123;&#125;; Object.defineProperties(o, &#123; name: &#123; value: 'xiaoxie', enumerable: true// 设置为可枚举 &#125;, sex: &#123; get: function() &#123; return '男'; &#125;, set: function(v) &#123; &#125;, enumerable: true// 设置为可枚举 &#125; &#125;) Object.values(o);// [\"xiaoxie\", \"男\"] entries// 返回对象中所有自有属性《可枚举的属性》的['key', 'value'] 组成的数组 // 例1 var o = &#123;&#125;; Object.defineProperties(o, &#123; name: &#123; value: 'xiaoxie', enumerable: true// 设置为可枚举 &#125;, sex: &#123; get: function() &#123; return '男'; &#125;, set: function(v) &#123; &#125;, enumerable: false// 设置为不可枚举 &#125; &#125;) Object.entries(o);// ----&gt;&gt; [[\"name\", \"xiaoxie\"]] // 例2 var o = &#123;&#125;; Object.defineProperties(o, &#123; name: &#123; value: 'xiaoxie', enumerable: true// 设置为可枚举 &#125;, sex: &#123; get: function() &#123; return '男'; &#125;, set: function(v) &#123; &#125;, enumerable: true// 设置为可枚举 &#125; &#125;) Object.entries(o);// ----&gt;&gt; [[\"name\", \"xiaoxie\"], [\"sex\", \"男\"]] getPrototypeOf// 检测p是否在o的原型链上，此方法是原型上的方法，所以实际上是实例上直接可用的方法 var p = &#123;x:'1'&#125;; var o = Object.create(p); p.isPrototypeOf(o);// ----&gt;&gt; true p在o的原型链中 o.isPrototypeOf(p);// ----&gt;&gt; false o不在p的原型链中 Object.prototype.isPrototypeOf(o);// ----&gt;&gt; true Object.prototype在o的原型链中 isPrototypeOf// 获取对象的原型，接受一个参数——对象 function F()&#123;&#125;; var o = new F(); Object.getPrototypeOf(o)=== F.prototype;// ---&gt;&gt; true Object.getPrototypeOf(o).constructor === F;// ---&gt;&gt; true isExtensible// 检测o对象是否是---&gt;&gt;《可扩展的》(是否可以新增属性)，返回true或false var o = &#123;name: 'o'&#125;; Object.isExtensible(o);// true // 执行添加属性 o.age = 20; console.log(o);// &#123;name:'o', age: 20&#125; preventExtensions// 接受一个参数o对象，将o变为不可扩展对象，并返回o对象的引用，此法只针对o，对于o的属性没有影响 var o = &#123;prop: &#123;name: 'pr'&#125;&#125;; Object.preventExtensions(o);// &#123;prop: &#123;name: \"pr\"&#125;&#125; // 执行添加属性 o.age = 20; console.log(o);// &#123;prop: &#123;name: \"pr\"&#125;&#125; 这里age并没有被添加进o对象 // preventExtensions不会影响到目标对象的属性 // 例如这里给o.prop对象添加属性 o.prop.age = 20; console.log(o);// ----&gt;&gt; &#123;prop: &#123;name: \"pr\", age: 20&#125;&#125; isSealed// 接受一个参数o对象，获取o是否是----&gt;&gt;《不可扩展，且所有自有属性也都是不可配置》，返回true或false // 例1 // 先定义一个对象，并配置属性的configurable var o = &#123;&#125;; Object.defineProperties(o, &#123; name: &#123; value: 'xiaoxie', configurable: false,// 配置性设置为false，表示自此以后不可以修改任何特性 &#125;, sex: &#123; configurable: true,// 配置性设置为true &#125; &#125;) Object.preventExtensions(o);// 接着将其改为不可扩展的，如果没有变成不可扩展。。。下面就不用测试了，肯定false Object.isSealed(o);// false 这里最终结果返回false。因为sex属性特性中configurable是可配置的 // 例2 // 先定义一个对象，并配置属性的configurable var o = &#123;&#125;; Object.defineProperties(o, &#123; name: &#123; value: 'xiaoxie', configurable: false,// 配置性设置为false，表示自此以后不可以修改任何特性 &#125;, sex: &#123; configurable: false,// 配置性设置为false &#125; &#125;) Object.preventExtensions(o);// 接着将其改为不可扩展的，如果没有变成不可扩展。。。下面就不用测试了，肯定false Object.isSealed(o);// true这里最终结果返回true ，因为o对象是不可扩展的。且它的所有自有属性的特性也都是不可配置的 seal// 接受一个参数o对象，将o变为不可扩展对象，且将o的所有自有属性的特性设置为不可配置。并返回对象的引用 // 例如 var o = &#123;name: 'xx',prop: &#123;age: 20&#125;&#125;; Object.isExtensible(o);// --&gt;&gt; true Object.isSealed(o);// --&gt;&gt; false Object.seal(o);// --&gt;&gt; 返回o的引用&#123;name: 'xx',prop: &#123;age: 20&#125;&#125; Object.isExtensible(o);// --&gt;&gt; false Object.isSealed(o);// --&gt;&gt; true // o的自有属性仍然可以《扩展和修改自身属性》的值 o.prop.age = 23;// console.log(o);// --&gt;&gt; &#123;name: 'xx',prop: &#123;age: 23&#125;&#125; o.prop.name = 'son'; console.log(o);// --&gt;&gt; &#123;name: 'xx',prop: &#123;age: 23, name: 'son'&#125;&#125; isFreeze// 接受一个参数o对象，获取o是否是----&gt;&gt;《不可扩展，且所有自有属性也都是不可配置和只读》，返回true或false // 例1 // 先定义一个对象，并配置属性的configurable var o = &#123;&#125;; Object.defineProperties(o, &#123; name: &#123; value: 'xiaoxie', configurable: false, writable: false, //不可写 &#125;, sex: &#123; configurable: false, writable: true, // 可写 &#125; &#125;); Object.seal(o);// 将o变为不可扩展对象，且将o的所有自有属性的特性设置为不可配置。并返回对象的引用 Object.isFrozen(o); Object.isFrozen(o);// ---&gt;&gt; 结果为false // 例2 // 先定义一个对象，并配置属性的configurable var o = &#123;&#125;; Object.defineProperties(o, &#123; name: &#123; value: 'xiaoxie', configurable: false, writable: false, //不可写 &#125;, sex: &#123; configurable: false, writable: false, // 不可写 &#125; &#125;); Object.seal(o);// 将o变为不可扩展对象，且将o的所有自有属性的特性设置为不可配置。并返回对象的引用 Object.isFrozen(o); console.log(Object.isFrozen(o));// ---&gt;&gt; 结果为true freeze// 接受一个参数o对象，将其变成不可扩展。并且自有属性也变成不可配置和只读 // 例如 var o = &#123;name: 'xx',prop: &#123;age: 20&#125;&#125;; Object.isExtensible(o);// --&gt;&gt; true Object.isSealed(o);// --&gt;&gt; false Object.isFrozen(o);// --&gt;&gt; false Object.freeze(o);// --&gt;&gt; 返回o的引用&#123;name: 'xx',prop: &#123;age: 20&#125;&#125; Object.isExtensible(o);// --&gt;&gt; false Object.isSealed(o);// --&gt;&gt; true Object.isFrozen(o);// --&gt;&gt; true // o的自有属性仍然可以《扩展和修改自身属性》的值 o.prop.age = 23;// console.log(o);// --&gt;&gt; &#123;name: 'xx',prop: &#123;age: 23&#125;&#125; o.prop.name = 'son'; console.log(o);// --&gt;&gt; &#123;name: 'xx',prop: &#123;age: 23, name: 'son'&#125;&#125;","permalink":"https://codermino.github.io/2020/08/18/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%AF%B9%E8%B1%A1object/","photos":[]},{"tags":[{"name":"js学习笔记字符串string","slug":"js学习笔记字符串string","permalink":"https://codermino.github.io/tags/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%AD%97%E7%AC%A6%E4%B8%B2string/"}],"title":"js学习笔记字符串string","date":"2020/08/18","text":"创建字符串// 1 var str = new String('abc');// ---&gt;&gt; &#123;0: \"a\", 1: \"b\", 2: \"c\", length: 3&#125; typeof(str);// \"object\" // 2 var str1 = \"abc\";// ----&gt;&gt; \"abc\" typeof(str);// \"string\" console.log(str.__proto__ === str1.__proto__);// true 说明同样继承了相同的原型 console.log(str == str1);// true console.log(str === str1);// false 字符串遍历// 现有变量： var str= \"abc\";// 或者new String(\"abc\");下面结果和过程相同 var len = str.length; // 通用遍历方法示例1 --- 《for》 for(var i = 0; i &lt; len; i++)&#123; console.log(str[i]); &#125; // 通用遍历方法示例2 --- 《while》 while(len &gt;= 0)&#123; console.log(str[len]); len--; &#125; 字符串方法* charAt 返回指定位置处的字符 * toUpperCase 将字符串转换成大写 * toLowerCase 将字符串转换成小写 * indexOf 返回特定字符在字符串中第一次出现的位置，参数2为查询的起始下标，未找到则返回-1 * lastIndexOf 从后往前找。原理和结果都和indexOf一样 * search 和indexOf返回值一样。但是参数只支持一个。且这个参数可以是正则 * startsWith(x) 检测字符串是否以x开头，返回true/false * endsWith(x) 检测字符串是否以x结尾，返回true/false * substr(x, y) 从下标x开始往后截取y个字符串 包括x * substring(x, y) 从下标x截取到y,只包下标小的，不区分x和y谁大,并且结果字符串的顺序不会因为x比y大而变成倒序 * slice(x,y) 支持负数,只包下标小的,并且左面数字一定比右面要大，-1为最大下标 * split('_') 用字符串中的_来分割成多段。生成一个数组。返回值---&gt;&gt;&gt;数组 * replace(reg, 'a') str中符合正则的字符,替换为\"a\",注意：参数2可以是函数，参数1正则如果不带g标识符则只替换第一个 * match(reg) 返回符合字符串中符合正则的字符串组成的数组 * conca(s,s1) 将参数转换为字符串并依次按照顺序将其连接到自身的尾部 * trim 清空自身两边的空字符，和此类似的还有trimLeft/trimRight * charCodeAt(index) index默认为0，返回下标为index位置的字符的Unicode编码(结果是数字,且数据类型是Number类型的); * codePointAt(index) 同charCodeAt，新增的，识别方位比charCodeAt更广 charCodeAt和codePointAt// 返回字符串中下标为index位置的字符的Unicode编码(结果是数字,且数据类型是Number类型的); // 中文和中文标点符号的Unicode码是大于255的 // 中文和中文标点符号的字节长度为 2 // 英文和英文标点符号的Unicode码是小于等于255的 // 英文和英文标点符号的字节长度为 1 var abc = \"abc\"; // charCodeAt str.charCodeAt();// 97 str.charCodeAt(0);// 97 str.charCodeAt(1);// 98 // codePointAt str.codePointAt();// 97 str.codePointAt(0);// 97 str.codePointAt(1);// 98 字符串构造函数上的静态方法* String.fromCharCode和String.fromCodePoint接收一个数字参数，将其根据Unicode编码转换成字符串 String.fromCharCode和String.fromCodePoint// 接收一个数字参数，将其根据Unicode编码转换成字符串 String.fromCharCode(97);// 'a' String.fromCodePoint(97);// 'a'","permalink":"https://codermino.github.io/2020/08/18/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%AD%97%E7%AC%A6%E4%B8%B2string/","photos":[]},{"tags":[{"name":"js学习笔记之es6","slug":"js学习笔记之es6","permalink":"https://codermino.github.io/tags/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8Bes6/"}],"title":"js学习笔记之es6","date":"2020/08/17","text":"声明变量// let关键字就是用来声明变量的 // 使用let关键字声明的变量具有块级作用域 // 在一个大括号中 使用let关键字声明的变量才具有块级作用域 var关键字是不具备这个特点的 // 防止循环变量变成全局变量 // 使用let关键字声明的变量没有变量提升 // 使用let关键字声明的变量具有暂时性死区特性 /* --------let关键字就是用来声明变量的-------- */ // let a = 10; // console.log(a); /* --------使用let关键字声明的变量具有块级作用域-------- */ // if (true) &#123; // let b = 20; // console.log(b) // if (true) &#123; // let c = 30; // &#125; // console.log(c); // &#125; // console.log(b) /* -------在一个大括号中 使用let关键字声明的变量才具有块级作用域 var关键字是不具备这个特点的--------- */ // if (true) &#123; // let num = 100; // var abc = 200; // &#125; // console.log(abc); // console.log(num) /* -------防止循环变量变成全局变量--------- */ // for (let i = 0; i &lt; 2; i++) &#123;&#125; // console.log(i); /*-----使用let关键字声明的变量没有变量提升------*/ // console.log(a); // let a = 100; /* -------使用let关键字声明的变量具有暂时性死区特性------- */ var num = 10 if (true) &#123; console.log(num); let num = 20; &#125; const常量// 使用const关键字声明的常量具有块级作用域 // if (true) &#123; // const a = 10; // if (true) &#123; // const a = 20; // console.log(a); // &#125; // console.log(a); // &#125; // console.log(a); // 使用const关键字声明的常量必须赋初始值 // const PI = 3.14; // 常量声明后值不可更改 const PI = 3.14; // PI = 100; const ary = [100, 200]; ary[0] = 123; ary = [1, 2] console.log(ary); 数组解构// 数组解构允许我们按照一一对应的关系从数组中提取值 然后将值赋值给变量 let ary = [1,2,3]; let [a, b, c, d, e] = ary; console.log(a) console.log(b) console.log(c) console.log(d) console.log(e) 对象解构// 对象解构允许我们使用变量的名字匹配对象的属性 匹配成功 将对象属性的值赋值给变量 let person = &#123;name: 'lisi', age: 30, sex: '男'&#125;; // let &#123; name, age, sex &#125; = person; // console.log(name) // console.log(age) // console.log(sex) let &#123;name: myName&#125; = person; console.log(myName) 箭头函数// 箭头函数是用来简化函数定义语法的 // const fn = () =&gt; &#123; // console.log(123) // &#125; // fn(); // 在箭头函数中 如果函数体中只有一句代码 并且代码的执行结果就是函数的返回值 函数体大括号可以省略 // const sum = (n1, n2) =&gt; n1 + n2; // const result = sum(10, 20); // console.log(result) // 在箭头函数中 如果形参只有一个 形参外侧的小括号也是可以省略的 // const fn = v =&gt; &#123; // alert(v); // &#125; // fn(20) // 箭头函数不绑定this 箭头函数没有自己的this关键字 如果在箭头函数中使用this this关键字将指向箭头函数定义位置中的this function fn () &#123; console.log(this); return () =&gt; &#123; console.log(this) &#125; &#125; const obj = &#123;name: 'zhangsan'&#125;; const resFn = fn.call(obj); resFn(); 箭头函数面试题var age = 100; let obj = &#123; age: 20, say: () =&gt; &#123; console.log(this); alert(this.age) &#125; &#125;; obj.say(); 剩余参数// const sum = (...args) =&gt; &#123; // let total = 0; // args.forEach(item =&gt; total += item); // return total; // &#125;; // console.log(sum(10, 20)); // console.log(sum(10, 20, 30)); let ary1 = ['张三' , '李四', '王五']; let [s1, ...s2] = ary1; console.log(s1) console.log(s2) 拓展运算符// 扩展运算符可以将数组拆分成以逗号分隔的参数序列 // let ary = [\"a\", \"b\", \"c\"]; // ...ary // \"a\", \"b\", \"c\" // console.log(...ary) // console.log(\"a\", \"b\", \"c\") // 扩展运算符应用于数组合并 // let ary1 = [1, 2, 3]; // let ary2 = [4, 5, 6]; // // ...ary1 // 1, 2, 3 // // ...ary1 // 4, 5, 6 // let ary3 = [...ary1, ...ary2]; // console.log(ary3) // 合并数组的第二种方法 // let ary1 = [1, 2, 3]; // let ary2 = [4, 5, 6]; // ary1.push(...ary2); // console.log(ary1) // 利用扩展运算符将伪数组转换为真正的数组 var oDivs = document.getElementsByTagName('div'); console.log(oDivs) var ary = [...oDivs]; ary.push('a'); console.log(ary); from方法(从一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例)// var arrayLike = &#123; // \"0\": \"张三\", // \"1\": \"李四\", // \"2\": \"王五\", // \"length\": 3 // &#125; // var ary = Array.from(arrayLike); // console.log(ary) var arrayLike = &#123; \"0\": \"1\", \"1\": \"2\", \"length\": 2 &#125; var ary = Array.from(arrayLike, item =&gt; item * 2) console.log(ary) find方法var ary = [&#123; id: 1, name: '张三' &#125;, &#123; id: 2, name: '李四' &#125;]; let target = ary.find(item =&gt; item.id === 3); console.log(target) findIndex方法let ary = [10, 20, 50]; let index = ary.findIndex(item =&gt; item &gt; 15); console.log(index) includes方法let ary = [\"a\", \"b\", \"c\"]; let result = ary.includes('a') console.log(result) result = ary.includes('e') console.log(result) 模板字符串// let name = `张三`; // let sayHello = `Hello, 我的名字叫$&#123;name&#125;`; // console.log(sayHello); // let result = &#123; // name: \"zhangsan\", // age: 20 // &#125;; // let html = ` // &lt;div&gt; // &lt;span&gt;$&#123;result.name&#125;&lt;/span&gt; // &lt;span&gt;$&#123;result.age&#125;&lt;/span&gt; // &lt;/div&gt; // `; // console.log(html); const fn = () =&gt; &#123; return '我是fn函数' &#125; let html = `我是模板字符串 $&#123;fn()&#125;`; console.log(html) startsWith和endsWithlet str = 'Hello ECMAScript 2015'; let r1 = str.startsWith('Hello'); console.log(r1); let r2 = str.endsWith('2016'); console.log(r2) repeat方法console.log(\"y\".repeat(5)) set方法// const s1 = new Set(); // console.log(s1.size) // const s2 = new Set([\"a\", \"b\"]); // console.log(s2.size) // const s3 = new Set([\"a\",\"a\",\"b\",\"b\"]); // console.log(s3.size) // const ary = [...s3]; // console.log(ary) // const s4 = new Set(); // 向set结构中添加值 使用add方法 // s4.add('a').add('b'); // console.log(s4.size) // 从set结构中删除值 用到的方法是delete // const r1 = s4.delete('c'); // console.log(s4.size) // console.log(r1); // 判断某一个值是否是set数据结构中的成员 使用has // const r2 = s4.has('d'); // console.log(r2) // 清空set数据结构中的值 使用clear方法 // s4.clear(); // console.log(s4.size); // 遍历set数据结构 从中取值 const s5 = new Set(['a', 'b', 'c']); s5.forEach(value =&gt; &#123; console.log(value) &#125;)","permalink":"https://codermino.github.io/2020/08/17/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8Bes6/","photos":[]},{"tags":[{"name":"js学习笔记之正则表达式","slug":"js学习笔记之正则表达式","permalink":"https://codermino.github.io/tags/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}],"title":"js学习笔记之正则表达式","date":"2020/08/17","text":"正则// 正则表达式在js中的使用 // 1. 利用 RegExp对象来创建 正则表达式 var regexp = new RegExp(/123/); console.log(regexp); // 2. 利用字面量创建 正则表达式 var rg = /123/; // 3.test 方法用来检测字符串是否符合正则表达式要求的规范 console.log(rg.test(123)); console.log(rg.test('abc')); 边界值// 边界符 ^ $ var rg = /abc/; // 正则表达式里面不需要加引号 不管是数字型还是字符串型 // /abc/ 只要包含有abc这个字符串返回的都是true console.log(rg.test('abc')); console.log(rg.test('abcd')); console.log(rg.test('aabcd')); console.log('---------------------------'); var reg = /^abc/; console.log(reg.test('abc')); // true console.log(reg.test('abcd')); // true console.log(reg.test('aabcd')); // false console.log('---------------------------'); var reg1 = /^abc$/; // 精确匹配 要求必须是 abc字符串才符合规范 console.log(reg1.test('abc')); // true console.log(reg1.test('abcd')); // false console.log(reg1.test('aabcd')); // false console.log(reg1.test('abcabc')); // false 字符类//var rg = /abc/; 只要包含abc就可以 // 字符类: [] 表示有一系列字符可供选择，只要匹配其中一个就可以了 var rg = /[abc]/; // 只要包含有a 或者 包含有b 或者包含有c 都返回为true console.log(rg.test('andy')); console.log(rg.test('baby')); console.log(rg.test('color')); console.log(rg.test('red')); var rg1 = /^[abc]$/; // 三选一 只有是a 或者是 b 或者是c 这三个字母才返回 true console.log(rg1.test('aa')); console.log(rg1.test('a')); console.log(rg1.test('b')); console.log(rg1.test('c')); console.log(rg1.test('abc')); console.log('------------------'); var reg = /^[a-z]$/; // 26个英文字母任何一个字母返回 true - 表示的是a 到z 的范围 console.log(reg.test('a')); console.log(reg.test('z')); console.log(reg.test(1)); console.log(reg.test('A')); // 字符组合 var reg1 = /^[a-zA-Z0-9_-]$/; // 26个英文字母(大写和小写都可以)任何一个字母返回 true console.log(reg1.test('a')); console.log(reg1.test('B')); console.log(reg1.test(8)); console.log(reg1.test('-')); console.log(reg1.test('_')); console.log(reg1.test('!')); console.log('----------------'); // 如果中括号里面有^ 表示取反的意思 千万和 我们边界符 ^ 别混淆 var reg2 = /^[^a-zA-Z0-9_-]$/; console.log(reg2.test('a')); console.log(reg2.test('B')); console.log(reg2.test(8)); console.log(reg2.test('-')); console.log(reg2.test('_')); console.log(reg2.test('!')); 量词// 量词符: 用来设定某个模式出现的次数 // 简单理解: 就是让下面的a这个字符重复多少次 // var reg = /^a$/; // * 相当于 &gt;= 0 可以出现0次或者很多次 // var reg = /^a*$/; // console.log(reg.test('')); // console.log(reg.test('a')); // console.log(reg.test('aaaa')); // + 相当于 &gt;= 1 可以出现1次或者很多次 // var reg = /^a+$/; // console.log(reg.test('')); // false // console.log(reg.test('a')); // true // console.log(reg.test('aaaa')); // true // ? 相当于 1 || 0 // var reg = /^a?$/; // console.log(reg.test('')); // true // console.log(reg.test('a')); // true // console.log(reg.test('aaaa')); // false // &#123;3 &#125; 就是重复3次 // var reg = /^a&#123;3&#125;$/; // console.log(reg.test('')); // false // console.log(reg.test('a')); // false // console.log(reg.test('aaaa')); // false // console.log(reg.test('aaa')); // true // &#123;3, &#125; 大于等于3 var reg = /^a&#123;3,&#125;$/; console.log(reg.test('')); // false console.log(reg.test('a')); // false console.log(reg.test('aaaa')); // true console.log(reg.test('aaa')); // true // &#123;3,16&#125; 大于等于3 并且 小于等于16 var reg = /^a&#123;3,6&#125;$/; console.log(reg.test('')); // false console.log(reg.test('a')); // false console.log(reg.test('aaaa')); // true console.log(reg.test('aaa')); // true console.log(reg.test('aaaaaaa')); // false 用户名验证// 量词是设定某个模式出现的次数 var reg = /^[a-zA-Z0-9_-]&#123;6,16&#125;$/; // 这个模式用户只能输入英文字母 数字 下划线 短横线但是有边界符和[] 这就限定了只能多选1 // &#123;6,16&#125; 中间不要有空格 // console.log(reg.test('a')); // console.log(reg.test('8')); // console.log(reg.test('18')); // console.log(reg.test('aa')); // console.log('-------------'); // console.log(reg.test('andy-red')); // console.log(reg.test('andy_red')); // console.log(reg.test('andy007')); // console.log(reg.test('andy!007')); var uname = document.querySelector('.uname'); var span = document.querySelector('span'); uname.onblur = function() &#123; if (reg.test(this.value)) &#123; console.log('正确的'); span.className = 'right'; span.innerHTML = '用户名格式输入正确'; &#125; else &#123; console.log('错误的'); span.className = 'wrong'; span.innerHTML = '用户名格式输入不正确'; &#125; &#125; 括号总结// 中括号 字符集合.匹配方括号中的任意字符. // var reg = /^[abc]$/; // a 也可以 b 也可以 c 可以 a ||b || c // 大括号 量词符. 里面表示重复次数 // var reg = /^abc&#123;3&#125;$/; // 它只是让c重复三次 abccc // console.log(reg.test('abc')); // console.log(reg.test('abcabcabc')); // console.log(reg.test('abccc')); // 小括号 表示优先级 var reg = /^(abc)&#123;3&#125;$/; // 它是让abc重复三次 console.log(reg.test('abc')); console.log(reg.test('abcabcabc')); console.log(reg.test('abccc')); 座机号码验证// 座机号码验证: 全国座机号码 两种格式: 010-12345678 或者 0530-1234567 // 正则里面的或者 符号 | // var reg = /^\\d&#123;3&#125;-\\d&#123;8&#125;|\\d&#123;4&#125;-\\d&#123;7&#125;$/; var reg = /^\\d&#123;3,4&#125;-\\d&#123;7,8&#125;$/; 替换// 替换 replace // var str = 'andy和red'; // // var newStr = str.replace('andy', 'baby'); // var newStr = str.replace(/andy/, 'baby'); // console.log(newStr); var text = document.querySelector('textarea'); var btn = document.querySelector('button'); var div = document.querySelector('div'); btn.onclick = function() &#123; div.innerHTML = text.value.replace(/激情|gay/g, '**'); &#125;","permalink":"https://codermino.github.io/2020/08/17/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","photos":[]},{"tags":[{"name":"js学习笔记之数组方法","slug":"js学习笔记之数组方法","permalink":"https://codermino.github.io/tags/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"}],"title":"js学习笔记之数组方法","date":"2020/08/17","text":"原型// 1. 构造函数的问题. function Star(uname, age) &#123; this.uname = uname; this.age = age; // this.sing = function() &#123; // console.log('我会唱歌'); // &#125; &#125; Star.prototype.sing = function() &#123; console.log('我会唱歌'); &#125; var ldh = new Star('刘德华', 18); var zxy = new Star('张学友', 19); console.log(ldh.sing === zxy.sing); // console.dir(Star); ldh.sing(); zxy.sing(); // 2. 一般情况下,我们的公共属性定义到构造函数里面, 公共的方法我们放到原型对象身上 对象原型function Star(uname, age) &#123; this.uname = uname; this.age = age; &#125; Star.prototype.sing = function() &#123; console.log('我会唱歌'); &#125; var ldh = new Star('刘德华', 18); var zxy = new Star('张学友', 19); ldh.sing(); console.log(ldh); // 对象身上系统自己添加一个 __proto__ 指向我们构造函数的原型对象 prototype console.log(ldh.__proto__ === Star.prototype); // 方法的查找规则: 首先先看ldh 对象身上是否有 sing 方法,如果有就执行这个对象上的sing // 如果么有sing 这个方法,因为有__proto__ 的存在,就去构造函数原型对象prototype身上去查找sing这个方法 原型constructorfunction Star(uname, age) &#123; this.uname = uname; this.age = age; &#125; // 很多情况下,我们需要手动的利用constructor 这个属性指回 原来的构造函数 // Star.prototype.sing = function() &#123; // console.log('我会唱歌'); // &#125;; // Star.prototype.movie = function() &#123; // console.log('我会演电影'); // &#125; Star.prototype = &#123; // 如果我们修改了原来的原型对象,给原型对象赋值的是一个对象,则必须手动的利用constructor指回原来的构造函数 constructor: Star, sing: function() &#123; console.log('我会唱歌'); &#125;, movie: function() &#123; console.log('我会演电影'); &#125; &#125; var ldh = new Star('刘德华', 18); var zxy = new Star('张学友', 19); console.log(Star.prototype); console.log(ldh.__proto__); console.log(Star.prototype.constructor); console.log(ldh.__proto__.constructor); 原型链function Star(uname, age) &#123; this.uname = uname; this.age = age; &#125; Star.prototype.sing = function() &#123; console.log('我会唱歌'); &#125; var ldh = new Star('刘德华', 18); // 1. 只要是对象就有__proto__ 原型, 指向原型对象 console.log(Star.prototype); console.log(Star.prototype.__proto__ === Object.prototype); // 2.我们Star原型对象里面的__proto__原型指向的是 Object.prototype console.log(Object.prototype.__proto__); // 3. 我们Object.prototype原型对象里面的__proto__原型 指向为 null 原型链查找规则function Star(uname, age) &#123; this.uname = uname; this.age = age; &#125; Star.prototype.sing = function() &#123; console.log('我会唱歌'); &#125; Star.prototype.sex = '女'; // Object.prototype.sex = '男'; var ldh = new Star('刘德华', 18); ldh.sex = '男'; console.log(ldh.sex); console.log(Object.prototype); console.log(ldh); console.log(Star.prototype); console.log(ldh.toString()); 拓展方法// 原型对象的应用 扩展内置对象方法 Array.prototype.sum = function() &#123; var sum = 0; for (var i = 0; i &lt; this.length; i++) &#123; sum += this[i]; &#125; return sum; &#125;; var arr = [1, 2, 3]; console.log(arr.sum()); console.log(Array.prototype); var arr1 = new Array(11, 22, 33); console.log(arr1.sum()); call方法// call 方法 function fn(x, y) &#123; console.log('我想喝手磨咖啡'); console.log(this); console.log(x + y); &#125; var o = &#123; name: 'andy' &#125;; // fn(); // 1. call() 可以调用函数 // fn.call(); // 2. call() 可以改变这个函数的this指向 此时这个函数的this 就指向了o这个对象 fn.call(o, 1, 2); 借助构造函数继承属性// 借用父构造函数继承属性 // 1. 父构造函数 function Father(uname, age) &#123; // this 指向父构造函数的对象实例 this.uname = uname; this.age = age; &#125; // 2 .子构造函数 function Son(uname, age, score) &#123; // this 指向子构造函数的对象实例 Father.call(this, uname, age); this.score = score; &#125; var son = new Son('刘德华', 18, 100); console.log(son); 结束原型继承方法// 借用父构造函数继承属性 // 1. 父构造函数 function Father(uname, age) &#123; // this 指向父构造函数的对象实例 this.uname = uname; this.age = age; &#125; Father.prototype.money = function() &#123; console.log(100000); &#125;; // 2 .子构造函数 function Son(uname, age, score) &#123; // this 指向子构造函数的对象实例 Father.call(this, uname, age); this.score = score; &#125; // Son.prototype = Father.prototype; 这样直接赋值会有问题,如果修改了子原型对象,父原型对象也会跟着一起变化 Son.prototype = new Father(); // 如果利用对象的形式修改了原型对象,别忘了利用constructor 指回原来的构造函数 Son.prototype.constructor = Son; // 这个是子构造函数专门的方法 Son.prototype.exam = function() &#123; console.log('孩子要考试'); &#125; var son = new Son('刘德华', 18, 100); console.log(son); console.log(Father.prototype); console.log(Son.prototype.constructor); 类的本质// ES6 之前通过 构造函数+ 原型实现面向对象 编程 // (1) 构造函数有原型对象prototype // (2) 构造函数原型对象prototype 里面有constructor 指向构造函数本身 // (3) 构造函数可以通过原型对象添加方法 // (4) 构造函数创建的实例对象有__proto__ 原型指向 构造函数的原型对象 // ES6 通过 类 实现面向对象编程 class Star &#123; &#125; console.log(typeof Star); // 1. 类的本质其实还是一个函数 我们也可以简单的认为 类就是 构造函数的另外一种写法 // (1) 类有原型对象prototype console.log(Star.prototype); // (2) 类原型对象prototype 里面有constructor 指向类本身 console.log(Star.prototype.constructor); // (3)类可以通过原型对象添加方法 Star.prototype.sing = function() &#123; console.log('冰雨'); &#125; var ldh = new Star(); console.dir(ldh); // (4) 类创建的实例对象有__proto__ 原型指向 类的原型对象 console.log(ldh.__proto__ === Star.prototype); i = i + 1; i++ foreach方法// forEach 迭代(遍历) 数组 var arr = [1, 2, 3]; var sum = 0; arr.forEach(function(value, index, array) &#123; console.log('每个数组元素' + value); console.log('每个数组元素的索引号' + index); console.log('数组本身' + array); sum += value; &#125;) console.log(sum); filter方法// filter 筛选数组 var arr = [12, 66, 4, 88, 3, 7]; var newArr = arr.filter(function(value, index) &#123; // return value &gt;= 20; return value % 2 === 0; &#125;); console.log(newArr); some函数// some 查找数组中是否有满足条件的元素 // var arr = [10, 30, 4]; // var flag = arr.some(function(value) &#123; // // return value &gt;= 20; // return value &lt; 3; // &#125;); // console.log(flag); var arr1 = ['red', 'pink', 'blue']; var flag1 = arr1.some(function(value) &#123; return value === 'pink'; &#125;); console.log(flag1); // 1. filter 也是查找满足条件的元素 返回的是一个数组 而且是把所有满足条件的元素返回回来 // 2. some 也是查找满足条件的元素是否存在 返回的是一个布尔值 如果查找到第一个满足条件的元素就终止循环 foreach和some的区别var arr = ['red', 'green', 'blue', 'pink']; // 1. forEach迭代 遍历 // arr.forEach(function(value) &#123; // if (value == 'green') &#123; // console.log('找到了该元素'); // return true; // 在forEach 里面 return 不会终止迭代 // &#125; // console.log(11); // &#125;) // 如果查询数组中唯一的元素, 用some方法更合适, arr.some(function(value) &#123; if (value === 'green') &#123; console.log('找到了该元素'); return true; // 在some 里面 遇到 return true 就是终止遍历 迭代效率更高 &#125; console.log(11); &#125;); // arr.filter(function(value) &#123; // if (value == 'green') &#123; // console.log('找到了该元素'); // return true; // // filter 里面 return 不会终止迭代 // &#125; // console.log(11); // &#125;); trim方法删除两边的空格// trim 方法去除字符串两侧空格 var str = ' an dy '; console.log(str); var str1 = str.trim(); console.log(str1); var input = document.querySelector('input'); var btn = document.querySelector('button'); var div = document.querySelector('div'); btn.onclick = function() &#123; var str = input.value.trim(); if (str === '') &#123; alert('请输入内容'); &#125; else &#123; console.log(str); console.log(str.length); div.innerHTML = str; &#125; &#125; Object.keys遍历对象// 用于获取对象自身所有的属性 var obj = &#123; id: 1, pname: '小米', price: 1999, num: 2000 &#125;; var arr = Object.keys(obj); console.log(arr); arr.forEach(function(value) &#123; console.log(value); &#125;) Object.defineProperty() 定义新属性或修改原有的属性// Object.defineProperty() 定义新属性或修改原有的属性 var obj = &#123; id: 1, pname: '小米', price: 1999 &#125;; // 1. 以前的对象添加和修改属性的方式 // obj.num = 1000; // obj.price = 99; // console.log(obj); // 2. Object.defineProperty() 定义新属性或修改原有的属性 Object.defineProperty(obj, 'num', &#123; value: 1000, enumerable: true &#125;); console.log(obj); Object.defineProperty(obj, 'price', &#123; value: 9.9 &#125;); console.log(obj); Object.defineProperty(obj, 'id', &#123; // 如果值为false 不允许修改这个属性值 默认值也是false writable: false, &#125;); obj.id = 2; console.log(obj); Object.defineProperty(obj, 'address', &#123; value: '中国山东蓝翔技校xx单元', // 如果只为false 不允许修改这个属性值 默认值也是false writable: false, // enumerable 如果值为false 则不允许遍历, 默认的值是 false enumerable: false, // configurable 如果为false 则不允许删除这个属性 不允许在修改第三个参数里面的特性 默认为false configurable: false &#125;); console.log(obj); console.log(Object.keys(obj)); delete obj.address; console.log(obj); delete obj.pname; console.log(obj); Object.defineProperty(obj, 'address', &#123; value: '中国山东蓝翔技校xx单元', // 如果值为false 不允许修改这个属性值 默认值也是false writable: true, // enumerable 如果值为false 则不允许遍历, 默认的值是 false enumerable: true, // configurable 如果为false 则不允许删除这个属性 默认为false configurable: true &#125;); console.log(obj.address); get和set// 存取描述符 var store = &#123;name: 'xx'&#125;; var o = &#123;&#125;; Object.defineProperty(o, 'name', &#123; get: function() &#123;// 定义属性值，读取o.name时执行的函数 return store.name; &#125;, set: function(v) &#123; // 在这里可以搞事情，做一些判断。来决定是否进行赋值更改 store.name = v;// 定义赋值操作。在给o.name赋值时执行的函数。 &#125;, enumerable: true,// 是否可以被枚举。true时在for in循环中可以被枚举到 configurable: false// 特性是否可以被修改，如值是false，则不可逆，也就是之后无法再次更改任何特性信息 &#125;) console.log(o); o.name = 'zhangsan'; console.log(o);","permalink":"https://codermino.github.io/2020/08/17/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/","photos":[]},{"tags":[{"name":"js学习笔记之函数","slug":"js学习笔记之函数","permalink":"https://codermino.github.io/tags/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%87%BD%E6%95%B0/"}],"title":"js学习笔记之函数","date":"2020/08/17","text":"函数的this指向问题`&lt;button&gt;点击&lt;/button&gt;` `&lt;script&gt;` // 函数的不同调用方式决定了this 的指向不同 // 1. 普通函数 this 指向window function fn() &#123; console.log('普通函数的this' + this); &#125; window.fn(); // 2. 对象的方法 this指向的是对象 o var o = &#123; sayHi: function() &#123; console.log('对象方法的this:' + this); &#125; &#125; o.sayHi(); // 3. 构造函数 this 指向 ldh 这个实例对象 原型对象里面的this 指向的也是 ldh这个实例对象 function Star() &#123;&#125;; Star.prototype.sing = function() &#123; &#125; var ldh = new Star(); // 4. 绑定事件函数 this 指向的是函数的调用者 btn这个按钮对象 var btn = document.querySelector('button'); btn.onclick = function() &#123; console.log('绑定时间函数的this:' + this); &#125;; // 5. 定时器函数 this 指向的也是window window.setTimeout(function() &#123; console.log('定时器的this:' + this); &#125;, 1000); // 6. 立即执行函数 this还是指向window (function() &#123; console.log('立即执行函数的this' + this); &#125;)(); `&lt;/script&gt;` call函数,改变this指向// 改变函数内this指向 js提供了三种方法 call() apply() bind() // 1. call() var o = &#123; name: 'andy' &#125; function fn(a, b) &#123; console.log(this); console.log(a + b); &#125;; fn.call(o, 1, 2); // call 第一个可以调用函数 第二个可以改变函数内的this 指向 // call 的主要作用可以实现继承 function Father(uname, age, sex) &#123; this.uname = uname; this.age = age; this.sex = sex; &#125; function Son(uname, age, sex) &#123; Father.call(this, uname, age, sex); console.log(this.uname); &#125; var son = new Son('刘德华', 18, '男'); console.log(son); apply函数，改变this指向// 改变函数内this指向 js提供了三种方法 call() apply() bind() // 2. apply() 应用 运用的意思 var o = &#123; name: 'andy' &#125;; function fn(arr) &#123; console.log(this); console.log(arr); // 'pink' &#125;; fn.apply(o, ['pink']); // 1. 也是调用函数 第二个可以改变函数内部的this指向 // 2. 但是他的参数必须是数组(伪数组) // 3. apply 的主要应用 比如说我们可以利用 apply 借助于数学内置对象求数组最大值 // Math.max(); var arr = [1, 66, 3, 99, 4]; var arr1 = ['red', 'pink']; // var max = Math.max.apply(null, arr); var max = Math.max.apply(Math, arr); var min = Math.min.apply(Math, arr); console.log(max, min); bind函数改变this指向`&lt;button&gt;点击&lt;/button&gt;` `&lt;button&gt;点击&lt;/button&gt;` `&lt;button&gt;点击&lt;/button&gt;` `&lt;script&gt;` // 改变函数内this指向 js提供了三种方法 call() apply() bind() // 3. bind() 绑定 捆绑的意思 var o = &#123; name: 'andy' &#125;; function fn(a, b) &#123; console.log(this); console.log(a + b); &#125;; var f = fn.bind(o, 1, 2); f(); // 1. 不会调用原来的函数 可以改变原来函数内部的this 指向 // 2. 返回的是原函数改变this之后产生的新函数 // 3. 如果有的函数我们不需要立即调用,但是又想改变这个函数内部的this指向此时用bind // 4. 我们有一个按钮,当我们点击了之后,就禁用这个按钮,3秒钟之后开启这个按钮 // var btn1 = document.querySelector('button'); // btn1.onclick = function() &#123; // this.disabled = true; // 这个this 指向的是 btn 这个按钮 // // var that = this; // setTimeout(function() &#123; // // that.disabled = false; // 定时器函数里面的this 指向的是window // this.disabled = false; // 此时定时器函数里面的this 指向的是btn // &#125;.bind(this), 3000); // 这个this 指向的是btn 这个对象 // &#125; var btns = document.querySelectorAll('button'); for (var i = 0; i &lt; btns.length; i++) &#123; btns[i].onclick = function() &#123; this.disabled = true; setTimeout(function() &#123; this.disabled = false; &#125;.bind(this), 2000); &#125; &#125; `&lt;/script&gt;` callback高阶函数// 高阶函数- 函数可以作为参数传递 function fn(a, b, callback) &#123; console.log(a + b); callback &amp;&amp; callback(); &#125; fn(1, 2, function() &#123; console.log('我是最后调用的'); &#125;); $(\"div\").animate(&#123; left: 500 &#125;, function() &#123; $(\"div\").css(\"backgroundColor\", \"purple\"); &#125;) 闭包// 闭包（closure）指有权访问另一个函数作用域中变量的函数。 // 闭包: 我们fun 这个函数作用域 访问了另外一个函数 fn 里面的局部变量 num function fn() &#123; var num = 10; function fun() &#123; console.log(num); &#125; fun(); &#125; fn(); 闭包的作用// 闭包（closure）指有权访问另一个函数作用域中变量的函数。 // 一个作用域可以访问另外一个函数的局部变量 // 我们fn 外面的作用域可以访问fn 内部的局部变量 // 闭包的主要作用: 延伸了变量的作用范围 function fn() &#123; var num = 10; // function fun() &#123; // console.log(num); // &#125; // return fun; return function() &#123; console.log(num); &#125; &#125; var f = fn(); f(); // 类似于 // var f = function() &#123; // console.log(num); // &#125; // var f = function fun() &#123; // console.log(num); // &#125; 闭包的应用Demo// 闭包应用-计算打车价格 // 打车起步价13(3公里内), 之后每多一公里增加 5块钱. 用户输入公里数就可以计算打车价格 // 如果有拥堵情况,总价格多收取10块钱拥堵费 function fn() &#123;&#125;; fn(); var car = (function() &#123; var start = 13; // 起步价 局部变量 var total = 0; // 总价 局部变量 return &#123; // 正常的总价 price: function(n) &#123; if (n &lt;= 3) &#123; total = start; &#125; else &#123; total = start + (n - 3) * 5 &#125; return total; &#125;, // 拥堵之后的费用 yd: function(flag) &#123; return flag ? total + 10 : total; &#125; &#125; &#125;)(); console.log(car.price(5)); // 23 console.log(car.yd(true)); // 33 console.log(car.price(1)); // 13 console.log(car.yd(false)); // 13 let car2 = function() &#123; let start = 13; // 起步价 局部变量 let total = 0; // 总价 局部变量 return &#123; // 正常的总价 price: function(n) &#123; if (n &lt;= 3) &#123; total = start; &#125; else &#123; total = start + (n - 3) * 5 &#125; return total; &#125;, // 拥堵之后的费用 yd: function(flag) &#123; return flag ? total + 10 : total; &#125; &#125; &#125;; const &#123;price,yd&#125; = car2(); console.log(price(5)); console.log(yd(true)); console.log(price(1)); console.log(yd(false)); 利用递归遍历数组var data = [&#123; id: 1, name: '家电', goods: [&#123; id: 11, gname: '冰箱', goods: [&#123; id: 111, gname: '海尔' &#125;, &#123; id: 112, gname: '美的' &#125;, ] &#125;, &#123; id: 12, gname: '洗衣机' &#125;] &#125;, &#123; id: 2, name: '服饰' &#125;]; // 我们想要做输入id号,就可以返回的数据对象 // 1. 利用 forEach 去遍历里面的每一个对象 function getID(json, id) &#123; var o = &#123;&#125;; json.forEach(function(item) &#123; // console.log(item); // 2个数组元素 if (item.id === id) &#123; // console.log(item); o = item; // 2. 我们想要得里层的数据 11 12 可以利用递归函数 // 里面应该有goods这个数组并且数组的长度不为 0 &#125; else if (item.goods &amp;&amp; item.goods.length &gt; 0) &#123; o = getID(item.goods, id); &#125; &#125;); return o; &#125; console.log(getID(data, 1)); console.log(getID(data, 2)); console.log(getID(data, 11)); console.log(getID(data, 12)); console.log(getID(data, 111)); 浅拷贝// 浅拷贝只是拷贝一层, 更深层次对象级别的只拷贝引用. // 深拷贝拷贝多层, 每一级别的数据都会拷贝. var obj = &#123; id: 1, name: 'andy', msg: &#123; age: 18 &#125; &#125;; var o = &#123;&#125;; // for (var k in obj) &#123; // // k 是属性名 obj[k] 属性值 // o[k] = obj[k]; // &#125; // console.log(o); // o.msg.age = 20; // console.log(obj); console.log('--------------'); Object.assign(o, obj); console.log(o); o.msg.age = 20; console.log(obj); console.log('--------------'); Object.assign(o, obj); console.log(o); o.msg.age = 20; console.log(obj); let o2 = &#123;...obj&#125;; console.log(o2); o2.msg.age = 30; console.log(obj); 深拷贝// 深拷贝拷贝多层, 每一级别的数据都会拷贝. var obj = &#123; id: 1, name: 'andy', msg: &#123; age: 18 &#125;, color: ['pink', 'red'] &#125;; var o = &#123;&#125;; // 封装函数 function deepCopy(newobj, oldobj) &#123; for (var k in oldobj) &#123; // 判断我们的属性值属于那种数据类型 // 1. 获取属性值 oldobj[k] var item = oldobj[k]; // 2. 判断这个值是否是数组 if (item instanceof Array) &#123; newobj[k] = []; deepCopy(newobj[k], item) &#125; else if (item instanceof Object) &#123; // 3. 判断这个值是否是对象 newobj[k] = &#123;&#125;; deepCopy(newobj[k], item) &#125; else &#123; // 4. 属于简单数据类型 newobj[k] = item; &#125; &#125; &#125; deepCopy(o, obj); console.log(o); var arr = []; console.log(arr instanceof Object); o.msg.age = 20; console.log(obj); function deepCopy2(target)&#123; let copyed_objs = [];//此数组解决了循环引用和相同引用的问题，它存放已经递归到的目标对象 function _deepCopy(target)&#123; if((typeof target !== 'object')||!target)&#123;return target;&#125; for(let i= 0 ;i&lt;copyed_objs.length;i++)&#123; if(copyed_objs[i].target === target)&#123; return copyed_objs[i].copyTarget; &#125; &#125; let obj = &#123;&#125;; if(Array.isArray(target))&#123; obj = [];//处理target是数组的情况 &#125; copyed_objs.push(&#123;target:target,copyTarget:obj&#125;); Object.keys(target).forEach(key=&gt;&#123; if(obj[key])&#123; return;&#125; obj[key] = _deepCopy(target[key]); &#125;); return obj; &#125; return _deepCopy(target); &#125; let o2 = deepCopy2(o); console.log(o2); o2.msg.age = 20; console.log(obj);","permalink":"https://codermino.github.io/2020/08/17/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%87%BD%E6%95%B0/","photos":[]},{"tags":[{"name":"js学习笔记之类","slug":"js学习笔记之类","permalink":"https://codermino.github.io/tags/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%B1%BB/"}],"title":"js学习笔记之类","date":"2020/08/17","text":"创建类// 1. 创建类 class 创建一个 明星类 class Star &#123; constructor(uname, age) &#123; this.uname = uname; this.age = age; &#125; &#125; // 2. 利用类创建对象 new let ldh = new Star('刘德华', 18); let zxy = new Star('张学友', 20); console.log(ldh); console.log(zxy); (1) 通过class 关键字创建类, 类名我们还是习惯性定义首字母大写 (2) 类里面有个constructor 函数,可以接受传递过来的参数,同时返回实例对象 (3) constructor 函数 只要 new 生成实例时,就会自动调用这个函数, 如果我们不写这个函数,类也会自动生成这个函数 (4) 生成实例 new 不能省略 (5) 最后注意语法规范, 创建类 类名后面不要加小括号,生成实例 类名后面加小括号, 构造函数不需要加function 向类中添加方法// 1. 创建类 class 创建一个 明星类 class Star &#123; // 类的共有属性放到 constructor 里面 constructor(uname, age) &#123; this.uname = uname; this.age = age; &#125; sing(song) &#123; // console.log('我唱歌'); console.log(this.uname + song); &#125; &#125; // 2. 利用类创建对象 new var ldh = new Star('刘德华', 18); var zxy = new Star('张学友', 20); console.log(ldh); console.log(zxy); // (1) 我们类里面所有的函数不需要写function //(2) 多个函数方法之间不需要添加逗号分隔 ldh.sing('冰雨'); zxy.sing('李香兰'); 类的继承class Father &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; sum() &#123; console.log(this.x + this.y); &#125; &#125; class Son extends Father &#123; constructor(x, y) &#123; super(x, y); //调用了父类中的构造函数 &#125; &#125; var son = new Son(1, 2); var son1 = new Son(11, 22); son.sum(); son1.sum(); 调用父函数的方法// super 关键字调用父类普通函数 class Father &#123; say() &#123; return '我是爸爸'; &#125; &#125; class Son extends Father &#123; say() &#123; // console.log('我是儿子'); console.log(super.say() + '的儿子'); // super.say() 就是调用父类中的普通函数 say() &#125; &#125; var son = new Son(); son.say(); // 继承中的属性或者方法查找原则: 就近原则 // 1. 继承中,如果实例化子类输出一个方法,先看子类有没有这个方法,如果有就先执行子类的 // 2. 继承中,如果子类里面没有,就去查找父类有没有这个方法,如果有,就执行父类的这个方法(就近原则) 拓展子类的方法 // 父类有加法方法 class Father &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; sum() &#123; console.log(this.x + this.y); &#125; &#125; // 子类继承父类加法方法 同时 扩展减法方法 class Son extends Father &#123; constructor(x, y) &#123; // 利用super 调用父类的构造函数 // super 必须在子类this之前调用 super(x, y); this.x = x; this.y = y; &#125; subtract() &#123; console.log(this.x - this.y); &#125; &#125; var son = new Son(5, 3); son.subtract(); son.sum(); this指向问题`&lt;button&gt;点击&lt;/button&gt;` `&lt;script&gt;` var that; var _that; class Star &#123; constructor(uname, age) &#123; // constructor 里面的this 指向的是 创建的实例对象 that = this; console.log(this); this.uname = uname; this.age = age; // this.sing(); this.btn = document.querySelector('button'); this.btn.onclick = this.sing; &#125; sing() &#123; // 这个sing方法里面的this 指向的是 btn 这个按钮,因为这个按钮调用了这个函数 console.log(this); console.log(that.uname); // that里面存储的是constructor里面的this &#125; dance() &#123; // 这个dance里面的this 指向的是实例对象 ldh 因为ldh 调用了这个函数 _that = this; console.log(this); &#125; &#125; var ldh = new Star('刘德华'); console.log(that === ldh); ldh.dance(); console.log(_that === ldh); // 1. 在 ES6 中类没有变量提升，所以必须先定义类，才能通过类实例化对象 // 2. 类里面的共有的属性和方法一定要加this使用.","permalink":"https://codermino.github.io/2020/08/17/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%B1%BB/","photos":[]},{"tags":[{"name":"webstorm常用快捷键","slug":"webstorm常用快捷键","permalink":"https://codermino.github.io/tags/webstorm%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"}],"title":"webstorm常用快捷键","date":"2020/08/16","text":"Ctrl+Shift + Enter，语句完成 “！”，否定完成，输入表达式时按 “！”键 Ctrl+E，最近的文件 Ctrl+Shift+E，最近更改的文件 Shift+Click，可以关闭文件 `Ctrl+[ OR ]`，可以跑到大括号的开头与结尾 Ctrl+F12，可以显示当前文件的结构 Ctrl+F7，可以查询当前元素在当前文件中的引用，然后按 F3 可以选择 Ctrl+N，可以快速打开类 Ctrl+Shift+N，可以快速打开文件 Alt+Q，可以看到当前方法的声明 Ctrl+P，可以显示参数信息 Ctrl+Shift+Insert，可以选择剪贴板内容并插入 Alt+Insert，可以生成构造器/Getter/Setter等 Ctrl+Alt+V，可以引入变量。例如：new String(); 自动导入变量定义 Ctrl+Alt+T，可以把代码包在一个块内，例如：try/catch Ctrl+Enter，导入包，自动修正 Ctrl+Alt+L，格式化代码 Ctrl+Alt+I，将选中的代码进行自动缩进编排，这个功能在编辑 JSP 文件时也可以工作 Ctrl+Alt+O，优化导入的类和包 Ctrl+R，替换文本 Ctrl+F，查找文本 Ctrl+Shift+Space，自动补全代码 Ctrl+空格，代码提示（与系统输入法快捷键冲突） Ctrl+Shift+Alt+N，查找类中的方法或变量 Alt+Shift+C，最近的更改 Alt+Shift+Up/Down，上/下移一行 Shift+F6，重构 – 重命名 Ctrl+X，删除行 Ctrl+D，复制行 Ctrl+/或Ctrl+Shift+/，注释（//或者/**/） Ctrl+J，自动代码（例如：serr） Ctrl+Alt+J，用动态模板环绕 Ctrl+H，显示类结构图（类的继承层次） Ctrl+Q，显示注释文档 Alt+F1，查找代码所在位置 Alt+1，快速打开或隐藏工程面板 Ctrl+Alt+left/right，返回至上次浏览的位置 Alt+left/right，切换代码视图 Alt+Up/Down，在方法间快速移动定位 Ctrl+Shift+Up/Down，向上/下移动语句 F2 或 Shift+F2，高亮错误或警告快速定位 Tab，代码标签输入完成后，按 Tab，生成代码 Ctrl+Shift+F7，高亮显示所有该文本，按 Esc 高亮消失 Alt+F3，逐个往下查找相同文本，并高亮显示 Ctrl+Up/Down，光标中转到第一行或最后一行下 Ctrl+B/Ctrl+Click，快速打开光标处的类或方法（跳转到定义处） Ctrl+Alt+B，跳转到方法实现处 Ctrl+Shift+Backspace，跳转到上次编辑的地方 Ctrl+O，重写方法 Ctrl+Alt+Space，类名自动完成 Ctrl+Alt+Up/Down，快速跳转搜索结果 Ctrl+Shift+J，整合两行 Alt+F8，计算变量值 Ctrl+Shift+V，可以将最近使用的剪贴板内容选择插入到文本 Ctrl+Alt+Shift+V，简单粘贴 Shift+Esc，不仅可以把焦点移到编辑器上，而且还可以隐藏当前（或最后活动的）工具窗口 F12，把焦点从编辑器移到最近使用的工具窗口 Shift+F1，要打开编辑器光标字符处使用的类或者方法 Java 文档的浏览器 Ctrl+W，可以选择单词继而语句继而行继而函数 Ctrl+Shift+W，取消选择光标所在词 Alt+F7，查找整个工程中使用地某一个类、方法或者变量的位置 Ctrl+I，实现方法 Ctrl+Shift+U，大小写转化 Ctrl+Y，删除当前行 Shift+Enter，向下插入新行 psvm/sout，main/System.out.println(); Ctrl+J，查看更多 Ctrl+Shift+F，全局查找 Ctrl+F，查找/Shift+F3，向上查找/F3，向下查找 Ctrl+Shift+S，高级搜索 Ctrl+U，转到父类 Ctrl+Alt+S，打开设置对话框 Alt+Shift+Inert，开启/关闭列选择模式 Ctrl+Alt+Shift+S，打开当前项目/模块属性 Ctrl+G，定位行 Alt+Home，跳转到导航栏 Ctrl+Enter，上插一行 Ctrl+Backspace，按单词删除 Ctrl+”+/-”，当前方法展开、折叠 Ctrl+Shift+”+/-”，全部展开、折叠 【调试部分、编译】 Ctrl+F2，停止 Alt+Shift+F9，选择 Debug Alt+Shift+F10，选择 Run Ctrl+Shift+F9，编译 Ctrl+Shift+F10，运行 Ctrl+Shift+F8，查看断点 F8，步过 F7，步入 Shift+F7，智能步入 Shift+F8，步出 Alt+Shift+F8，强制步过 Alt+Shift+F7，强制步入 Alt+F9，运行至光标处 Ctrl+Alt+F9，强制运行至光标处 F9，恢复程序 Alt+F10，定位到断点 Ctrl+F8，切换行断点 Ctrl+F9，生成项目 Alt+1，项目 Alt+2，收藏 Alt+6，TODO Alt+7，结构 Ctrl+Shift+C，复制路径 Ctrl+Alt+Shift+C，复制引用，必须选择类名 Ctrl+Alt+Y，同步 Ctrl+~，快速切换方案（界面外观、代码风格、快捷键映射等菜单） Shift+F12，还原默认布局 Ctrl+Shift+F12，隐藏/恢复所有窗口 Ctrl+F4，关闭 Ctrl+Shift+F4，关闭活动选项卡 Ctrl+Tab，转到下一个拆分器 Ctrl+Shift+Tab，转到上一个拆分器 【重构】 Ctrl+Alt+Shift+T，弹出重构菜单 Shift+F6，重命名 F6，移动 F5，复制 Alt+Delete，安全删除 Ctrl+Alt+N，内联 【查找】 Ctrl+F，查找 Ctrl+R，替换 F3，查找下一个 Shift+F3，查找上一个 Ctrl+Shift+F，在路径中查找 Ctrl+Shift+R，在路径中替换 Ctrl+Shift+S，搜索结构 Ctrl+Shift+M，替换结构 Alt+F7，查找用法 Ctrl+Alt+F7，显示用法 Ctrl+F7，在文件中查找用法 Ctrl+Shift+F7，在文件中高亮显示用法","permalink":"https://codermino.github.io/2020/08/16/webstorm%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/","photos":[]},{"tags":[{"name":"computed的get和set","slug":"computed的get和set","permalink":"https://codermino.github.io/tags/computed%E7%9A%84get%E5%92%8Cset/"}],"title":"computed的get和set","date":"2020/08/15","text":"计算属性的一般使用(双向绑定)&lt;h1&gt;&#123;&#123;fullName&#125;&#125;&lt;/h1&gt; &lt;label&gt; &lt;input type=\"text\" v-model=\"firstName\"&gt; &lt;/label&gt; &lt;label&gt; &lt;input type=\"text\" v-model=\"lastName\"&gt; &lt;/label&gt; computed: &#123; fullName() &#123; return this.firstName + ' ' + this.lastName; &#125; &#125;, 计算属性的一般使用(单向绑定)&lt;h1&gt;&#123;&#123;fullName&#125;&#125;&lt;/h1&gt; &lt;button @click=\"fullName = 'sun he'\"&gt;changename&lt;/button&gt; computed: &#123; fullName: &#123; get: function () &#123; return this.firstName + ' ' + this.lastName &#125;, set: function (newValue) &#123; var names = newValue.split(' '); this.firstName = names[0]; this.lastName = names[names.length - 1]; &#125; &#125; &#125;","permalink":"https://codermino.github.io/2020/08/15/computed%E7%9A%84get%E5%92%8Cset/","photos":[]},{"tags":[{"name":"vue别名和波浪号的使用","slug":"vue别名和波浪号的使用","permalink":"https://codermino.github.io/tags/vue%E5%88%AB%E5%90%8D%E5%92%8C%E6%B3%A2%E6%B5%AA%E5%8F%B7%E7%9A%84%E4%BD%BF%E7%94%A8/"}],"title":"vue别名和波浪号的使用","date":"2020/08/14","text":"使用方法使用别名一般就三种情况：在js中用，在css中用，在html文档内用js中用，最简单: import &#123;getName&#125; from '@/util/name' css中使用，需要加入“~”，并且不要写成字符串： &#123; background: url(~@/assets/img/04_2.jpg); background: url('~@/assets/img/04_2.jpg');//错了，这里有个坑，不能写成字符串，我就是因为这样写错了 &#125; html中使用，可以加入‘’也可以不加入‘’。 `&lt;img class=\"pic-404__child left\" src=\"@/assets/404_images/404_cloud.png\" alt=\"404\"&gt;` 在引入文件的时候，路径前面需要加上”~”。 @import '~@/css/index.css' tip: 图片以及一些静态资源尽量放入src/assets目录内，不要放入static目录内，访问不易出错。以@/assets/……方式访问。 在写路径时候，尽量不要使用绝对路径，请使用@别名方式访问资源。","permalink":"https://codermino.github.io/2020/08/14/vue%E5%88%AB%E5%90%8D%E5%92%8C%E6%B3%A2%E6%B5%AA%E5%8F%B7%E7%9A%84%E4%BD%BF%E7%94%A8/","photos":[]},{"tags":[{"name":"yield和return区别","slug":"yield和return区别","permalink":"https://codermino.github.io/tags/yield%E5%92%8Creturn%E5%8C%BA%E5%88%AB/"}],"title":"yield和return区别","date":"2020/08/14","text":"迭代器与可迭代对象开始之前，先理解一下迭代器与可迭代对象，因为yield其实是一种特殊的迭代器，不过这种迭代器更加优雅。 可迭代对象//可迭代对象：列表为例 s = 'ABC' l = list(s) print(l) ['A', 'B', 'C'] 迭代器# 迭代器对象l1 s = 'ABC' l = list(s) l1 = iter(l) print(l1) # 取出迭代器容器中的值，没有值后就抛出异常 print(next(l1)) print(next(l1)) print(next(l1)) print(next(l1)) &lt;list_iterator object at 0x0000020D793D95C0&gt; A B C StopIteration 上面案例中l是一个列表，是一个可迭代对象l1是一个迭代器，直接打印，结果是&lt;list_iterator object at 0x0000020D793D95C0&gt;，访问其中的值可以使用for循环或者next函数，所有值都被访问后，最后会抛出StopIteration异常 关于迭代器与可迭代对象参考我另一篇博文，里面有详细解释：https://blog.csdn.net/u011318077/article/details/93754013 yield生成器就是一个优雅的迭代器，访问也会用到next函数，理解迭代器后可以更轻松的理解yield生成器的执行过程和原理。 yield简单案例及执行步骤下面进入正题，如果你还没有对yield有个初步分认识，那么你先把yield看做“return”，这个是直观的，它首先是个return，普通的return是什么意思，就是在程序中返回某个值，返回之后程序就不再往下运行了。看做return之后再把它看做一个是生成器（generator）的一部分（带yield的函数才是真正的迭代器），好了，如果你对这些不明白的话，那先把yield看做return,然后直接看下面的程序，你就会明白yield的全部意思了(只是先当做return，本质向后看就会明白)。 先看一个普通函数 // 一个普通函数： def foo(): print('Starting.....') // 调用函数，直接执行语句 g = foo() print(\"*\" * 100) Starting..... **************************************************** 生成器函数 // 包含yield关键字，就变成了生成器函数 //调用函数并不会执行语句 def foo(): print('Starting.....') while True: res = yield 4 print(\"res:\", res) // 下面调用函数并没有执行，可以先将后面的语句注释掉 // 逐行运行代码观察效果 g = foo() print(\"第一次调用执行结果：\") print(next(g)) print(\"*\" * 100) print(\"第二次调用执行结果：\") print(next(g)) print(\"*\" * 100） 第一次调用执行结果： Starting..... 4 ******************************************************************** 第二次调用执行结果： res: None 4 ******************************************************************** 下面解释代码运行顺序，相当于代码单步调试()：程序开始执行以后，因为foo函数中有yield关键字，所以foo函数并不会真的执行，而是先得到一个生成器g(相当于一个对象)，函数的一个状态，函数相当于暂停了执行第一次调用，直到遇到next方法，foo函数正式开始执行，先执行foo函数中的print方法，然后进入while循环程序遇到yield关键字，然后把yield想想成return,return了一个4之后，程序停止，但是，程序只是返回了一个值4，并没有执行将4赋值给res操作，此时next(g)语句执行完成，所以第一次调用后的结果有两行（第一个是while上面的print的结果,第二个是return出的结果）也就是执行print(next(g))先调用函数，最后打印出了返回值4程序执行print(“” * 100)，输出100个执行第二次调用，又开始执行下面的print(next(g)),这个时候和上面那个差不多，不过不同的是，这个时候是从刚才那个next程序停止的地方开始执行的，也就是要执行res的赋值操作语句，这时候要注意，yield 4返回值4后就停止了，并没有赋值给前面的res, （因为刚才那个是return出去了，并没有给赋值操作的左边传参数），此时代码实际是从print(“res:”, res)开始执行，这个时候res赋值是空，是None,所以接着下面的输出就是res:None,程序会继续在while里执行，又一次碰到yield,这个时候同样return出4，然后程序停止，print函数输出的4就是这次return出的4.到这里你可能就明白yield和return的关系和区别了，带yield的函数是一个生成器，而不是一个函数了，这个生成器有一个函数就是next函数，next就相当于“下一步”生成哪个数，这一次的next开始的地方是接着上一次的next停止的地方执行的，所以调用next的时候，生成器并不会从foo函数的开始执行，只是接着上一步停止的地方开始，然后遇到yield后，return出要生成的数，此步就结束。 总结上面的foo()就是一个生成器函数，当一个生成器函数调用yield，生成器函数的“状态”会被冻结，所有的变量的值会被保留下来，下一行要执行的代码的位置也会被记录，就是yield这行代码结束的位置直到再次调用next()。一旦next()再次被调用，生成器函数会从它上次离开的地方开始。如果永远不调用next()，yield保存的状态就被无视了。 generator是用来产生一系列值的，yield则像是generator函数的返回结果，(yield也可以看似return)，yield唯一所做的另一件事就是保存一个generator函数的状态 yield和return的区别，return执行后会继续执行后面的代码，但是yield会停止之后的代码继续执行，注意，只是停止生成器函数内部的代码，生成器函数外部代码不受影响 generator就是一个特殊类型的迭代器（iterator）和迭代器相似，我们可以通过使用next()来从generator中获取下一个值 yield中的send函数yield生成器函数中另外一重要函数就是send(），可以传入一个值作为返回值，看下面案例，第二次调用时候传入数字7 # 包含yield关键字，就变成了生成器函数 def foo(): print('Starting.....') while True: res = yield 4 print(\"res:\", res) # 下面调用函数并没有执行，可以先将后面的语句注释掉 # 逐行运行代码观察效果 g = foo() print(\"第一次调用执行结果：\") print(next(g)) print(\"*\" * 100) print(\"第二次调用执行结果(传入参数)：\") print(g.send(7)) print(\"*\" * 100) print(\"第三次调用执行结果：\") print(next(g)) print(\"*\" * 100) 第一次调用执行结果： Starting..... 4 ***************************************************************** 第二次调用执行结果(传入参数)： res: 7 4 ****************************************************************** 第三次调用执行结果： res: None 4 ****************************************************************** send函数的概念：003案例中第二次调用时res的值为什么是None，这个变成了7，到底为什么？这是因为，send是发送一个参数给res的，因为上面讲到，return的时候，并没有把4赋值给res，下次执行的时候只好继续执行赋值操作，只好赋值为None了，而如果用send的话，开始执行的时候，先接着上一次（return 4之后）执行，先把7赋值给了res,然后执行next的作用，遇见下一回的yield，return出结果后结束（return的结果都是4，每次代码最后的结果都是4）。 上面代码执行步骤： 程序执行g.send(7)，程序会从yield关键字那一行继续向下运行，send会把7这个值赋值给res变量 由于send方法中包含next()方法，所以程序会继续向下运行执行print方法，然后再次进入while循环 程序执行再次遇到yield关键字，yield会返回后面的值后，程序再次暂停，直到再次调用next方法或send方法。 深层次补充：(上面的案例描述只是为了容易理解，描述为暂停和赋值)比如说“send方法中包含next()”send先赋值然后在执行next，从一些代码直观上来讲好像是这样，但其实并不是，第一，其实并不是赋值，第二，底层send和next其实都是调用gen_send_ex(PyGenObject *gen,PyObject *arg,int exc)这个函数，只是第二个参数不一样，send也不一定要带参数，尤其是第一次使用send来启动生成器，send带参数还是不允许的。如果对中断了解的话，其实不要把这个当成return来看，因为根本就不是，应该当成中断来理解，因为底层的实现就是中断的原理，保存栈帧，加载栈帧。 yield的好处是什么？通过上面的阅读和敲代码已经理解了什么是yield，和整个执行原理都应该很清楚了，单究竟为什么要使用yield，而不是用return？？？ 我们以列表list为例，为什么用这个生成器，是因为如果用List的话，会占用更大的空间，比如说取0,1,2,3,4,5,6…1000，下面举例，只取到10,1000结果太长了 for n in range(10): a=n print(a) # 相当于return a print(\"*\" * 100) 0 1 2 3 4 5 6 7 8 9 ``` #### 生成器实现上面功能 ```markdown //生成器实现 def foo(num): print(\"starting...\") while num&lt;10: num=num+1 yield num for n in foo(0): print(n) starting... 1 2 3 4 5 6 7 8 9 10 上面两种方式都可以得到0-10之间的数字，但是占用内存不同： 第一种直接使用for循环：for循环运行时，所有的0-10之间数字都存在内存之中需要消耗极大的内存，如果数字是10000，可能for循环直接就将电脑内存消耗完了后面的代码，其它程序就无内存可用了 第二种，虽然也是for循环，但是内部加入了yield：for循环每次调用时，yield生成器(generator)能够迭代的关键是它有一个next()方法，工作原理就是通过重复调用next()方法，直到捕获一个异常,for循环自动结束 每次执行到yield，因为底层的实现就是中断的原理，保存栈帧，加载栈帧。 每次执行结束内存释放，执行的时候占用一点内存，消耗的内存资源就很少 上面for循环执行过程，并没有写next函数，其实自动调用的next函数(参考迭代器与迭代对象中详细解释)： for循环执行过程： 1、调用可迭代对象的iter方法返回一个迭代器对象（iterator）2、不断调用迭代器的next方法返回元素3、直到迭代完成后，处理StopIteration异常 yield的好处总结：1、不会将所有数据取出来存入内存中；而是返回了一个对象；可以通过对象获取数据；用多少取多少，可以节省内容空间。2、除了能返回一个值，还不会终止循环的运行；3、每次执行到yield，因为底层的实现就是中断的原理，保存栈帧，加载栈帧。4、每次执行结束内存释放，执行的时候占用一点内存，消耗的内存资源就很少 补充：1、通常yield都是放在一个函数中，该函数就变成了生成器函数，该函数就变成了一个迭代器2、生成器函数一般都是通过for循环调用，for循环自带next方法3、分布式爬虫会经常使用yield,yield直接放在for循环的内部4、爬虫代码运行时候，for循环自动调用next方法，yield就会不断执行，直到爬取结束5、使用yield也会大大减少爬虫运行时候的内存消耗","permalink":"https://codermino.github.io/2020/08/14/yield%E5%92%8Creturn%E5%8C%BA%E5%88%AB/","photos":[]},{"tags":[{"name":"mysql知识点总结和应用4","slug":"mysql知识点总结和应用4","permalink":"https://codermino.github.io/tags/mysql%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E5%92%8C%E5%BA%94%E7%94%A84/"}],"title":"mysql知识点总结和应用4","date":"2020/08/14","text":"触发器介绍触发器是与表有关的数据库对象，指在 insert/update/delete 之前或之后，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性 , 日志记录 , 数据校验等操作 。 使用别名 OLD 和 NEW 来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。 触发器类型 NEW 和 OLD的使用 INSERT 型触发器 NEW 表示将要或者已经新增的数据 UPDATE 型触发器 OLD 表示修改之前的数据 , NEW 表示将要或已经修改后的数据 DELETE 型触发器 OLD 表示将要或者已经删除的数据 创建触发器create trigger trigger_name before/after insert/update/delete on tbl_name [ for each row ] -- 行级触发器 begin trigger_stmt ; end; 通过触发器记录 emp 表的数据变更日志 , 包含增加, 修改 , 删除 ; 首先创建一张日志表 : create table emp_logs( id int(11) not null auto_increment, operation varchar(20) not null comment '操作类型, insert/update/delete', operate_time datetime not null comment '操作时间', operate_id int(11) not null comment '操作表的ID', operate_params varchar(500) comment '操作参数', primary key(`id`) )engine=innodb default charset=utf8; 创建 insert 型触发器，完成插入数据时的日志记录 : DELIMITER $ create trigger emp_logs_insert_trigger after insert on emp for each row begin insert into emp_logs (id,operation,operate_time,operate_id,operate_params) values(null,'insert',now(),new.id,concat('插入后(id:',new.id,', name:',new.name,', age:',new.age,', salary:',new.salary,')')); end $ DELIMITER ; 创建 update 型触发器，完成更新数据时的日志记录 : DELIMITER $ create trigger emp_logs_update_trigger after update on emp for each row begin insert into emp_logs (id,operation,operate_time,operate_id,operate_params) values(null,'update',now(),new.id,concat('修改前(id:',old.id,', name:',old.name,', age:',old.age,', salary:',old.salary,') , 修改后(id',new.id, 'name:',new.name,', age:',new.age,', salary:',new.salary,')')); end $ DELIMITER ; 创建delete 行的触发器 , 完成删除数据时的日志记录 : DELIMITER $ create trigger emp_logs_delete_trigger after delete on emp for each row begin insert into emp_logs (id,operation,operate_time,operate_id,operate_params) values(null,'delete',now(),old.id,concat('删除前(id:',old.id,', name:',old.name,', age:',old.age,', salary:',old.salary,')')); end $ DELIMITER ; 删除触发器drop trigger [schema_name.]trigger_name 如果没有指定 schema_name，默认为当前数据库 。 查看触发器可以通过执行 SHOW TRIGGERS 命令查看触发器的状态、语法等信息。 show triggers ；","permalink":"https://codermino.github.io/2020/08/14/mysql%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E5%92%8C%E5%BA%94%E7%94%A84/","photos":[]},{"tags":[{"name":"mysql知识点总结和应用3","slug":"mysql知识点总结和应用3","permalink":"https://codermino.github.io/tags/mysql%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E5%92%8C%E5%BA%94%E7%94%A83/"}],"title":"mysql知识点总结和应用3","date":"2020/08/14","text":"存储过程和函数概述存储过程和函数是 事先经过编译并存储在数据库中的一段 SQL 语句的集合，调用存储过程和函数可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。 ​ 存储过程和函数的区别在于函数必须有返回值，而存储过程没有。 ​ 函数 ： 是一个有返回值的过程 ； ​ 过程 ： 是一个没有返回值的函数 ； 创建存储过程CREATE PROCEDURE procedure_name ([proc_parameter[,...]]) begin -- SQL语句 end ; 示例： delimiter $ create procedure pro_test1() begin select 'Hello Mysql' ; end$ delimiter ; 知识小贴士 DELIMITER 该关键字用来声明SQL语句的分隔符 , 告诉 MySQL 解释器，该段命令是否已经结束了，mysql是否可以执行了。 默认情况下，delimiter是分号;。在命令行客户端中， 如果有一行命令以分号结束，那么回车后，mysql将会执行该命令。 调用存储过程call procedure_name() ; 查看存储过程-- 查询db_name数据库中的所有的存储过程 select name from mysql.proc where db='db_name'; -- 查询存储过程的状态信息 show procedure status; -- 查询某个存储过程的定义 show create procedure test.pro_test1 \\G; 删除存储过程DROP PROCEDURE [IF EXISTS] sp_name ； 语法存储过程是可以编程的，意味着可以使用变量，表达式，控制结构 ， 来完成比较复杂的功能。 变量DECLARE通过 DECLARE 可以定义一个局部变量，该变量的作用范围只能在 BEGIN…END 块中。 DECLARE var_name[,...] type [DEFAULT value] delimiter $ create procedure pro_test2() begin declare num int default 5; select num+ 10; end$ delimiter ; SET直接赋值使用 SET，可以赋常量或者赋表达式，具体语法如下： SET var_name = expr [, var_name = expr] ... DELIMITER $ CREATE PROCEDURE pro_test3() BEGIN DECLARE NAME VARCHAR(20); SET NAME = 'MYSQL'; SELECT NAME ; END$ DELIMITER ; 也可以通过select … into 方式进行赋值操作 : DELIMITER $ CREATE PROCEDURE pro_test5() BEGIN declare countnum int; select count(*) into countnum from city; select countnum; END$ DELIMITER ; if条件判断 if search_condition then statement_list [elseif search_condition then statement_list] ... [else statement_list] end if; 根据定义的身高变量，判定当前身高的所属的身材类型 180 及以上 ———-&gt; 身材高挑 170 - 180 ———&gt; 标准身材 170 以下 ———-&gt; 一般身材 delimiter $ create procedure pro_test6() begin declare height int default 175; declare description varchar(50); if height &gt;= 180 then set description = '身材高挑'; elseif height &gt;= 170 and height &lt; 180 then set description = '标准身材'; else set description = '一般身材'; end if; select description ; end$ delimiter ; 传递参数 create procedure procedure_name([in/out/inout] 参数名 参数类型) ... IN : 该参数可以作为输入，也就是需要调用方传入值 , 默认 OUT: 该参数作为输出，也就是该参数可以作为返回值 INOUT: 既可以作为输入参数，也可以作为输出参数 小知识 @description : 这种变量要在变量名称前面加上“@”符号，叫做用户会话变量， 代表整个会话过程他都是有作用的，这个类似于全局变量一样。 @@global.sort_buffer_size : 这种在变量前加上 “@@” 符号, 叫做 系统变量 case结构方式一 : CASE case_value WHEN when_value THEN statement_list [WHEN when_value THEN statement_list] ... [ELSE statement_list] END CASE; 方式二 : CASE WHEN search_condition THEN statement_list [WHEN search_condition THEN statement_list] ... [ELSE statement_list] END CASE; 给定一个月份, 然后计算出所在的季度 delimiter $ create procedure pro_test9(month int) begin declare result varchar(20); case when month &gt;= 1 and month &lt;=3 then set result = '第一季度'; when month &gt;= 4 and month &lt;=6 then set result = '第二季度'; when month &gt;= 7 and month &lt;=9 then set result = '第三季度'; when month &gt;= 10 and month &lt;=12 then set result = '第四季度'; end case; select concat('您输入的月份为 :', month , ' , 该月份为 : ' , result) as content ; end$ delimiter ; while循环while search_condition do statement_list end while; 计算从1加到n的值 delimiter $ create procedure pro_test8(n int) begin declare total int default 0; declare num int default 1; while num&lt;=n do set total = total + num; set num = num + 1; end while; select total; end$ delimiter ; repeat结构有条件的循环控制语句, 当满足条件的时候退出循环 。while 是满足条件才执行，repeat 是满足条件就退出循环。 REPEAT statement_list UNTIL search_condition END REPEAT; 计算从1加到n的值 delimiter $ create procedure pro_test10(n int) begin declare total int default 0; repeat set total = total + n; set n = n - 1; until n=0 end repeat; select total ; end$ delimiter ; loop语句LOOP 实现简单的循环，退出循环的条件需要使用其他的语句定义，通常可以使用 LEAVE 语句实现. [begin_label:] LOOP statement_list END LOOP [end_label] 如果不在 statement_list 中增加退出循环的语句，那么 LOOP 语句可以用来实现简单的死循环。 leave语句用来从标注的流程构造中退出，通常和 BEGIN … END 或者循环一起使用。下面是一个使用 LOOP 和 LEAVE 的简单例子 , 退出循环： delimiter $ CREATE PROCEDURE pro_test11(n int) BEGIN declare total int default 0; ins: LOOP IF n &lt;= 0 then leave ins; END IF; set total = total + n; set n = n - 1; END LOOP ins; select total; END$ delimiter ; 存储函数CREATE FUNCTION function_name([param type ... ]) RETURNS type BEGIN ... END; 案例 :定义一个存储过程, 请求满足条件的总记录数 ; delimiter $ create function count_city(countryId int) returns int begin declare cnum int ; select count(*) into cnum from city where country_id = countryId; return cnum; end$ delimiter ; 调用 select count_city(1); select count_city(2); 删除 drop function fun_name;","permalink":"https://codermino.github.io/2020/08/14/mysql%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E5%92%8C%E5%BA%94%E7%94%A83/","photos":[]},{"tags":[{"name":"mysql知识点总结和应用2","slug":"mysql知识点总结和应用2","permalink":"https://codermino.github.io/tags/mysql%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E5%92%8C%E5%BA%94%E7%94%A82/"}],"title":"mysql知识点总结和应用2","date":"2020/08/14","text":"视图视图概述视图（View）是一种虚拟存在的表。视图并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。通俗的讲，视图就是一条SELECT语句执行后返回的结果集。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。 视图相对于普通的表的优势主要包括以下几项。 简单：使用视图的用户完全不需要关心后面对应的表的结构、关联条件和筛选条件，对用户来说已经是过滤好的复合条件的结果集。 安全：使用视图的用户只能访问他们被允许查询的结果集，对表的权限管理并不能限制到某个行某个列，但是通过视图就可以简单的实现。 数据独立：一旦视图的结构确定了，可以屏蔽表结构变化对用户的影响，源表增加列对视图没有影响；源表修改列名，则可以通过修改视图来解决，不会造成对访问者的影响。 创建或者修改视图创建CREATE [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}] VIEW view_name [(column_list)] AS select_statement [WITH [CASCADED | LOCAL] CHECK OPTION] 修改ALTER [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}] VIEW view_name [(column_list)] AS select_statement [WITH [CASCADED | LOCAL] CHECK OPTION]选项 : WITH [CASCADED | LOCAL] CHECK OPTION 决定了是否允许更新数据使记录不再满足视图的条件。 LOCAL ： 只要满足本视图的条件就可以更新。 CASCADED ： 必须满足所有针对该视图的所有视图的条件才可以更新。 默认值.(级联)示例 , 创建city_country_view视图 , 执行如下SQL : create or replace view city_country_view as select t.*,c.country_name from country c , city t where c.country_id = t.country_id; 删除视图DROP VIEW [IF EXISTS] view_name [, view_name] …[RESTRICT | CASCADE]示例 , 删除视图city_country_view : DROP VIEW city_country_view ;","permalink":"https://codermino.github.io/2020/08/14/mysql%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E5%92%8C%E5%BA%94%E7%94%A82/","photos":[]},{"tags":[{"name":"mysql知识点总结和应用1","slug":"mysql知识点总结和应用1","permalink":"https://codermino.github.io/tags/mysql%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E5%92%8C%E5%BA%94%E7%94%A81/"}],"title":"mysql知识点总结和应用1","date":"2020/08/14","text":"索引索引概述MySQL官方对索引的定义为：索引（index）是帮助MySQL高效获取数据的数据结构（有序）。在数据之外，数据库系统还维护者满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。如下面的==示意图==所示 : 左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找快速获取到相应数据。 一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。索引是数据库中用来提高性能的最常用的工具。 索引优势劣势优势 1） 类似于书籍的目录索引，提高数据检索的效率，降低数据库的IO成本。 2） 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。 劣势 1） 实际上索引也是一张表，该表中保存了主键与索引字段，并指向实体类的记录，所以索引列也是要占用空间的。 2） 虽然索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE。 因为更新表时，MySQL 不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段， 都会调整因为更新所带来的键值变化后的索引信息。 索引结构索引是在MySQL的存储引擎层中实现的，而不是在服务器层实现的。所以每种存储引擎的索引都不一定完全相同，也不是所有的存储引擎都支持所有的索引类型的。MySQL目前提供了以下4种索引： BTREE 索引 ： 最常见的索引类型，大部分索引都支持 B 树索引。 HASH 索引：只有Memory引擎支持 ， 使用场景简单 。 R-tree 索引（空间索引）：空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少，不做特别介绍。 Full-text （全文索引） ：全文索引也是MyISAM的一个特殊索引类型，主要用于全文索引，InnoDB从Mysql5.6版本开始支持全文索引。 索引分类1） 单值索引 ：即一个索引只包含单个列，一个表可以有多个单列索引 2） 唯一索引 ：索引列的值必须唯一，但允许有空值 3） 复合索引 ：即一个索引包含多个列 索引语法创建索引CREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX index_name[USING index_type]ON tbl_name(index_col_name,…) index_col_name : column_name[(length)][ASC | DESC]eq:create index idx_city_name on city(city_name); 查看索引show index from table_name[\\G]; 删除索引DROP INDEX index_name ON tbl_name; ALTER命令1). alter table tb_name add primary key(column_list); 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL2). alter table tb_name add unique index_name(column_list); 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）3). alter table tb_name add index index_name(column_list); 添加普通索引， 索引值可以出现多次。4). alter table tb_name add fulltext index_name(column_list); 该语句指定了索引为FULLTEXT， 用于全文索引索引设计原则索引的设计可以遵循一些已有的原则，创建索引的时候请尽量考虑符合这些原则，便于提升索引的使用效率，更高效的使用索引。 对查询频次较高，且数据量比较大的表建立索引。 索引字段的选择，最佳候选列应当从where子句的条件中提取，如果where子句中的组合比较多，那么应当挑选最常用、过滤效果最好的列的组合。 使用唯一索引，区分度越高，使用索引的效率越高。 索引可以有效的提升查询数据的效率，但索引数量不是多多益善，索引越多，维护索引的代价自然也就水涨船高。 对于插入、更新、删除等DML操作比较频繁的表来说，索引过多，会引入相当高的维护代价，降低DML操作的效率，增加相应操作的时间消耗。 另外索引过多的话，MySQL也会犯选择困难病，虽然最终仍然会找到一个可用的索引，但无疑提高了选择的代价。 使用短索引，索引创建之后也是使用硬盘来存储的，因此提升索引访问的I/O效率，也可以提升总体的访问效率。假如构成索引的字段总长度比较短， 那么在给定大小的存储块内可以存储更多的索引值，相应的可以有效的提升MySQL访问索引的I/O效率。 利用最左前缀，N个列组合而成的组合索引，那么相当于是创建了N个索引，如果查询时where子句中使用了组成该索引的前几个字段， 那么这条查询SQL可以利用组合索引来提升查询效率。 创建复合索引: CREATE INDEX idx_name_email_status ON tb_seller(NAME,email,STATUS); 就相当于 对name 创建索引 ; 对name , email 创建了索引 ; 对name , email, status 创建了索引 ;","permalink":"https://codermino.github.io/2020/08/14/mysql%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E5%92%8C%E5%BA%94%E7%94%A81/","photos":[]},{"tags":[{"name":"找回密码功能流程","slug":"找回密码功能流程","permalink":"https://codermino.github.io/tags/%E6%89%BE%E5%9B%9E%E5%AF%86%E7%A0%81%E5%8A%9F%E8%83%BD%E6%B5%81%E7%A8%8B/"}],"title":"找回密码功能流程","date":"2020/08/14","text":"找回密码流程 1、注册时要求每个用户使用唯一的邮箱，注册后向用户的邮箱发一封邮件 2、找回密码时要求用户填写邮箱地址，提示用户如果不记得地址请在邮箱中搜索 3、找回密码功能限制每帐号每天只能使用三次(只能发三次邮件), 使用缓存来完成这个计数 4、找回密码时向缓存中写入一个随机的字符串作为 Token, 有效期为一天，向用户的邮箱发送包含 Token 的链接 5、用户从链接点回来先验证 Token 的有效性，然后提示填写新密码，然后将新密码和 Token 一起提交给后端完成修改密码的操作 6、删除掉 Token 的缓存","permalink":"https://codermino.github.io/2020/08/14/%E6%89%BE%E5%9B%9E%E5%AF%86%E7%A0%81%E5%8A%9F%E8%83%BD%E6%B5%81%E7%A8%8B/","photos":[]},{"tags":[{"name":"vuex页面刷新数据丢失问题","slug":"vuex页面刷新数据丢失问题","permalink":"https://codermino.github.io/tags/vuex%E9%A1%B5%E9%9D%A2%E5%88%B7%E6%96%B0%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/"}],"title":"vuex页面刷新数据丢失问题","date":"2020/08/14","text":"vuex 数据在页面刷新后数据丢失问题解决方法：在APP.vue文件的created生命周期中加入以下代码： if(localStorage.eleToken)&#123; // 1.使用jwt_decode解码存储的token信息 const decoded = jwt_decode(localStorage.eleToken); console.log(decoded); //调用对应的函数，进行用户信息的存储 this.$store.dispatch(\"setAuthenticated\",isEmpty(localStorage.eleToken)); this.$store.dispatch(\"setUser\",decoded); &#125; 对应的vuex中的mutations和actions const mutations=&#123; set_authenticated(state,isAuthenticated)&#123; if(isAuthenticated)&#123; state.isAuthenticated=isAuthenticated; &#125;else&#123; state.isAuthenticated=false; &#125; &#125;, set_user(state,user)&#123; if(user)&#123; state.user=user; &#125;else&#123; state.user=&#123;&#125;; &#125; &#125; &#125;; const actions=&#123; setAuthenticated:(&#123;commit&#125;,isAuthenticated)=&gt;&#123; commit('set_authenticated',isAuthenticated); &#125;, setUser:(&#123;commit&#125;,user)=&gt;&#123; commit('set_user',user); &#125;, clearCurrentState(&#123;commit&#125;)&#123; commit('set_authenticated',false); commit('set_user',&#123;&#125;); &#125; &#125;;","permalink":"https://codermino.github.io/2020/08/14/vuex%E9%A1%B5%E9%9D%A2%E5%88%B7%E6%96%B0%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/","photos":[]},{"tags":[{"name":"vuex知识点总结","slug":"vuex知识点总结","permalink":"https://codermino.github.io/tags/vuex%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"}],"title":"vuex知识点总结","date":"2020/08/14","text":"1、vuex主要包括以下几个模块： State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。 Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。 Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。 Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。 Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。 2、什么情况下使用 Vuex？ 如果应用够简单，最好不要使用 Vuex，一个简单的 store 模式即可 需要构建一个中大型单页应用时，使用Vuex能更好地在组件外部管理状态 3、Vuex和单纯的全局对象有什么区别？ Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。 这样使得我们可以方便地跟踪每一个状态的变化， 从而让我们能够实现一些工具帮助我们更好地了解我们的应用。 4、为什么 Vuex 的 mutation 中不能做异步操作？ Vuex中所有的状态更新的唯一途径都是mutation，异步操作通过 Action 来提交 mutation实现，这样使得我们可以方便地跟踪每一个状态的变化， 从而让我们能够实现一些工具帮助我们更好地了解我们的应用。 每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来， 然后就可以实现 time-travel 了。如果mutation支持异步操作，就没有办法知道状态是何时更新的， 无法很好的进行状态的追踪，给调试带来困难 5、vuex的action有返回值吗？返回的是什么？ store.dispatch 可以处理被触发的 action 的处理函数返回的 Promise，并且 store.dispatch 仍旧返回 Promise Action 通常是异步的，要知道 action 什么时候结束或者组合多个 action以处理更加复杂的异步流程， 可以通过定义action时返回一个promise对象，就可以在派发action的时候就可以通过处理返回的 Promise处理异步流程。 一个 store.dispatch 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后， 返回的 Promise 才会执行。 6、为什么不直接分发mutation,而要通过分发action之后提交 mutation变更状态？ mutation 必须同步执行，我们可以在 action 内部执行异步操作 可以进行一系列的异步操作，并且通过提交 mutation 来记录 action 产生的副作用（即状态变更） 7、从vuex中获取的数据能直接更改吗？ 从vuex中取的数据，不能直接更改，需要浅拷贝对象之后更改，否则报错； 8、Vuex的严格模式是什么,有什么作用,怎么开启 在严格模式下，无论何时发生了状态变更且不是由mutation函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。 在Vuex.Store 构造器选项中开启,如下： const store = new Vuex.Store(&#123; strict:true, &#125;) 9、mutation和action有什么区别 action 提交的是 mutation，而不是直接变更状态。mutation可以直接变更状态 action 可以包含任意异步操作。mutation只能是同步操作 提交方式不同 action 是用this.store.dispatch('ACTION_NAME',data)来提交。 mutation是用this.$store.commit('SET_NUMBER',10)来提交 接收参数不同，mutation第一个参数是state，而action第一个参数是context，其包含了 &#123; state, // 等同于 `store.state`，若在模块中则为局部状态 rootState, // 等同于 `store.state`，只存在于模块中 commit, // 等同于 `store.commit` dispatch, // 等同于 `store.dispatch` getters, // 等同于 `store.getters` rootGetters // 等同于 `store.getters`，只存在于模块中 &#125; 10、在v-model上怎么用Vuex中state的值？ &lt;input v-model=\"message\"&gt; computed: &#123; message: &#123; get () &#123; return this.$store.state.message &#125;, set (value) &#123; this.$store.commit('updateMessage', value) &#125; &#125; &#125;","permalink":"https://codermino.github.io/2020/08/14/vuex%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/","photos":[]},{"tags":[{"name":"响应式布局尺寸划分","slug":"响应式布局尺寸划分","permalink":"https://codermino.github.io/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%E5%B0%BA%E5%AF%B8%E5%88%92%E5%88%86/"}],"title":"响应式布局尺寸划分","date":"2020/08/14","text":"尺寸划分 超小屏幕(手机) ------- &lt;768px 设置宽度为100% 小屏设备(平板) ------- &gt;=768px &lt;992px 设置宽度为750px 中等屏幕(桌面显示器) ------- &gt;=992px &lt;1200px 设置宽度为970px 宽屏设备(大桌面显示器) ------- &gt;=1200px 设置宽度为1170px","permalink":"https://codermino.github.io/2020/08/14/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%E5%B0%BA%E5%AF%B8%E5%88%92%E5%88%86/","photos":[]},{"tags":[{"name":"echarts自定义样式","slug":"echarts自定义样式","permalink":"https://codermino.github.io/tags/echarts%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%B7%E5%BC%8F/"}],"title":"echarts自定义样式","date":"2020/08/14","text":"一、折线统计图中的自定义样式（注意背景条纹色的设置） let option1 = &#123; title: &#123; // text: \"堆叠区域图\" &#125;, tooltip: &#123; trigger: \"axis\", axisPointer: &#123; type: \"cross\", label: &#123; backgroundColor: \"#6a7985\" &#125; &#125; &#125;, legend: &#123; data: [\"登记数\", \"分享数\"] &#125;, toolbox: &#123;&#125;, grid: &#123; left: 10, right: 10, bottom: 20, top: 30, containLabel: true &#125;, color: [\"#81b22f\", \"#f3d71c\", \"#f4b9a9\"], xAxis: [ &#123; type: \"category\", boundaryGap: false, data: [\"周一\", \"周二\", \"周三\", \"周四\", \"周五\", \"周六\", \"周日\"] &#125; ], yAxis: [ &#123; type: \"value\", splitArea: &#123; show: true, areaStyle:&#123; color:['rgba(255,255,255,0.3)','rgba(241,241,241,0.3)'] &#125; &#125; &#125; ], series: [ &#123; name: \"登记数\", type: \"line\", stack: \"总量\", animationEasing: \"quadraticOut\", label: &#123; normal: &#123; // show: true, position: \"top\" &#125; &#125;, itemStyle: &#123; normal: &#123; color: \"#3888fa\", lineStyle: &#123; color: \"#3888fa\", width: 2 &#125;, areaStyle: &#123; color: \"#f3f8ff\" &#125; &#125; &#125;, data: [820, 932, 901, 934, 1290, 1330, 1320], animationDuration: 2800, animationEasing: \"cubicInOut\" &#125;, &#123; name: \"分享数\", type: \"line\", stack: \"总量\", itemStyle: &#123; normal: &#123; color: \"#FF005A\", lineStyle: &#123; color: \"#FF005A\", width: 2 &#125; &#125; &#125;, data: [350, 432, 601, 554, 390, 430, 410], animationDuration: 2800, animationEasing: \"cubicInOut\" &#125; ] &#125;; 二、雷达图自定义样式 let option2 = &#123; tooltip: &#123; trigger: \"axis\", axisPointer: &#123; // 坐标轴指示器，坐标轴触发有效 type: \"shadow\" // 默认为直线，可选为：'line' | 'shadow' &#125; &#125;, radar: &#123; radius: \"66%\", center: [\"50%\", \"42%\"], splitNumber: 8, splitArea: &#123; areaStyle: &#123; color: \"rgba(127,95,132,.3)\", opacity: 1, shadowBlur: 45, shadowColor: \"rgba(0,0,0,.5)\", shadowOffsetX: 0, shadowOffsetY: 15 &#125; &#125;, indicator: [ &#123; name: \"Sales\", max: 10000 &#125;, &#123; name: \"Administration\", max: 20000 &#125;, &#123; name: \"Information Technology\", max: 20000 &#125;, &#123; name: \"Customer Support\", max: 20000 &#125;, &#123; name: \"Development\", max: 20000 &#125;, &#123; name: \"Marketing\", max: 20000 &#125; ] &#125;, legend: &#123; left: \"center\", bottom: \"10\", data: [\"Allocated Budget\", \"Expected Spending\", \"Actual Spending\"] &#125;, series: [ &#123; type: \"radar\", symbolSize: 0, areaStyle: &#123; normal: &#123; shadowBlur: 13, shadowColor: \"rgba(0,0,0,.2)\", shadowOffsetX: 0, shadowOffsetY: 10, opacity: 1 &#125; &#125;, data: [ &#123; value: [5000, 7000, 12000, 11000, 15000, 14000], name: \"Allocated Budget\", itemStyle: &#123; normal: &#123; color: \"#2ec7c9\", areaStyle: &#123; type: \"default\", // opacity: 0.8, // 图表中各个图区域的透明度 color: \"#5ab1ef\" // 图表中各个图区域的颜色 &#125; &#125; &#125; &#125;, &#123; value: [4000, 9000, 15000, 15000, 13000, 11000], itemStyle: &#123; normal: &#123; color: \"#b6a2de\" // areaStyle: &#123; // type: \"default\", // // opacity: 0.8, // 图表中各个图区域的透明度 // color: \"#b6a2de\" // 图表中各个图区域的颜色 // &#125; &#125; &#125;, name: \"Expected Spending\" &#125;, &#123; value: [5500, 11000, 12000, 15000, 12000, 12000], name: \"Actual Spending\", itemStyle: &#123; normal: &#123; color: \"#5ab1ef\", areaStyle: &#123; type: \"default\", // opacity: 0.8, // 图表中各个图区域的透明度 color: \"#2ec7c9\" // 图表中各个图区域的颜色 &#125; &#125; &#125; &#125; ], animationDuration: 3000 &#125; ] &#125;; 三、玫瑰图自定义样式 let option3 = &#123; tooltip: &#123; trigger: \"item\", formatter: \"&#123;a&#125; &lt;br/&gt;&#123;b&#125; : &#123;c&#125; (&#123;d&#125;%)\" &#125;, legend: &#123; left: \"center\", bottom: \"10\", data: [\"Industries\", \"Technology\", \"Forex\", \"Gold\", \"Forecasts\"] &#125;, series: [ &#123; name: \"WEEKLY WRITE ARTICLES\", type: \"pie\", roseType: \"radius\", radius: [15, 95], center: [\"50%\", \"38%\"], color: [\"#2ec7c9\", \"#b6a2de\", \"#5ab1ef\", \"#ffb980\", \"#d87a80\"], data: [ &#123; value: 320, name: \"Industries\" &#125;, &#123; value: 240, name: \"Technology\" &#125;, &#123; value: 149, name: \"Forex\" &#125;, &#123; value: 100, name: \"Gold\" &#125;, &#123; value: 59, name: \"Forecasts\" &#125; ], animationEasing: \"cubicInOut\", animationDuration: 2600 &#125; ] &#125;; 四、柱形图自定义样式（注意背景条纹色的设置） let option4 = &#123; tooltip: &#123; trigger: \"axis\", axisPointer: &#123; // 坐标轴指示器，坐标轴触发有效 type: \"shadow\" // 默认为直线，可选为：'line' | 'shadow' &#125; &#125;, // backgroundColor: &#123;&#125;, grid: &#123; top: 10, left: \"2%\", right: \"2%\", bottom: \"3%\", containLabel: true &#125;, xAxis: [ &#123; type: \"category\", data: [\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\"], axisTick: &#123; alignWithLabel: true &#125; &#125; ], yAxis: [ &#123; type: \"value\", axisTick: &#123; show: false &#125;, splitArea: &#123; show: true, areaStyle:&#123; color:['rgba(255,255,255,0.3)','rgba(241,241,241,0.3)'] &#125; &#125; &#125; ], series: [ &#123; name: \"pageA\", type: \"bar\", stack: \"vistors\", barWidth: \"60%\", itemStyle: &#123; normal: &#123; color: \"#2ec7c9\" &#125; &#125;, data: [79, 52, 200, 334, 390, 330, 220], animationDuration: 6000 &#125;, &#123; name: \"pageB\", type: \"bar\", stack: \"vistors\", barWidth: \"60%\", itemStyle: &#123; normal: &#123; color: \"#b6a2de\" &#125; &#125;, data: [80, 52, 200, 334, 390, 330, 220], animationDuration: 6000 &#125;, &#123; name: \"pageC\", type: \"bar\", stack: \"vistors\", barWidth: \"60%\", itemStyle: &#123; normal: &#123; color: \"#1e9fff\" &#125; &#125;, data: [30, 52, 200, 334, 390, 330, 220], animationDuration: 6000 &#125; ] &#125;;","permalink":"https://codermino.github.io/2020/08/14/echarts%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%B7%E5%BC%8F/","photos":[]},{"tags":[{"name":"在本地运行webpack打包后的vue项目文件","slug":"在本地运行webpack打包后的vue项目文件","permalink":"https://codermino.github.io/tags/%E5%9C%A8%E6%9C%AC%E5%9C%B0%E8%BF%90%E8%A1%8Cwebpack%E6%89%93%E5%8C%85%E5%90%8E%E7%9A%84vue%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6/"}],"title":"在本地运行webpack打包后的vue项目文件","date":"2020/08/14","text":"那么如何用最简单的方法就可以让打包后的文件正常运行呢？ 解决这个问题首先要安装server，在cmd中输入命令： npm install -g serve 进入项目目录使用：serve -s dist 这时会提示要访问的网址，在浏览器中输入网址就可以打开了！","permalink":"https://codermino.github.io/2020/08/14/%E5%9C%A8%E6%9C%AC%E5%9C%B0%E8%BF%90%E8%A1%8Cwebpack%E6%89%93%E5%8C%85%E5%90%8E%E7%9A%84vue%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6/","photos":[]},{"tags":[{"name":"vue.config.js配置","slug":"vue-config-js配置","permalink":"https://codermino.github.io/tags/vue-config-js%E9%85%8D%E7%BD%AE/"}],"title":"vue.config.js配置","date":"2020/08/14","text":"简易版 const path = require(\"path\"); const resolve = function(dir) &#123; return path.join(__dirname, dir); &#125;; module.exports = &#123; publicPath: process.env.NODE_ENV === \"production\" ? \"./\" : \"./\", outputDir: \"dist\", assetsDir: \"static\", lintOnSave: true, // 是否开启eslint保存检测 productionSourceMap: false, // 是否在构建生产包时生成sourcdeMap chainWebpack: config =&gt; &#123; config.resolve.alias .set(\"@\", resolve(\"src\")) .set(\"@v\", resolve(\"src/views\")) .set(\"@c\", resolve(\"src/components\")) .set(\"@u\", resolve(\"src/utils\")) .set(\"@s\", resolve(\"src/service\")); /* 别名配置 */ config.optimization.runtimeChunk(\"single\"); &#125;, devServer: &#123; // host: \"localhost\", /* 本地ip地址 */ //host: \"192.168.1.107\", host: \"0.0.0.0\", //局域网和本地访问 port: \"8080\", hot: true, /* 自动打开浏览器 */ open: false, overlay: &#123; warning: false, error: true &#125;, /* 跨域代理 */ proxy: &#123; \"/api\": &#123; /* 目标代理服务器地址 */ target: \"http://xxx.com\", // // target: \"http://localhost:8888\", // /* 允许跨域 */ changeOrigin: true, ws: true, pathRewrite: &#123; \"^/api\": \"\" &#125; &#125; &#125; &#125; &#125;; 完整版 const path = require(\"path\"); const UglifyPlugin = require(\"uglifyjs-webpack-plugin\"); module.exports = &#123; // 基本路径 /* 部署生产环境和开发环境下的URL：可对当前环境进行区分，baseUrl 从 Vue CLI 3.3 起已弃用，要使用publicPath */ /* baseUrl: process.env.NODE_ENV === 'production' ? './' : '/' */ publicPath: process.env.NODE_ENV === \"production\" ? \"./\" : \"./\", // 输出文件目录 outputDir: \"dist\", // eslint-loader 是否在保存的时候检查 lintOnSave: true, // use the full build with in-browser compiler? // https://vuejs.org/v2/guide/installation.html#Runtime-Compiler-vs-Runtime-only // compiler: false, runtimeCompiler: true, //关键点在这 // 调整内部的 webpack 配置。 // 查阅 https://github.com/vuejs/vue-doc-zh-cn/vue-cli/webpack.md // webpack配置 // see https://github.com/vuejs/vue-cli/blob/dev/docs/webpack.md chainWebpack: () =&gt; &#123;&#125;, configureWebpack: config =&gt; &#123; if (process.env.NODE_ENV === \"production\") &#123; // 为生产环境修改配置... config.mode = \"production\"; // 将每个依赖包打包成单独的js文件 var optimization = &#123; runtimeChunk: \"single\", splitChunks: &#123; chunks: \"all\", maxInitialRequests: Infinity, minSize: 20000, // 依赖包超过20000bit将被单独打包 cacheGroups: &#123; vendor: &#123; test: /[\\\\/]node_modules[\\\\/]/, name(module) &#123; // get the name. E.g. node_modules/packageName/not/this/part.js // or node_modules/packageName const packageName = module.context.match( /[\\\\/]node_modules[\\\\/](.*?)([\\\\/]|$)/ )[1]; // npm package names are URL-safe, but some servers don't like @ symbols return `npm.$&#123;packageName.replace(\"@\", \"\")&#125;`; &#125; &#125; &#125; &#125;, minimizer: [ new UglifyPlugin(&#123; uglifyOptions: &#123; compress: &#123; warnings: false, drop_console: true, // console drop_debugger: false, pure_funcs: [\"console.log\"] // 移除console &#125; &#125; &#125;) ] &#125;; Object.assign(config, &#123; optimization &#125;); &#125; else &#123; // 为开发环境修改配置... config.mode = \"development\"; var optimization2 = &#123; runtimeChunk: \"single\", splitChunks: &#123; chunks: \"all\", maxInitialRequests: Infinity, minSize: 20000, // 依赖包超过20000bit将被单独打包 cacheGroups: &#123; vendor: &#123; test: /[\\\\/]node_modules[\\\\/]/, name(module) &#123; // get the name. E.g. node_modules/packageName/not/this/part.js // or node_modules/packageName const packageName = module.context.match( /[\\\\/]node_modules[\\\\/](.*?)([\\\\/]|$)/ )[1]; // npm package names are URL-safe, but some servers don't like @ symbols return `npm.$&#123;packageName.replace(\"@\", \"\")&#125;`; &#125; &#125; &#125; &#125; &#125;; &#125; Object.assign(config, &#123; // 开发生产共同配置 // externals: &#123; // 'vue': 'Vue', // 'element-ui': 'ELEMENT', // 'vue-router': 'VueRouter', // 'vuex': 'Vuex' // &#125; // 防止将某些 import 的包(package)打包到 bundle 中，而是在运行时(runtime)再去从外部获取这些扩展依赖(用于csdn引入) resolve: &#123; extensions: [\".js\", \".vue\", \".json\"], //文件优先解析后缀名顺序 alias: &#123; \"@\": path.resolve(__dirname, \"./src\"), \"@c\": path.resolve(__dirname, \"./src/components\"), \"@v\": path.resolve(__dirname, \"./src/views\"), \"@u\": path.resolve(__dirname, \"./src/utils\"), \"@s\": path.resolve(__dirname, \"./src/service\") &#125;, // 别名配置 plugins: [] &#125;, optimization: optimization2 &#125;); &#125;, // vue-loader 配置项 // https://vue-loader.vuejs.org/en/options.html // vueLoader: &#123;&#125;, // 生产环境是否生成 sourceMap 文件 productionSourceMap: false, // css相关配置 css: &#123; // 是否使用css分离插件 ExtractTextPlugin // extract: true, //注释css热更新生效 // 开启 CSS source maps? sourceMap: false, // css预设器配置项 loaderOptions: &#123;&#125;, // 启用 CSS modules for all css / pre-processor files. modules: false &#125;, // use thread-loader for babel &amp; TS in production build // enabled by default if the machine has more than 1 cores parallel: require(\"os\").cpus().length &gt; 1, // 是否启用dll // See https://github.com/vuejs/vue-cli/blob/dev/docs/cli-service.md#dll-mode // dll: false, // PWA 插件相关配置 // see https://github.com/vuejs/vue-cli/tree/dev/packages/%40vue/cli-plugin-pwa pwa: &#123;&#125;, // webpack-dev-server 相关配置 devServer: &#123; /* 自动打开浏览器 */ open: false, // host: \"192.168.0.137\", host: \"0.0.0.0\", //局域网和本地访问 //host: \"192.168.1.137\", port: 8080, https: false, hotOnly: false, /* 使用代理 */ proxy: &#123; \"/api\": &#123; /* 目标代理服务器地址 */ // target: \"http://192.168.0.106:8080/\", target: \"http://192.168.1.126:8080/\", //阳洋 /* 允许跨域 */ changeOrigin: true, ws: true, pathRewrite: &#123; \"^/api\": \"\" &#125; &#125; &#125;, before: () =&gt; &#123;&#125; &#125;, // 第三方插件配置 pluginOptions: &#123;&#125; &#125;; 之后运行打包命令即可 npm run build 清除缓存 tip: 直接在vue项目中新建vue.config.js，然后复制进去即可。 const path = require(\"path\"); // 获取当前时间戳 const Timestamp = new Date().getTime(); // 定义版本号 const VUE_APP_Version = '1.0.0' const resolve = function (dir) &#123; return path.join(__dirname, dir); &#125;; module.exports = &#123; configureWebpack: &#123; output: &#123; //输出重构，打包编译后的文件名称 【模块名称.版本号.时间戳】 filename: `[name].$&#123;VUE_APP_Version&#125;.$&#123;Timestamp&#125;.js`, chunkFilename: `[name].$&#123;VUE_APP_Version&#125;.$&#123;Timestamp&#125;.js` &#125; &#125;, publicPath: process.env.NODE_ENV === \"production\" ? \"./\" : \"./\", // publicPath: './', outputDir: \"dist\", assetsDir: \"static\", lintOnSave: true, // 是否开启eslint保存检测 productionSourceMap: false, // 是否在构建生产包时生成sourcdeMap chainWebpack: config =&gt; &#123; config.resolve.alias .set(\"@\", resolve(\"src\")) .set(\"@v\", resolve(\"src/views\")) .set(\"@c\", resolve(\"src/components\")) .set(\"@u\", resolve(\"src/utils\")) .set(\"@s\", resolve(\"src/service\")); /* 别名配置 */ config.optimization.runtimeChunk(\"single\"); &#125;, devServer: &#123; // host: \"localhost\", /* 本地ip地址 */ //host: \"192.168.1.107\", host: \"0.0.0.0\", //局域网和本地访问 port: \"8080\", hot: true, /* 自动打开浏览器 */ open: false, overlay: &#123; warning: false, error: true &#125;, /* 跨域代理 */ proxy: &#123; \"/api\": &#123; /* 目标代理服务器地址 */ target: \"http://m260048y71.zicp.vip\", // // target: \"http://192.168.1.102:8888\", // /* 允许跨域 */ changeOrigin: true, ws: true, pathRewrite: &#123; \"^/api\": \"\" &#125; &#125; &#125; &#125; &#125;;","permalink":"https://codermino.github.io/2020/08/14/vue-config-js%E9%85%8D%E7%BD%AE/","photos":[]},{"tags":[{"name":"ecahrts自适应和切换问题","slug":"ecahrts自适应和切换问题","permalink":"https://codermino.github.io/tags/ecahrts%E8%87%AA%E9%80%82%E5%BA%94%E5%92%8C%E5%88%87%E6%8D%A2%E9%97%AE%E9%A2%98/"}],"title":"ecahrts自适应和切换问题","date":"2020/08/14","text":"1、解决方法：监听屏幕的 onresize() 事件调用Echarts的resize()事件,代码如下： // 自适应屏幕宽度 window.onresize = function() &#123; myChart.resize(); myChart2.resize(); myChart3.resize(); myChart4.resize(); &#125;; 2、不要页面一加载就全部把页面中的图表都加载好，而是刚开始只渲染默认的第一个图表，其他的图表在tabs选项卡切换的时候再加载渲染出来就可以了，具体代码如下： &lt;template&gt; &lt;!-- 使用tabs选项卡子组件 --&gt; &lt;titleBar :indexRenshiMsg=\"renshiMsg\" @func=\"changeHandle\"&gt;&lt;/titleBar&gt; &lt;el-row style=\"margin-top:20px\"&gt; &lt;div id=\"renshichu\" :style=\"&#123;width: '100%', height: '400px'&#125;\"&gt;&lt;/div&gt; &lt;/el-row&gt; &lt;!-- 使用子组件 --&gt; &lt;titleBar :indexRenshiMsg=\"renshiMsg\" @func=\"changeHandle2\"&gt;&lt;/titleBar&gt; &lt;el-row style=\"margin-top:20px\"&gt; &lt;div id=\"zhinengbu\" :style=\"&#123;width: '100%', height: '400px'&#125;\"&gt;&lt;/div&gt; &lt;/el-row&gt; &lt;!-- 部门管理员权限 --&gt; &lt;titleBar :indexRenshiMsg=\"renshiMsg\" @func=\"changeHandle3\"&gt;&lt;/titleBar&gt; &lt;el-row style=\"margin-top:20px\"&gt; &lt;div id=\"bumengguanli\" :style=\"&#123;width: '100%', height: '400px'&#125;\"&gt;&lt;/div&gt; &lt;/el-row&gt; &lt;/template&gt; &lt;script&gt; import titleBar from \"../components/titleBar\"; // 指定图表的配置项和数据 var option = &#123; tooltip: &#123; trigger: \"axis\", axisPointer: &#123; type: \"cross\", crossStyle: &#123; color: \"#999\" &#125; &#125; &#125;, toolbox: &#123; feature: &#123; dataView: &#123; show: true, readOnly: false &#125;, magicType: &#123; show: true, type: [\"line\", \"bar\"] &#125;, restore: &#123; show: true &#125;, saveAsImage: &#123; show: true &#125; &#125; &#125;, color: [\"#3398DB\"], tooltip: &#123;&#125;, legend: &#123; data: [\"申报人数\"], left: \"left\", top: \"10%\", textStyle: &#123; fontSize: 16 &#125; &#125;, xAxis: &#123; data: [\"教授\", \"副教授\", \"讲师\", \"研究员\", \"副研究员\", \"助理研究员\"], axisLabel: &#123; fontSize: 20 //字体大小 &#125; &#125;, yAxis: [ &#123; type: \"value\", name: \"人数\", axisLabel: &#123; formatter: \"&#123;value&#125;\", fontSize: 20 //字体大小 &#125; &#125; ], series: [ &#123; barWidth: 50, name: \"申报人数\", type: \"bar\", data: [10, 3, 4, 4, 5, 4] &#125; ] &#125;; var option2 = &#123; tooltip: &#123; trigger: \"axis\", axisPointer: &#123; type: \"cross\", crossStyle: &#123; color: \"#999\" &#125; &#125; &#125;, toolbox: &#123; feature: &#123; dataView: &#123; show: true, readOnly: false &#125;, magicType: &#123; show: true, type: [\"line\", \"bar\"] &#125;, restore: &#123; show: true &#125;, saveAsImage: &#123; show: true &#125; &#125; &#125;, tooltip: &#123; trigger: \"axis\", axisPointer: &#123; type: \"cross\", crossStyle: &#123; color: \"#999\" &#125; &#125; &#125;, legend: &#123; data: [\"已审核\", \"未审核\", \"退回\"], left: \"left\", top: \"10%\", orient: \"vertical\", textStyle: &#123; fontSize: 20 &#125; &#125;, xAxis: &#123; type: \"category\", data: [\"论文著作\", \"项目获批\", \"荣誉获奖\"], axisPointer: &#123; type: \"shadow\" &#125;, axisLabel: &#123; fontSize: 20 //字体大小 &#125; &#125;, yAxis: [ &#123; type: \"value\", name: \"人数\", axisLabel: &#123; formatter: \"&#123;value&#125;\", fontSize: 20 //字体大小 &#125; &#125; ], series: [ &#123; barWidth: 50, name: \"已审核\", type: \"bar\", color: \"#92d050\", data: [10, 8, 6] &#125;, &#123; barWidth: 50, name: \"未审核\", type: \"bar\", color: \"#ed7d31\", data: [7, 5, 3] &#125;, &#123; barWidth: 50, name: \"退回\", type: \"bar\", color: \"#9cc3e5\", data: [4, 3, 1] &#125; ] &#125;; var option4 = &#123; tooltip: &#123; trigger: \"axis\", axisPointer: &#123; type: \"cross\", crossStyle: &#123; color: \"#999\" &#125; &#125; &#125;, toolbox: &#123; feature: &#123; dataView: &#123; show: true, readOnly: false &#125;, magicType: &#123; show: true, type: [\"line\", \"bar\"] &#125;, restore: &#123; show: true &#125;, saveAsImage: &#123; show: true &#125; &#125; &#125;, color: [\"#3398DB\"], tooltip: &#123;&#125;, legend: &#123; data: [\"数量\"], left: \"left\", top: \"10%\", textStyle: &#123; fontSize: 20 &#125; &#125;, xAxis: &#123; data: [\"论文发表\", \"著作发表\", \"项目立项\", \"获奖荣誉\", \"教学课程\"], axisLabel: &#123; fontSize: 20 //字体大小 &#125; &#125;, yAxis: [ &#123; type: \"value\", name: \"数量\", axisLabel: &#123; formatter: \"&#123;value&#125;\", fontSize: 20 //字体大小 &#125; &#125; ], series: [ &#123; barWidth: 50, name: \"数量\", type: \"bar\", data: [12, 4, 7, 4, 9, 33] &#125; ] &#125;; export default &#123; components: &#123; titleBar &#125;, name: \"index\", data() &#123; return &#123; num: 115, onePower: true, echartsTitle: \"评审年度 | 2020年\", echartsTitle4: \"个人档案库内情况\", xAxis: [\"教授\", \"副教授\", \"讲师\", \"研究员\", \"副研究员\", \"助理研究员\"], xAxis2: [\"论文著作\", \"项目获批\", \"荣誉获奖\"], xAxis4: [\"论文发表\", \"著作发表\", \"项目立项\", \"获奖荣誉\", \"教学课程\"], series: [10, 3, 4, 4, 5, 4], // 步骤条进度 active: 1, // 待办事项 backlog: 4, // 传给子组件的参数 renshiMsg: &#123; title: \"评审年度 | 2020年\", msg: \"申报人数：\", number: 49 &#125;, chartOptions: [option, option2, option4], tableData: [ &#123; category: \"论文\", research: \"基于C51单片机的全球导弹发射控制系统\", opinion: \"这是一个非常好的想法\", name: \"张三\" &#125;, &#123; category: \"项目\", research: \"基于C51单片机的全球导弹发射控制系统\", opinion: \"这是一个非常好的想法\", name: \"张三\" &#125;, &#123; category: \"获奖\", research: \"全球和平伟大贡献奖\", opinion: \"这是一个非常好的想法\", name: \"张三\" &#125;, &#123; category: \"论文\", research: \"基于C51单片机的全球导弹发射控制系统\", opinion: \"这是一个非常好的想法\", name: \"张三\" &#125;, &#123; category: \"论文\", research: \"基于C51单片机的全球导弹发射控制系统\", opinion: \"这是一个非常好的想法\", name: \"张三\" &#125; ] &#125;; &#125;, mounted() &#123; // 人事处管理员审核权限统计图 var dom = document.getElementById(\"renshichu\"); var myChart = this.echarts.init(dom); myChart.setOption(this.chartOptions[0]); // 职能部门审核用户权限统计图 var dom2 = document.getElementById(\"zhinengbu\"); var myChart2 = this.echarts.init(dom2); myChart2.setOption(this.chartOptions[1]); // 部门管理员权限统计图 var dom3 = document.getElementById(\"bumengguanli\"); var myChart3 = this.echarts.init(dom3); myChart3.setOption(this.chartOptions[2]); // 普通教师权限统计图 var dom4 = document.getElementById(\"jiaoshiquanxian\"); var myChart4 = this.echarts.init(dom4); myChart4.setOption(this.chartOptions[2]); // 自适应屏幕宽度 window.onresize = function() &#123; myChart.resize(); myChart2.resize(); myChart3.resize(); myChart4.resize(); &#125;; &#125;, methods: &#123; // 下面的几个函数都是tabs选项卡切换的点击事件 changeHandle(e) &#123; // 人事处管理员审核权限统计图 var dom = document.getElementById(\"renshichu\"); var myChart = this.echarts.init(dom); myChart.clear(); myChart.setOption(this.chartOptions[e]); &#125;, changeHandle2(e) &#123; // 职能部门审核用户权限统计图 var dom2 = document.getElementById(\"zhinengbu\"); var myChart2 = this.echarts.init(dom2); myChart2.clear(); myChart2.setOption(this.chartOptions[e]); &#125;, changeHandle3(e) &#123; // 职能部门审核用户权限统计图 var dom3 = document.getElementById(\"bumengguanli\"); var myChart3 = this.echarts.init(dom3); myChart3.clear(); myChart3.setOption(this.chartOptions[e]); &#125; &#125; &#125;; &lt;/script&gt;","permalink":"https://codermino.github.io/2020/08/14/ecahrts%E8%87%AA%E9%80%82%E5%BA%94%E5%92%8C%E5%88%87%E6%8D%A2%E9%97%AE%E9%A2%98/","photos":[]},{"tags":[{"name":"scrapy的shell的使用","slug":"scrapy的shell的使用","permalink":"https://codermino.github.io/tags/scrapy%E7%9A%84shell%E7%9A%84%E4%BD%BF%E7%94%A8/"}],"title":"scrapy的shell的使用","date":"2020/07/26","text":"scrapy shell 网址 然后可以在Terminal中使用tab键进行代码提示(但是可能会出现warning等提示信息，扰乱界面) 可以在settings.py中 import logging logging.getLogger('parso').setLevel(logging.WARNING)","permalink":"https://codermino.github.io/2020/07/26/scrapy%E7%9A%84shell%E7%9A%84%E4%BD%BF%E7%94%A8/","photos":[]},{"tags":[{"name":"scrapy添加cookie的三种方式","slug":"scrapy添加cookie的三种方式","permalink":"https://codermino.github.io/tags/scrapy%E6%B7%BB%E5%8A%A0cookie%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/"}],"title":"scrapy添加cookie的三种方式","date":"2020/07/26","text":"settings中添加 settings文件中给Cookies_enabled=False解注释 settings的headers配置的cookie就可以用了 这种方法最简单，同时cookie可以直接粘贴浏览器的。 后两种方法添加的cookie是字典格式的，需要用json反序列化一下, 而且需要设置settings中的Cookies_enabled=True eq:cookie = &#123;k1: v1, k2: v2&#125; DownloadMiddleware中添加 settings中给downloadmiddleware解注释 去中间件文件中找downloadmiddleware这个类， 修改process_request，添加request.cookies=&#123;&#125;即可。 爬虫主文件中重写start_request def start_requests(self): yield scrapy.Request(url,dont_filter=True,cookies=&#123;自己的cookie&#125;) 方法三的Demo1 import scrapy class ItaobaoSpider(scrapy.Spider): name = 'itaobao' allowed_domains = ['taobao.com'] # start_urls = ['https://cart.taobao.com/cart.htm?spm=a1z02.1.a2109.d1000367.OOeipq&amp;nekot=1470211439694'] # 需要重写start_requests方法 def start_requests(self): url = \"https://cart.taobao.com/cart.htm?spm=a1z02.1.a2109.d1000367.OOeipq&amp;nekot=1470211439694\" # 此处的cookie为手动登录后从浏览器粘贴下来的值 cookie = \"thw=cn; cookie2=16b0fe13709f2a71dc06ab1f15dcc97b; _tb_token_=fe3431e5fe755;\" \\ \" _samesite_flag_=true; ubn=p; ucn=center; t=538b39347231f03177d588275aba0e2f;\" \\ \" tk_trace=oTRxOWSBNwn9dPyorMJE%2FoPdY8zfvmw%2Fq5hoqmmiKd74AJ%2Bt%2FNCZ%\" \\ \"2FSIX9GYWSRq4bvicaWHhDMtcR6rWsf0P6XW5ZT%2FgUec9VF0Ei7JzUpsghuwA4cBMNO9EHkGK53r%\" \\ \"2Bb%2BiCEx98Frg5tzE52811c%2BnDmTNlzc2ZBkbOpdYbzZUDLaBYyN9rEdp9BVnFGP1qVAAtbsnj35zfBVfe09E%\" \\ \"2BvRfUU823q7j4IVyan1lagxILINo%2F%2FZK6omHvvHqA4cu2IaVAhy5MzzodyJhmXmOpBiz9Pg%3D%3D; \" \\ \"cna=5c3zFvLEEkkCAW8SYSQ2GkGo; sgcookie=E3EkJ6LRpL%2FFRZIBoXfnf; unb=578051633; \" \\ \"uc3=id2=Vvl%2F7ZJ%2BJYNu&amp;nk2=r7kpR6Vbl9KdZe14&amp;lg2=URm48syIIVrSKA%3D%3D&amp;vt3=F8dBxGJsy36E3EwQ%2BuQ%3D;\" \\ \" csg=c99a3c3d; lgc=%5Cu5929%5Cu4ED9%5Cu8349%5Cu5929%5Cu4ED9%5Cu8349; cookie17=Vvl%2F7ZJ%2BJYNu;\" \\ \" dnk=%5Cu5929%5Cu4ED9%5Cu8349%5Cu5929%5Cu4ED9%5Cu8349; skt=4257a8fa00b349a7; existShop=MTU5MzQ0MDI0MQ%3D%3D;\" \\ \" uc4=nk4=0%40rVtT67i5o9%2Bt%2BQFc65xFQrUP0rGVA%2Fs%3D&amp;id4=0%40VH93OXG6vzHVZgTpjCrALOFhU4I%3D;\" \\ \" tracknick=%5Cu5929%5Cu4ED9%5Cu8349%5Cu5929%5Cu4ED9%5Cu8349; _cc_=W5iHLLyFfA%3D%3D; \" \\ \"_l_g_=Ug%3D%3D; sg=%E8%8D%893d; _nk_=%5Cu5929%5Cu4ED9%5Cu8349%5Cu5929%5Cu4ED9%5Cu8349;\" \\ \" cookie1=VAmiexC8JqC30wy9Q29G2%2FMPHkz4fpVNRQwNz77cpe8%3D; tfstk=cddPBI0-Kbhyfq5IB_1FRmwX4zaRClfA\" \\ \"_qSREdGTI7eLP5PGXU5c-kQm2zd2HGhcE; mt=ci=8_1; v=0; uc1=cookie21=VFC%2FuZ9ainBZ&amp;cookie15=VFC%2FuZ9ayeYq2g%3D%3D&amp;cookie\" \\ \"16=WqG3DMC9UpAPBHGz5QBErFxlCA%3D%3D&amp;existShop=false&amp;pas=0&amp;cookie14=UoTV75eLMpKbpQ%3D%3D&amp;cart_m=0;\" \\ \" _m_h5_tk=cbe3780ec220a82fe10e066b8184d23f_1593451560729; _m_h5_tk_enc=c332ce89f09d49c68e13db9d906c8fa3; \" \\ \"l=eBxAcQbPQHureJEzBO5aourza7796IRb8sPzaNbMiInca6MC1hQ0PNQD5j-MRdtjgtChRe-PWBuvjdeBWN4dbNRMPhXJ_n0xnxvO.; \" \\ \"isg=BJ2drKVLn8Ww-Ht9N195VKUWrHmXutEMHpgqKF9iKfRAFrxIJAhD3DbMRAoQ1unE\" cookies = &#123;&#125; # 提取键值对 请求头中携带cookie必须是一个字典，所以要把原生的cookie字符串转换成cookie字典 for cookie in cookie.split(';'): key, value = cookie.split(\"=\", 1) cookies[key] = value yield scrapy.Request(url=url, cookies=cookies, callback=self.parse) def parse(self, response): print(response.text) 方法三的Demo1的最终cookie的dict形式 cookie = &#123;'ll': '\"108090\"', ' bid': 'LKyRKxbzn_E', ' _pk_ses.100001.8cb4': '*', ' __utma': '30149280.1348080368.1556600783.1556600783.1556600783.1', ' __utmc': '30149280', ' __utmz': '30149280.1556600783.1.1.utmcsr', ' __utmt': '1', ' dbcl2': '\"177745320:ER12/4y8Vxk\"', ' ck': '9SGi', ' _pk_id.100001.8cb4': 'fc3beca6f0344a06.1556600779.1.1556600805.1556600779.', ' push_noty_num': '0', ' push_doumail_num': '0', ' __utmv': '30149280.17774', ' __utmb': '30149280.3.10.1556600783', ' ap_v': '0,6.0'&#125; def start_requests(self): yield scrapy.Request(self.profile_url, callback=self.parse_profile, cookies=self.cookie) 方法三的Demo2 def start_requests(self): \"\"\" 根据cookies模拟登陆人人网，注意settings.py文件的cookies必须是开启的 :return: \"\"\" cookies=\"anonymid=jxcn09d5-vd52v0; depovince=GUZ; _r01_=1; ick_login=d41bb8a9-056b-41a7-b187-7c706f0f8702; ick=39b091b8-f882-499b-992b-34a682d3469a; JSESSIONID=abcHJrhG1CAIo64PJRrUw; jebe_key=9ca5b44f-aaec-4180-962e-bf7581ad6e5e%7Cc1d85b293dafa0e44367ceed107b877e%7C1561517245262%7C1%7C1561517244004; jebe_key=9ca5b44f-aaec-4180-962e-bf7581ad6e5e%7Cc1d85b293dafa0e44367ceed107b877e%7C1561517245262%7C1%7C1561517244011; wp_fold=0; td_cookie=18446744069457827825; jebecookies=e9de8580-fb15-4891-b7c3-7c08ebb41f5c|||||; _de=AE9934B6C85831351B86F7DDD5B20F8A; p=b25ab0edb69343d7f80c5e481864b8c30; first_login_flag=1; ln_uact=18620028487; ln_hurl=http://head.xiaonei.com/photos/0/0/men_main.gif; t=b8a0d848e228dd51d2c84609f814495b0; societyguester=b8a0d848e228dd51d2c84609f814495b0; id=971298880; xnsid=6e5116da; ver=7.0; loginfrom=null\" cookies = &#123;i.split(\"=\")[0]:i.split(\"=\")[1] for i in cookies.split(\"; \")&#125; yield scrapy.Request( self.start_urls[0], callback=self.parse, cookies=cookies )","permalink":"https://codermino.github.io/2020/07/26/scrapy%E6%B7%BB%E5%8A%A0cookie%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/","photos":[]},{"tags":[{"name":"scrapy爬虫细节","slug":"scrapy爬虫细节","permalink":"https://codermino.github.io/tags/scrapy%E7%88%AC%E8%99%AB%E7%BB%86%E8%8A%82/"}],"title":"scrapy爬虫细节","date":"2020/07/25","text":"scrapy.Request相关 yield scrapy.Request( url, callback, meta = &#123;\"item\":item&#125; ) 在对应的callback函数中可以使用下面的代码，接收上一个函数传递过来的参数。 item=response.meta['key'] 使用for...in 循环导致数据重复问题 在scrapy中使用了for in 循环，由于是多线程，如果还需要继续scrapy.Request进行请求更深的页面数据。 可以使用form copy import deepcopy 进行深拷贝。 可以防止scrapy多线程导致item的数据重复(上一个数据传递过来之后，后面的数据还没有解析完成， 下一个for循环，将传递下去的item的某些字段覆盖，从而可能导致重复) scrapy翻页 response.text =&gt; unicode编码返回body部分，等同于 response.body.decode(response.encoding) page_count = int(re. findall(\"var pagecount=.7);, response.body.decode())[0]) current_page = int(re. findall\"var currentPage=.2);, response.body.decode())[0] if current_page page_count: next_url item[\"s_href\"] +\"?pageNumber=[&amp;sort=\". format(current_page 1) yield scrapy. Request( next_url, callback=self.parse_book_list, meta = &#123;\"item\":response.meta[\"item\"]&#125; ) 创建CrawlSpider爬虫简要步骤 1.创建项目文件： scrapy startproject douyu 2.进入项目文件： cd douyu 3.创建爬虫 scrapy genspider -t crawl dy 'douyu.com' 正则的使用 def parse_item(self, response): item = &#123;&#125; item[\"title\"]=re.findall(\"&lt;!---TitleStart--&gt;(.*)&lt;--TitleEnd---&gt;\", response.body. decode())[0] item[\"publish_date\"] = re.findall(\"发布时间:(20\\d&#123;2&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;)\", response.body. decode())[0] CrawlSpider补充知识 CrawlSpider补充(了解) LinkExtractor更多常见参数: allow:满足括号中“正则表达式的URL会被提取,如果为空,则全部匹配。 (就是在当前的爬虫的页面，如果为True就会寻找当前页面是否有满足当前rule的连接，如果为False就不会继续寻找) deny:满足括号中“正则表达式\"的URL一定不提取(优先级高于 allow) allow_domains:会被提取的链接的 domains. deny_domains:一定不会被提取链接的 domains restrict_xpaths:使用 xpath表达式和 allow共同作用过滤链接,级 xpath足范围内的ur地址会被提取 spiders.rule常见参数: linkextractor:是一个 Link Extractor对象,用于定义需要提取的链接。 calLback:从linkextractor中每获取到链接时,参数所指定的值作为回调函数 follow:是一个布尔(boolean)值,指定了根据该规则从 response提取的链接是否需要跟进。 如果 callback为none, follow默认设置为Tre,否则默认为 False process_links:指定该 spider中哪个的函数将会被调用,从 linkextractor中获取到链接列表时将会调用该函数, 该方法主要用来过滤url process_request:指定该 spider中哪个的函数将会被调用,该规则提取到每个 request时都会调用该函数, 用来过滤 request 模拟登录的原因 scrapy模拟登陆 为什么需要模拟登陆? 获取 cookie,能够爬取登陆后的页面 回顾: requests是如何模拟登陆的? 1、直接携带 cookies请求页面 2、找接口发送post请求 cookie存储 selenium是如何模拟登陆的? 找到对应的 input标签,输入文字点击登录 dir函数的使用 在python2.7中, dir(response)查看response内置函数可以找到decode, encode()方法。 class CheckUserAgent: def process_response(self, request, response, spider): print(dir(response)) print(request.headers[User-Agent\"]) 添加代理 class RandomUserAgent(object): def process_request(self, request, spider): useragent= random.choice(UER_AGENTS) request.headers[\"User-Agent\"] = useragent #添加自定义的UA,给 requestheaders的赋值即可 class ProxyMiddleware(object) def process_request(self, request, spider): reqeust.meta [\"proxy\"] = \"http://124.115.126.76: 808\" #添加代理,需要在request的mea信息中添加字段 #代理的形式为:协议+ip地址+端口 发送post请求 使用scrapr.Request的时候一直是发送的get请求， 那么post请求就是需要使用scrapy.FormRequest来发送， 同时使用formdata来携带需要post的数据 scrapy模拟登陆之发送post请求 class GithubSpider(scrapy.Spider): name =github' allowed_domains ['github.com'] start_urls = ['https://github.com/login' -请求首页,为了获取登录参数 headers =&#123; \"Accept\":\"**\", \"Accept-Language\": \"en-US, en;q=. 8, zh-TW;q=0.6, zh; q=0.4\", &#125; def parse(self, response): print(response.url) utf8 = response.xpath(\"//form[@action='/session']/div[1]/input[1]/@value\").extract_first() authenticity_token = response.xpath(\"//form[@action='/session']/div[1]/input[2]/@value\").extract_first() return scrapy.FormRequest( \"https://github.com/session\", headers=self.headers, #可以在spider中定义,也可以在 setting中定义 formdata = dict( commit=\"Sign in\", utf8=utf8, authenticity_token=authenticity_token, login=\"user_name\",(对应的标签的name) password=\"password\"(对应的标签的name) ), callbackself = self.after_login #登录之后的回调函数 ) def after_login(self, response): print(response.url,\"*\"*100, response.status) 注意 : github的部分页面只允许一处登录,比如https:/github.comsettings/security 自动寻找post的action进行提交 import scrapy import re class Github2Spider(scrapy.Spider): name =github2' allowed_domains ['github.com'] start_urls =['https://github.com/login'] def parse(self, response): yield scrapy.FormRequest.from_response( response, #自动的从response中寻找from表单 formdata = &#123;\"login\":\"noobpythoner\",\"password\":\"zhoudawei1123\"&#125;, callback=self.after_login ) def after_login(self, response): print(re.findall(\"noobpythoner|NoobPythoner\", response.body.decode())) xpath的contains语法 div_list = response.xpath(\"//div[contains(@class,'i')]) 提取下一页的文本 next_url = response.xpath(\"//a[text()='下一页']/@href).extract_first() if next_url is not None: next_url = urllib","permalink":"https://codermino.github.io/2020/07/25/scrapy%E7%88%AC%E8%99%AB%E7%BB%86%E8%8A%82/","photos":[]},{"tags":[{"name":"Excel打开UTF8编码CSV文件乱码","slug":"Excel打开UTF8编码CSV文件乱码","permalink":"https://codermino.github.io/tags/Excel%E6%89%93%E5%BC%80UTF8%E7%BC%96%E7%A0%81CSV%E6%96%87%E4%BB%B6%E4%B9%B1%E7%A0%81/"}],"title":"Excel打开UTF8编码CSV文件乱码","date":"2020/07/25","text":"1. 新建一个excel表格 2. 执行“数据”-&gt;“自文本” 3. 选择 CSV 文件，出现文本导入向导 4. 选择“分隔符号”，下一步 5. 勾选“逗号”，去掉“ Tab 键”，下一步，完成 6. 在“导入数据”对话框里，直接点确定","permalink":"https://codermino.github.io/2020/07/25/Excel%E6%89%93%E5%BC%80UTF8%E7%BC%96%E7%A0%81CSV%E6%96%87%E4%BB%B6%E4%B9%B1%E7%A0%81/","photos":[]},{"tags":[{"name":"scrapy保存图片","slug":"scrapy保存图片","permalink":"https://codermino.github.io/tags/scrapy%E4%BF%9D%E5%AD%98%E5%9B%BE%E7%89%87/"}],"title":"scrapy保存图片","date":"2020/07/12","text":"为什么使用ImagesPipelines进行图片下载 1. 避免重新下载最近已经下载过的数据 2. 可以方便的指定文件存储的路径 3. 可以将下载的图片转换成通用的格式。比如png或jpg 4. 可以方便的成成缩略图 5. 可以方便的检测图片的宽和高，确保他们满足最小限制 6. 异步下载，效率非常高 crawl.py文件内容 import scrapy from bmw.items import BmwItem #引入item文件的BmwItem类 class Bmw5Spider(scrapy.Spider): name = 'bmw5' start_urls = ['https://car.autohome.com.cn/pic/series/4350.html'] def parse(self, response): uiboxs=response.xpath(\"//div[@class='uibox']\")[1:] for uibox in uiboxs: title=uibox.xpath(\".//div[@class='uibox-title']/a/text()\").get() #获取分类的标题 images=uibox.xpath(\".//ul/li/a/img/@src\").getall() #获取所有图片的url地址 urls=list(map(lambda url:response.urljoin(url),images)) #将图片的url地址进行处理，前面加上https:// item=BmwItem(title=title,image_urls=urls) #进行包装 yield item #返回给items.py文件 items.py文件内容 import scrapy class BmwItem(scrapy.Item): title=scrapy.Field() #用来存储图片分类的名称标题 image_urls=scrapy.Field() #用来存储需要下载的图片的url images=scrapy.Field() #用来保存下载之后图片的本地路径 方法一、同步的方式进行图片下载 这样下载的方式是一个一个的下载，下载的效率比较低， 同步的方式进行下载 import os from urllib import request class BmwPipeline(object): def __init__(self): #os.path.dirname(__file__)获得当前文件所在的上级目录 #创建项目工程下的iamges文件夹 self.path=os.path.join(os.path.dirname(os.path.dirname(__file__)),'images') #判断images文件夹是否存在，如果不存在则创建 if not os.path.exists(self.path): os.mkdir(self.path) #这个函数会自动调用,每次爬取一个item就会调用一次进行数据的处理 def process_item(self, item, spider): title=item['title'] #图片所在分类的标题 urls=item['image_urls'] #分类下图片的url地址 category_path=os.path.join(self.path,title) #创建分类文件夹 if not os.path.exists(category_path): os.mkdir(category_path) #遍历urls数组，进行图片下载 for url in urls: image_name=url.split('_')[-1] #按照_进行拆分得到图片的名称 request.urlretrieve(url,os.path.join(category_path,image_name)) #进行图片的下载 return item 对应的settings.py文件内容 ITEM_PIPELINES = &#123; 'bmw.pipelines.BmwPipeline': 300, #开启pipelines &#125; 方法二、使用scrapy自带的ImagesPipeline settings.py文件的内容 IMAGES_EXPIRES = 90 # 90天内抓取的都不会被重抓 ITEM_PIPELINES = &#123; 'scrapy.pipelines.images.ImagesPipeline': 1, &#125; 方法三、重写ImagesPipeline---Demo1 import os from urllib import request from scrapy.pipelines.images import ImagesPipeline from bmw import settings #继承了ImagesPipeline这个类 class BMWImagePipeline(ImagesPipeline): def get_media_requests(self, item, info): #这个方法是在发送下载请求之前调用 #其实这个方法本身就是去发送下载请求的 request_objs=super(BMWImagePipeline, self).get_media_requests(item,info) for request_obj in request_objs: request_obj.item=item return request_objs # 我们可以通过继承FilesPipeline重写file_path() # 方法来重定义文件名 def file_path(self, request, response=None, info=None): #这个方法是在图片将要被存储的时候调用的，来获取这个图片存储的路径 path=super(BMWImagePipeline, self).file_path(request,response,info) category=request.item.get('title') image_store=settings.IMAGES_STORE category_path=os.path.join(image_store,category) if not os.path.exists(category_path): os.mkdir(category_path) image_name=path.replace(\"full/\",'') image_path=os.path.join(category_path,image_name) return image_path def item_completed(self, results, item, info): \"\"\" 将图片的本地路径赋值给item['image_paths'] :param results:下载结果，二元组定义如下：(success, image_info_or_failure)。 第一个元素表示图片是否下载成功；第二个元素是一个字典。 如果success=true，image_info_or_error词典包含以下键值对。失败则包含一些出错信息。 字典内包含* url：原始URL * path：本地存储路径 * checksum：校验码 :param item: :param info: :return: \"\"\" # print(results) image_paths = [x['path'] for ok, x in results if ok] if not image_paths: raise DropItem(\"Item contains no images\") # 如果没有路径则抛出异常 item['images'] = image_paths return item 方法三、重写ImagesPipeline---Demo2 #引入其他所需的相关模块 from scrapy import Request from scrapy.exceptions import DropItem category = '' #继承了ImagesPipeline这个类 class BMWImagePipeline(ImagesPipeline): global category #用来存储下载的图片所属的分类标题 category = item['title'] for img_url in item['image_urls']: #遍历image_urls并发起请求 yield Request(img_url) # 我们可以通过继承FilesPipeline重写file_path() # 方法来重定义文件名 def file_path(self, request, response=None, info=None): image_store=settings.IMAGES_STORE #获取settings.py中配置的图片下载路径 category_path=os.path.join(image_store,category) #创建分类名称文件夹 if not os.path.exists(category_path): #不存在则进行创建 os.mkdir(category_path) image_name = request.url.split(\"__\")[-1] #将图片的url地址按照_进行拆分得到图片的名称 return os.path.join(category_path,image_name) #拼接下载的图片的路径 def item_completed(self, results, item, info): \"\"\" 将图片的本地路径赋值给item['image_paths'] :param results:下载结果，二元组定义如下：(success, image_info_or_failure)。 第一个元素表示图片是否下载成功；第二个元素是一个字典。 如果success=true，image_info_or_error词典包含以下键值对。失败则包含一些出错信息。 字典内包含* url：原始URL * path：本地存储路径 * checksum：校验码 :param item: :param info: :return: \"\"\" # print(results) #results 数组第一个参数为表示图片是否下载成功；第二个元素是一个字典。 #ok, x in results 遍历results数组 if ok 成立 去除x['path']并且包装成数组返回给image_paths image_paths = [x['path'] for ok, x in results if ok] if not image_paths: raise DropItem(\"Item contains no images\") # 如果没有路径则抛出异常 item['images'] = image_paths #将下载之后的图片的本地路径保存在items.py的images中 #也可以在这里使用os.rename进行文件的重命名 return item Demo2对应的settings.py文件配置 #设置图片的存储路径 IMAGES_STORE=os.path.join(os.path.dirname(os.path.dirname(__file__)),'images4') #90天内抓取的都不会被重抓 IMAGES_EXPIRES = 90 #90天内抓取的都不会被重抓 ITEM_PIPELINES = &#123; 'bmw.pipelines.BMWImagePipeline':1 &#125; ImagesPipelines的其他作用---保存缩略图 settings.py文件的相关配置 # 设置图片缩略图 IMAGES_THUMBS = &#123; 'small': (50, 50), 'big': (250, 250), &#125; # 图片过滤器，最小高度和宽度，低于此尺寸不下载 # 注意：这些尺寸的限制不会影响缩略图生成 # 默认情况下，没有限制，所有的图片都会被处理。 IMAGES_MIN_HEIGHT = 70 IMAGES_MIN_WIDTH = 70 piplines文件内容---更改thumbs缩略图保存的文件路径 def thumb_path(self, request, thumb_id, response=None, info=None): ## start of deprecation warning block (can be removed in the future) def _warn(): from scrapy.exceptions import ScrapyDeprecationWarning import warnings warnings.warn('ImagesPipeline.thumb_key(url) method is deprecated, please use ' 'thumb_path(request, thumb_id, response=None, info=None) instead', category=ScrapyDeprecationWarning, stacklevel=1) # check if called from thumb_key with url as first argument if not isinstance(request, Request): _warn() url = request else: url = request.url # detect if thumb_key() method has been overridden if not hasattr(self.thumb_key, '_base'): _warn() return self.thumb_key(url, thumb_id) ## end of deprecation warning block thumb_guid = hashlib.sha1(to_bytes(url)).hexdigest() # change to request.url after deprecation return 'thumbs/%s/%s/%s.jpg' % (category,thumb_id, thumb_guid)","permalink":"https://codermino.github.io/2020/07/12/scrapy%E4%BF%9D%E5%AD%98%E5%9B%BE%E7%89%87/","photos":[]},{"tags":[{"name":"scrapy数据保存为xml格式","slug":"scrapy数据保存为xml格式","permalink":"https://codermino.github.io/tags/scrapy%E6%95%B0%E6%8D%AE%E4%BF%9D%E5%AD%98%E4%B8%BAxml%E6%A0%BC%E5%BC%8F/"}],"title":"scrapy数据存为xml格式","date":"2020/07/12","text":"scrapy crawl myspider -o data.xml","permalink":"https://codermino.github.io/2020/07/12/scrapy%E6%95%B0%E6%8D%AE%E5%AD%98%E4%B8%BAxml%E6%A0%BC%E5%BC%8F/","photos":[]},{"tags":[{"name":"scrapy数据存入csv文件","slug":"scrapy数据存入csv文件","permalink":"https://codermino.github.io/tags/scrapy%E6%95%B0%E6%8D%AE%E5%AD%98%E5%85%A5csv%E6%96%87%E4%BB%B6/"}],"title":"scrapy数据存入csv文件","date":"2020/07/11","text":"方法一、通过终端方式 scrapy crawl name(爬虫名字) -o result.csv tip: #在pycharm中可以新建一个start.py加入如下内容，然后运行即可 from scrapy import cmdline cmdline.execute(\"scrapy crawl field(爬虫名字) -o info.csv -t csv\".split()) 方法一、通过pipelines方式 from scrapy.exporters import CsvItemExporter class CsvPipeline（object）： def __init __（self）： self.file = open（“xxx.csv”，'wb'） self.exporter = CsvItemExporter（self.file， encoding='utf-8'） self.exporter.start_exporting（） def close_spider（ self，spider）： self.exporter.finish_exporting（） self.file.close（） def process_item（self，item，spider）： self.exporter.export_item（item） return item Demo2--pipelines方式 import csv class MyProjectPipeline(object): # 保存为csv格式 def __init__(self): # 打开文件，指定方式为写，利用第3个参数把csv写数据时产生的空行消除 self.f = open(\"myproject.csv\",\"a\",newline=\"\") # 设置文件第一行的字段名，注意要跟spider传过来的字典key名称相同 self.fieldnames = [\"goods_sketch\",\"goods_img\",\"good_price\",\"goods_shop\",\"b_href\",\"title\"] # 指定文件的写入方式为csv字典写入，参数1为指定具体文件，参数2为指定字段名 self.writer = csv.DictWriter(self.f, fieldnames=self.fieldnames) # 写入第一行字段名，因为只要写入一次，所以文件放在__init__里面 self.writer.writeheader() def process_item(self, item, spider): # 写入spider传过来的具体数值 self.writer.writerow(item) # 写入完返回 return item def close(self,spider): self.f.close()","permalink":"https://codermino.github.io/2020/07/11/scrapy%E6%95%B0%E6%8D%AE%E5%AD%98%E5%85%A5csv%E6%96%87%E4%BB%B6/","photos":[]},{"tags":[{"name":"scrapy数据存入json文件","slug":"scrapy数据存入json文件","permalink":"https://codermino.github.io/tags/scrapy%E6%95%B0%E6%8D%AE%E5%AD%98%E5%85%A5json%E6%96%87%E4%BB%B6/"}],"title":"scrapy数据写入json文件","date":"2020/07/11","text":"方法一、使用终端命令 scrapy crawl novel -o novel.json 方法二、使用pipelines from scrapy.exporters import JsonItemExporter # JsonItemExporter：一次性写入大量数据，占用内存 from scrapy.exporters import JsonLinesItemExporter # 逐条写入 class JsonPipeline(object): def __init__(self): self.fp = open('sftaobao.json', 'wb') # ensure_ascii=False:以中文字符保存 self.exporter = JsonItemExporter(self.fp, ensure_ascii=False, encoding='utf-8') # JsonLinesItemExporter：一个字典一行，整个文件不满足json格式的；数据都直接存到磁盘文件中，内存占用少. # self.exporter = JsonLinesItemExporter(self.fp, ensure_ascii=False, encoding='utf-8') #不需要start_exporting和finish_exporting self.exporter.start_exporting() # 以标识 exporting 过程的开始。 def open_sprider(self): pass def process_item(self, item, spider): self.exporter.export_item(item) return item def close_sprider(self, spider): self.exporter.finish_exporting() # 以标识 exporting 过程的结束 self.fp.close() 方法三、文件读写方式 import json class JsonWriterPipeline(object): def open_spider(self, spider): #在爬虫开启的时候执行,仅执行一次 self. file =open(spider. settings.get( \"SAVE_FILE\", \"./temp.json\"), 'w') def close_spider(self, spider): #在爬虫关闭的时候执行,仅执行一次 self.file.close() def process_item(self, item, spider): line=json. dumps(dict(item))+\"\\n\" self.file.write(line) return item #不return的情况下,另个一个权重较低的 pipeline就不会获取到该item","permalink":"https://codermino.github.io/2020/07/11/scrapy%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5json%E6%96%87%E4%BB%B6/","photos":[]},{"tags":[{"name":"scrapy数据存入redis","slug":"scrapy数据存入redis","permalink":"https://codermino.github.io/tags/scrapy%E6%95%B0%E6%8D%AE%E5%AD%98%E5%85%A5redis/"}],"title":"scrapy数据存入redis","date":"2020/07/11","text":"import redis class QiubaiproPipelineByRedis(object): conn = None def open_spider(self,spider): print('开始爬虫') # 创建链接对象 self.conn = redis.Redis(host='127.0.0.1',port=6379) def process_item(self, item, spider): dict = &#123; 'author':item['author'], 'content':item['content'] &#125; # 写入redis中 self.conn.lpush('data', dict) return item from scrapy.exceptions import DropItem def process_item(self, item, spider): #当添加失败的时候会返回一个0 if self.conn.sadd('data',item['author']) return item #丢掉不符合条件的item raise DropItem","permalink":"https://codermino.github.io/2020/07/11/scrapy%E6%95%B0%E6%8D%AE%E5%AD%98%E5%85%A5redis/","photos":[]},{"tags":[{"name":"scrapy数据存入mongodb","slug":"scrapy数据存入mongodb","permalink":"https://codermino.github.io/tags/scrapy%E6%95%B0%E6%8D%AE%E5%AD%98%E5%85%A5mongodb/"}],"title":"scrapy数据存入mongodb","date":"2020/07/11","text":"存入mongodb def __init__(self): host = settings['MONGODB_HOST'] #数据库的host 如:127.0.0.1 port = settings['MONGODB_PORT'] #数据库端口号 如：27017 dbname = settings['MONGODB_DBNAME'] #数据库名称 如:XXX # 创建数据库连接 client = pymongo.MongoClient(host=host, port=port) # 指向指定数据库 mdb = client[dbname] # 获取数据库里面存放数据的表名 self.post = mdb[settings['MONGODB_DOCNAME']] def process_item(self, item, spider): data = dict(item) # 向指定的表里添加数据 self.post.insert(data) return item Demo2 from pymongo import MongoClient class xxxPipeline(object): def open_spider(self,spider): client = MongoClient() self.collection = client['test']['test'] def process_item(self,item,spider): spider.setting,get('MONGO_HOST') item['content'] = self.process_content(item['content']) print(item) return item def process_content(self,content): content = [re.sub(r\"\\xa0|\\s\",\"\",i) for i in content] content = [i for i in content if len(i)&gt;0] #去除列表中的空字符串 return content","permalink":"https://codermino.github.io/2020/07/11/scrapy%E6%95%B0%E6%8D%AE%E5%AD%98%E5%85%A5mongodb/","photos":[]},{"tags":[{"name":"scrapy数据存入mysql","slug":"scrapy数据存入mysql","permalink":"https://codermino.github.io/tags/scrapy%E6%95%B0%E6%8D%AE%E5%AD%98%E5%85%A5mysql/"}],"title":"scrapy数据存入mysql","date":"2020/07/11","text":"1、同步方式 import pymysql #引入相关库 class MysqlPipeline(object): \"\"\" 同步操作 \"\"\" def __init__(self): # 建立连接,下面是两种方式 1. self.conn = pymysql.connect( host='localhost', db='bole', user='root', passwd='123456', charset='utf8', port=330, use_unicode=True) 2. self.conn = pymysql.connect('localhost','root','Abcd1234','test') # 有中文要存入数据库的话要加charset='utf8' # 创建游标 self.cursor = self.conn.cursor() #每爬取到一条数据就会调用一次process_item函数 def process_item(self,item,spider): # sql语句 try: # 查重处理,根据表的主键进行一次查询，查看是否有重复数据 self.cursor.execute( \"\"\"select * from doubanmovie where img_url = %s\"\"\", item['img_url']) # 是否有重复数据 repetition = self.cursor.fetchone() if repetition: #两种方式丢弃无效数据 1. pass 2. raise DropItem(\"Missing price in %s\" % item) #需要引入相关的模块from scrapy.exceptions import DropItem else: insert_sql = \"\"\" insert into test_zxf(quote,author,tags,born_date,born_location) VALUES(%s,%s,%s,%s,%s) \"\"\" # 执行插入数据到数据库操作 self.cursor.execute(insert_sql,(item['quote'],item['author'],item['tags'],item['born_date'], item['born_location'])) # 提交，不进行提交无法保存到数据库 self.conn.commit() except Exception as error: # 出现错误时打印错误日志 self.conn.rollback() log(error) return item def close_spider(self,spider): # 关闭游标和连接 self.cursor.close() self.conn.close() 同步方式Demo2 class WhfjPipeline(object): def __init__(self): dbparams = &#123; 'host': '127.0.0.1', 'user': 'root', 'password': '19980211', 'database': 'fangjia', 'port': 3306, 'charset': 'utf8' &#125; self.conn = pymysql.connect(**dbparams) self.cursor = self.conn.cursor() self._sql = None def process_item(self, item, spider): self.cursor.execute(self.sql, (item['xiaoqu_name'], item['position'], item['price'])) self.conn.commit() return item #将一个方法变为属性进行调用 @property def sql(self): if not self._sql: self._sql = \"\"\" insert into fangchan2(id,xiaoqu_name,position,price) values(null,%s,%s,%s); \"\"\" return self._sql return self._sql tip: ### # 我们可以使用@property装饰器来创建只读属性，@property装饰器会将方法转换为相同名称的只读属性,可以与所定义的属性配合使用，这样可以防止属性被修改。 # class DataSet(object): # @property # def method_with_property(self): ##含有@property # return 15 # def method_without_property(self): ##不含@property # return 15 # # l = DataSet() # print(l.method_with_property) # 加了@property后，可以用调用属性的形式来调用方法,后面不需要加（）。 # print(l.method_without_property()) #没有加@property , 必须使用正常的调用方法的形式，即在后面加() ### 1、异步方式 #piplines调用 from scrapyDemo.db.dbhelper import DBHelper class ScrapydemoPipeline(object): # 连接数据库 def __init__(self): self.db = DBHelper() def process_item(self, item, spider): # 插入数据库 self.db.insert(item) return item #这里面我们用到了数据库的操作DBHelper类，那 #么我们在scrapyDemo/db目录下创建dbhelper.py 模块，记得再创建一个__init__.py哦。 import pymysql from twisted.enterprise import adbapi from scrapy.utils.project import get_project_settings #导入seetings配置 import time class DBHelper(): '''这个类也是读取settings中的配置，自行修改代码进行操作''' def __init__(self): settings = get_project_settings() #获取settings配置，设置需要的信息 #或者使用这种方式来获取settings中定义的变量 userAgent = settings.get('USER_AGENT') dbparams = dict( host=settings['MYSQL_HOST'], #读取settings中的配置 db=settings['MYSQL_DBNAME'], user=settings['MYSQL_USER'], passwd=settings['MYSQL_PASSWD'], charset='utf8', #编码要加上，否则可能出现中文乱码问题 cursorclass=pymysql.cursors.DictCursor, use_unicode=False, ) #**表示将字典扩展为关键字参数,相当于host=xxx,db=yyy.... dbpool = adbapi.ConnectionPool('pymysql', **dbparams) self.dbpool = dbpool def connect(self): return self.dbpool #创建数据库 def insert(self, item): sql = \"insert into tech_courses(title,image,brief,course_url,created_at) values(%s,%s,%s,%s,%s)\" #调用插入的方法 query = self.dbpool.runInteraction(self._conditional_insert, sql, item) #调用异常处理方法 query.addErrback(self._handle_error) return item #写入数据库中 def _conditional_insert(self, tx, sql, item): item['created_at'] = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time())) params = (item[\"title\"], item['image'], item['brief'], item['course_url'], item['created_at']) tx.execute(sql, params) #错误处理方法 def _handle_error(self, failue): print('--------------database operation exception!!-----------------') print(failue) #demo2: #tip: 1. @classmethod不需要self参数，但第一个参数需要是表示自身类的cls参数。 # 用twisted库将数据进行异步插入到数据库 class MysqlTwistedPipeline(object): def __init__(self, dbpool): self.dbpool = dbpool #这个函数会自动调用 @classmethod def from_settings(cls, settings): # 需要在setting中设置数据库配置参数 dbparms = dict( host=settings['MYSQL_HOST'], db=settings['MYSQL_DBNAME'], user=settings['MYSQL_USER'], passwd=settings['MYSQL_PASSWORD'], charset='utf8', cursorclass=MySQLdb.cursors.DictCursor, use_unicode=True, ) # 连接ConnectionPool（使用MySQLdb连接，或者pymysql） dbpool = adbapi.ConnectionPool(\"pymysql\", **dbparms) # **让参数变成可变化参数 return cls(dbpool) # # 返回一个pipeline实例化对象 def process_item(self, item, spider): # 使用twisted将MySQL插入变成异步执行 #使用数据库连接池对象进行数据库操作,自动传递cursor对象到数据库操作方法的第一个参数 query = self.dbpool.runInteraction(self.do_insert, item) # 添加异常处理 query.addCallback(self.handle_error) def handle_error(self, failure): # 处理异步插入时的异常 print(failure) def do_insert(self, cursor, item): # 执行具体的插入 insert_sql = \"\"\" insert into jobbole_artitle(name, base_url, date, comment) VALUES (%s, %s, %s, %s) \"\"\" #这里不需要进行commit()提交，adbapi会进行自动的commit cursor.execute(insert_sql, (item['name'], item['base_url'], item['date'], item['coment'],)) 最后的tip: 在python1.7以前的版本引入settings中定义的常量的方式可以使用: from scrapy.conf import settings 但是在1.7版本之后,scrapy.conf就被移除了，1.7以后的版本里，正确使用 settings.py中配置的方法是: from scrapy.utils.project import get_project_settings settings = get_project_settings() host = settings['MONGODB_HOST] port = settings['MONGODB_PORT']","permalink":"https://codermino.github.io/2020/07/11/scrapy%E6%95%B0%E6%8D%AE%E5%AD%98%E5%85%A5mysql/","photos":[]},{"tags":[{"name":"markdown基本语法","slug":"markdown基本语法","permalink":"https://codermino.github.io/tags/markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"}],"title":"markdown基本语法","date":"2020/07/11","text":"+ space = 原点 数字+.+space=有序列表 #+space一级标题 ##+space二级标题 **字符**加粗 *字符*斜体 &gt;+space说明文字 ```+语言=代码块 内容原封不动的显示使用` 超链接 [百度](https://www.baidu.com)","permalink":"https://codermino.github.io/2020/07/11/markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/","photos":[]},{"tags":[{"name":"python引入模块的四种方式","slug":"python引入模块的四种方式","permalink":"https://codermino.github.io/tags/python%E5%BC%95%E5%85%A5%E6%A8%A1%E5%9D%97%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F/"}],"title":"python引入模块四种方式","date":"2020/07/11","text":"1. import time #使用import模块名直接导入一个模块 2. from random import randint #from模块名 import函数名,导入一个模块里的方法或者变量 3. from math import* #from模块名 import*导入这个模块里的\"所有方法和变量 4. import datetime as dt #导入一个模块并给这个模块起一个别名 5. from copy import deepcopy as dp #from模块名 import函数名as别名","permalink":"https://codermino.github.io/2020/07/11/python%E5%BC%95%E5%85%A5%E6%A8%A1%E5%9D%97%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F/","photos":[]},{"tags":[{"name":"python字符串前修饰符","slug":"python字符串前修饰符","permalink":"https://codermino.github.io/tags/python%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%89%8D%E4%BF%AE%E9%A5%B0%E7%AC%A6/"}],"title":"python字符串前修饰符","date":"2020/07/05","text":"1、字符串前加 u 例：u\"我是含有中文字符组成的字符串。\" 作用： 后面字符串以 Unicode 格式 进行编码，一般用在中文字符串前面，防止因为源码储存格式问题，导致再次使用时出现乱码。 2、字符串前加 r 例：r\"\\n\\n\\n\\n” # 表示一个普通生字符串 \\n\\n\\n\\n，而不表示换行了。 作用： 去掉反斜杠的转移机制。 （特殊字符：即那些，反斜杠加上对应字母，表示对应的特殊含义的，比如最常见的”\\n”表示换行，”\\t”表示Tab等。 ） 应用： 常用于正则表达式，对应着re模块。 3、字符串前加 b 例: response = b'Hello World!' # b' ' 表示这是一个 bytes 对象 作用： b\" \"前缀表示：后面字符串是bytes 类型。 用处： 网络编程中，服务器和浏览器只认bytes 类型数据。 如：send 函数的参数和 recv 函数的返回值都是 bytes 类型 附： 在 Python3 中，bytes 和 str 的互相转换方式是 str.encode('utf-8') bytes.decode('utf-8') 具体见底部代码 python str与bytes之间的转换 4、字符串前加 f import time t0 = time.time() time.sleep(1) name = 'processing' # 以 f开头表示在字符串内支持大括号内的python 表达式 print(f'{name} done in {time.time() - t0:.2f} s') 输出： processing done in 1.00 s # bytes object b = b\"example\" # str object s = \"example\" # str to bytes sb = bytes(s, encoding = \"utf8\") # bytes to str bs = str(b, encoding = \"utf8\") # an alternative method # str to bytes sb2 = str.encode(s) # bytes to str bs2 = bytes.decode(b)","permalink":"https://codermino.github.io/2020/07/05/python%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%89%8D%E4%BF%AE%E9%A5%B0%E7%AC%A6/","photos":[]},{"tags":[{"name":"pyinstaller","slug":"pyinstaller","permalink":"https://codermino.github.io/tags/pyinstaller/"}],"title":"pyinstaller的使用","date":"2020/07/05","text":"pyinstaller -F -w TestDataGen.py pyinstaller -Fw -i xxx.ico TestDataGen.py","permalink":"https://codermino.github.io/2020/07/05/pyinstaller%E7%9A%84%E4%BD%BF%E7%94%A8/","photos":[]},{"tags":[{"name":"git","slug":"git","permalink":"https://codermino.github.io/tags/git/"}],"title":"git提交pr","date":"2020/07/05","text":"简单过程 首先git分为本地仓库(自己电脑中)和远程仓库(git官网自己的账号中)，仓库可以理解为保存代码的地方， 简单的说是在自己本地仓库修改代码，提交到自己远程仓库，提交pr后被接受后再会被合并到master。 下面一步一步来。 详细过程 申请账号、添加ssh公钥等过程就不说了哈。 fork 将项目fork到自己的仓库中，可以在github的首页搜索到自己的想要的开源项目， 我以flink为例： 进去后，点出fork，稍等片刻，此项目便会出现在自己的仓库中 进到自己fork的项目中，就能看到Clone or download按钮，如下，记下这个https链接。 通过上面的步骤，已经将远程仓库建好 clone 需要将远程仓库clone到本地，此处省略安装本地github的过程， 随便在哪个目录(项目存放的目录)，右键打开一个Git base， 执行一下git clone https://github.com/***/***.git(使用上一步的https链接)， 等待命令完成，时间视下载速度而定，也许会比较慢， 网上也有些可以提高git clone速度的方法，不防一试。 上面的命令完成后，当前目录下会多一个目录，我clone的是flink， 所以会多一个flink目录，进到flink目录中，试试跑一下git status试试，会提示现在是master分支。 用git remote -v命令，可以看到此时只与自己的远程仓库建立了连接 还需要与上游建立连接，这里上游指的是一开始fork的那个项目源，以flink为例，执行如下命令： git remote add upstream https://github.com/apache/flink.git 再用git remote -v可以看到： 接下来就能创建分支了。 创建分支 接着上面的运行命令：git checkout -b flink-fs， 这个命令的意思是创建一个叫flink-fs的分支，运行这个命令后bash将自动切换到新的分支下. 修改代码 自行修改代码. 提交 可以先使用git status来查看有哪些文件被修改了 然后再git add ***.java将要提交的文件都加上 然后再git commit -m \"modify XX\"，需要注意的是git commit只是把修改的代码提交到当前分支(当前分支是flink-fs，而不是master)，”modify XX”是本次提交的简单说明 然后再git push origin flink-fs，这一步才是将当前分支推送到自己的远程仓库。 这时，在自己的远程仓库便能看刚才push上去的分支了 提交pr 找到New pull request 需要注意的是compare处选择刚才提交上来的分支 然后点Create pull request 写好名字，写好说明，提交，就OK啦。","permalink":"https://codermino.github.io/2020/07/05/git%E6%8F%90%E4%BA%A4pr/","photos":[]},{"tags":[{"name":"git","slug":"git","permalink":"https://codermino.github.io/tags/git/"}],"title":"git同步更新fork项目","date":"2020/07/05","text":"master:git同步更新fork项目 1、打开fork 过来的项目如下所示： 2、点击new pull request 3、在进入的界面， 后进行将左边的设置为你自己的仓库， fork 过来的源在右边， 如下图： 4、当选择完后会变成下图（关键步骤，千万不可选错分支） 5、接下来， 将其展示出可以调整状态： 右边改为源fork地址 6、就会出现变更数据： 7、点击create pull request 8、进行数据的合并： 9 、最后合并!","permalink":"https://codermino.github.io/2020/07/05/git%E5%90%8C%E6%AD%A5%E6%9B%B4%E6%96%B0fork%E9%A1%B9%E7%9B%AE/","photos":[]},{"tags":[{"name":"cookie和session的区别","slug":"cookie和session的区别","permalink":"https://codermino.github.io/tags/cookie%E5%92%8Csession%E7%9A%84%E5%8C%BA%E5%88%AB/"}],"title":"cookie和session的区别","date":"2020/06/25","text":"cookie 和session 的区别详解 这些都是基础知识，不过有必要做深入了解。 先简单介绍一下。二者的定义：当你在浏览网站的时候，WEB 服务器会先送一小小资料放在你的计算机上， Cookie 会帮你在网站上所打的文字或是一些选择，都纪录下来。 当下次你再光临同一个网站，WEB 服务器会先看看有没有它上次留下的 Cookie 资料， 有的话，就会依据 Cookie里的内容来判断使用者，送出特定的网页内容给你。 Cookie 的使用很普遍，许多有提供个人化服务的网站，都是利用 Cookie来辨认使用者， 以方便送出使用者量身定做的内容，像是 Web 接口的免费 email 网站，都要用到 Cookie。 具体来说cookie机制采用的是在客户端保持状态的方案， 而session机制采用的是在服务器端保持状态的方案。同时我们也看到， 由于采用服务器端保持状态的方案在客户端也需要保存一个标识， 所以session机制可能需要借助于cookie机制来达到保存标识的目的，但实际上它还有其他选择。 cookie机制。正统的cookie分发是通过扩展HTTP协议来实现的， 服务器通过在HTTP的响应头中加上一行特殊的指示以提示浏览器按照指示生成相应的cookie。 然而纯粹的客户端脚本如JavaScript或者VBScript也可以生成cookie。 而cookie的使用是由浏览器按照一定的原则在后台自动发送给服务器的。 浏览器检查所有存储的cookie，如果某个cookie所声明的作用范围大于等于将要请求的资源所在的位置， 则把该cookie附在请求资源的HTTP请求头上发送给服务器。 cookie的内容主要包括：名字，值，过期时间，路径和域。 路径与域一起构成cookie的作用范围。 若不设置过期时间，则表示这个cookie的生命期为浏览器会话期间， 关闭浏览器窗口，cookie就消失。这种生命期为浏览器会话期的cookie被称为会话cookie。 会话cookie一般不存储在硬盘上而是保存在内存里，当然这种行为并不是规范规定的。 若设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器， 这些cookie仍然有效直到超过设定的过期时间。 存储在硬盘上的cookie可以在不同的浏览器进程间共享，比如两个IE窗口。 而对于保存在内存里的cookie，不同的浏览器有不同的处理方式session机制。 session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。 当程序需要为某个客户端的请求创建一个session时， 服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id）， 如果已包含则说明以前已经为此客户端创建过session， 服务器就按照session id把这个session检索出来使用（检索不到，会新建一个）， 如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id， session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发送给服务器。一般这个cookie的名字都是类似于SEEESIONID。但cookie可以被人为的禁止，则必须有其他机制以便在cookie被禁止时仍然能够把session id传递回服务器。经常被使用的一种技术叫做URL重写，就是把session id直接附加在URL路径的后面。还有一种技术叫做表单隐藏字段。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器。比如： &lt;form name=\"testform\" action=\"/xxx\"&gt; &lt;input type=\"hidden\" name=\"jsessionid\" value=\"ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764\"&gt; &lt;input type=\"text\"&gt; &lt;/form&gt; 实际上这种技术可以简单的用对action应用URL重写来代替。 cookie 和session 的区别： 1、cookie数据存放在客户的浏览器上，session数据放在服务器上。 2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗,考虑到安全应当使用session。 3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能, 考虑到减轻服务器性能方面，应当使用COOKIE。 4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。 5、所以个人建议：将登陆信息等重要信息存放为SESSION,其他信息如果需要保留，可以放在COOKIE中 Jwt和一些权限 JWT 一般和 OAuth2 使用。 对外服务器使用 OAuth2，类似于三方的 API ; 内部使用 JWT 进行服务与服务间的交互，也就是内网间的传输。 OAuth2 进行授权用，JWT 是让系统知道你是谁。 OAuth2 转 JWT 一般在网关层进行转换。","permalink":"https://codermino.github.io/2020/06/25/cookie%E5%92%8Csession%E7%9A%84%E5%8C%BA%E5%88%AB/","photos":[]},{"tags":[{"name":"爬虫下载图片","slug":"爬虫下载图片","permalink":"https://codermino.github.io/tags/%E7%88%AC%E8%99%AB%E4%B8%8B%E8%BD%BD%E5%9B%BE%E7%89%87/"}],"title":"网页图片批量获取（Python教程）","date":"2020/06/25","text":"图片下载（知识点） urllib 库 我们首先了解一下 urllib 库，它是 Python 内置的 HTTP 请求库，也就是说我们不需要额外安装即可使用，它包含四个模块： 第一个模块 request，它是最基本的 HTTP 请求模块，我们可以用它来模拟发送一请求。 就像在浏览器里输入网址，然后敲击回车一样，只需要给库方法传入 URL ， 还有额外的参数，就可以模拟实现这个过程了； 第二个 error 模块即异常处理模块，如果出现请求错误，我们可以捕获这些异常， 然后进行重试或其他操作，保证程序不会意外终止； 第三个 parse 模块是一个工具模块，提供了许多 URL 处理方法，比如拆分、解析、合并等等的方法； 第四个模块是 robotparser，主要是用来识别网站的 robots.txt 文件， 然后判断哪些网站可以爬，哪些网站不可以爬，其实用的比较少。 使用 urlopen() 发送请求 urllib.request 模块提供了最基本的构造 HTTP 请求的方法，利用它可以模拟浏览器的一个请求发起过程，同时它还带有处理 authenticaton（授权验证）、 redirections（重定向)、 cookies（浏览器 Cookies）以及其它内容。 接下来，我们来感受下它的强大之处，以百度为例 ，我们把网页爬取下来。 code: import urllib.request response = urllib.request.urlopen('https://www.baidu.com') print(response.read().decode('utf-8')) urllib.request.urlopen（URL） ：发送 HTTP 请求，返回为 HTTPResponse； response.read() : 获取 HTTP 请求之后响应的内容。 IO open() file object = open(file_name [, access_mode][, buffering]) 打开 file 对象，并返回对应的数据流。如果打开失败，则抛出 IOError异常。 file_name： file_name 变量是一个包含了你要访问的文件名称的字符串值； access_mode ： access_mode 决定了打开文件的模式：只读( r)，写入(w)，追加(a)，创建(x)等。这个参数是非强制的，默认文件访问模式为只读( r)； buffering : 如果 buffering 的值被设为 0，就不会有寄存。如果 buffering 的值取 1，访问文件时会寄存行。如果将 buffering 的值设为大于 1 的整数，表明这就是寄存区的缓冲大小。如果取负值，则寄存区的缓冲大小为系统默认。 上面介绍了这么多知识点，接下来举个“栗子”吧，让我们体验下如何使用 open() 函数。 # 打开一个文件(文件必须已经存在) fo = open(\"example.txt\", \"w\") fo.write( \"\"\"这个博主值得你关注! 这篇博客值得你点赞！ \"\"\") # 关闭打开的文件 fo.close() OS库 os 模块代表了程序所在的操作系统，主要用于获取程序运行所在操作系统的相关信息。 举个“栗子”：创建目录： import os # 创建的目录 path = \"/tmp/home/monthly/daily/hourly\" os.mkdir(path); print(\"目录已创建\") os.mkdir()创建该目录，若目录已存在会报错 再举个“栗子”：判断文件或目录是否已存在： import os exists = os.path.exists(\"foo.txt\") if exists: abspath = os.path.abspath(\"foo.txt\") print(abspath) else: print(\"文件不存在\") os.path.exists()判断目录或文件是否存在 os.path.abspath()返回绝对路径 正则表达式（知识点） 为什么使用正则表达式？ 1、典型的搜索和替换操作，要求您提供与预期的搜索结果匹配的确切文本。虽然这种技术， 对于对静态文本执行简单搜索和替换任务，可能已经足够了，但它缺乏灵活性， 若采用这种方法搜索动态文本，也不是不可能，至少也会变得很困难。 2、比如说，判断邮箱格式是否正确、手机号格式是否正确。 这种需求如果不使用正则匹配的话，那么就需要写很多逻辑进行 equals 操作。 想一想都很麻烦，麻烦的原因是 equals 操作只能确切匹配，缺乏灵活度。 3、而正则就不同了，正则可以使用限定符，匹配字符出现的次数，这样一来灵活度都高了。 4、正则表达式是一个以简单直观的方式通过寻找模式匹配文本的工具 正则表达式的重复限定符 限定符用来指定正则表达式的一个给定组件，必须要出现多少次才能满足匹配。 有 * 或 + 或 ? 或 &#123;n&#125; 或 &#123;n,&#125; 或 &#123;n,m&#125; 共 6种。 如上图 正则表达式的特殊字符类 如上图 正则表达式的分组 要实现分组很简单，使用 ()即可。 从正则表达式的左边开始看，看到的第一个左括号 (表示表示第一个分组，第二个表示第二个分组，依次类推。 a='&lt;div&gt;&lt;a href=\"https://support.google.com/chrome/?p=ui_hotword_search\" target=\"_blank\"&gt;python正则表达式之分组&lt;/a&gt;&lt;p&gt;dfsl&lt;/p&gt;&lt;/div&gt;' print(re.search(r'&lt;a.*&gt;(.*)&lt;/a&gt;',a).group(1)) 输出： python正则表达式之分组 需要注意的是，有一个隐含的全局分组（就是索引号为 0的分组），就是整个正则表达式匹配的结果。 如果正则表达式包含组，则re.findall()返回组的列表 re 库的 findall 函数 在字符串中，找到正则表达式所匹配的所有子串，并返回一个列表。如果没有找到匹配的，则返回空列表。 举个“栗子”：查找字符串中的所有数字。 ort re result1 = re.findall(r'\\d+', 'runoob 123 google 456') result2 = re.findall(r'\\d+', 'run88oob123google456', 0, 10) print(result1) print(result2) ['123', '456'] ['88', '12'] 正则表达式的懒惰匹配算法 针对 正则表达式的重复限定符 默认情况下，Python正则表达式的匹配算法采用贪婪性算法（尽可能多的重复前导字符） 如果正则表达式的重复限定符的后面加后缀?，则正则表达式引擎使用懒惰性匹配算法（尽可能少的重复前导字符） 图片链接提取（例题） 使用 urllib 访问 http://www.tencent.com/ 网页，提取其网页中所有的图片链接。 import urllib.request as req import re \"\"\" 爬取网页内容 \"\"\" def getHTML(url): response = req.urlopen(url) return response.read().decode('utf-8') # 所爬取网站为utf-8编码 \"\"\" 获取网页中全部图片的链接 - 如果网页爬取的超链接为相对路径，需要与网页根路径进行补全 - 网页爬取的超链接如果有重复项，需要去重（不一定有重复，但保险起见） \"\"\" def getImgUrls(html): root = 'http://www.tencent.com/' imgUrls = re.findall(r'img src=\"(.*?)\".*&gt;', html) temp = [] for url in imgUrls: if url not in temp: temp.append(url) for index, url in enumerate(temp): if root not in url: temp[index] = root + url return temp if __name__ == '__main__': url = 'http://www.tencent.com/' html = getHTML(url) imgUrls = getImgUrls(html) for url in imgUrls: print(url) 输出效果（运行时间为2020年5月7日，网站内容可能会变哦）： http://www.tencent.com//data/index/index_detail_1.jpg http://www.tencent.com//data/index/index_detail_2.jpg http://www.tencent.com//data/index/index_detail_3.jpg http://www.tencent.com//img/index/tencent_logo.png 文本内容分析（例题） 通过路径 /root/score.txt，以只读的方式读取 score.txt 文件； 获取 2016年一本线最高的的三个省份，并将其打印到控制台（格式为： 省份**********分数） score.txt 文件数据类似如下： 甘肃 490 632 621 625 630 597 608 吉林 530 658 639 649 634 599 615 新疆 464 673 617 630 612 534 578 广西 502 642 601 620 603 584 592 上海 360 489 475 480 / / / 广东 508 641 600 613 619 585 597 内蒙古 484 641 615 627 623 558 597 陕西 470 665 628 638 639 596 615 四川 532 665 626 643 651 612 623 黑龙江 486 667 623 641 628 580 600 安徽 518 655 620 631 647 608 621 河北 525 682 654 667 669 640 649 江西 529 645 614 629 613 589 599 浙江 600 692 670 679 676 652 661 湖南 517 662 635 644 646 593 609 宁夏 465 637 565 597 590 481 526 山东 537 679 655 665 660 597 637 河南 523 665 644 652 659 629 638 山西 519 639 617 625 638 579 599 天津 512 659 634 649 600 537 567 北京 548 662 607 629 613 570 592 重庆 525 671 644 655 654 634 642 云南 525 680 653 663 663 627 639 青海 416 596 562 580 571 502 533 江苏 353 404 376 386 384 355 366 福建 465 632 614 623 606 485 576 海南 602 829 710 750 737 672 700 贵州 473 671 627 643 658 600 616 辽宁 498 660 624 637 641 607 621 湖北 512 665 622 640 637 604 614 以第一行数据为例，对数据结构进行说明： 甘肃 490 632 621 625 630 597 608 ， 第一列为省份， 第二列为 2016年的一本线分数 490， 第三列为 2015年的一本线分数 632， 其次类推，分别是 2014、 2013、 2012、 2011、 2010 年的分数线。 代码： # 先读取所有省份和对应的2016年一本线分数，分别存入列表prov和score prov, score = [], [] with open(r'/root/score.txt', 'r') as f: for line in f.readlines(): t = line.split() prov.append(t[0]) score.append(int(t[1])) # 对prov和score中的数据进行排序 temp = list(zip(prov, score)) # 把prov和score压缩为一个列表tmp ''' 对temp排序，当列表元素是元组时， 需要以元组的第二个元素进行排序，即根据一本线分数排序， 所以写了takeSecond()函数 ''' def takeSecond(elem): return elem[1] temp.sort(reverse=True, key=takeSecond) # 降序排序 # 获取 2016年一本线最高的的三个省份，并将其打印到控制台 for i in range(3): p = str(temp[i][0]) s = str(temp[i][1]) print(p + '**********' + s) 效果： 海南**********602 浙江**********600 北京**********548 图片批量下载（例题） 以http://www.tencent.com/该网址为例，将网页上的所有图片批量下载到一个文件夹中。 三个步骤就可以完成了 如何获取 HTML 源码， 如何获取 HTML 源码上的指定标签， 如何使用 OS 模块完成目录的创建。 import urllib.request as req import re import os # 获取网页的HTML源码,返回HTML源码 def getHTML(url): response = req.urlopen(url) return response.read().decode('utf-8') # 从HTML代码中提取图片的网址,返回图片链接列表 def getImgUrls(html): root = 'http://www.tencent.com/' imgUrls = re.findall(r'img src=\"(.*?)\".*&gt;', html) temp = [] for url in imgUrls: if url not in temp: temp.append(url) for index, url in enumerate(temp): if root not in url: temp[index] = root + url return temp # 下载一幅图片，图片的链接为url，下载后的图片名字为name def downloadImg(url, name): response = req.urlopen(url) img = open(name, 'wb') # 以二进制形式写入 img.write(response.read()) img.close() # 将url对应网页上所有图片下载到dirPath文件夹 def downloadAllImg(url, dirPath): # 若文件夹不存在，则创建 exists = os.path.exists(dirPath) if not exists: os.mkdir(dirPath) # 获取网页上所有图片的网址 html = getHTML(url) imgUrls = getImgUrls(html) print(os.path) # 下载图片，注意异常处理 for url in imgUrls: imgName = os.path.split(url)[1] # 获取文件名 filePath = os.path.join(dirPath, imgName) # 存放入文件夹内的完整路径名 try: downloadImg(url, filePath) except: continue if __name__ == '__main__': url = 'http://www.tencent.com/' dirPath = 'D:\\imgs' downloadAllImg(url, dirPath) os.path.split(path) 以 path 中最后一个 / 作为分隔符，分隔后，将索引为0的视为目录（路径），将索引为1的视为文件名 os.path.join(path1, path2, ...) 以/拼接参数","permalink":"https://codermino.github.io/2020/06/25/%E7%BD%91%E9%A1%B5%E5%9B%BE%E7%89%87%E6%89%B9%E9%87%8F%E8%8E%B7%E5%8F%96%EF%BC%88Python%E6%95%99%E7%A8%8B%EF%BC%89/","photos":[]},{"tags":[{"name":"火柴","slug":"火柴","permalink":"https://codermino.github.io/tags/%E7%81%AB%E6%9F%B4/"}],"title":"火柴软件使用说明","date":"2020/06/24","text":"呼叫火柴 火柴是一款PC端的 快速启动+文件搜索+局域网传文件 软件。使用方法十分简单，双击 Ctrl 键 呼出搜索框，输入内 容即可搜索，再次双击 Ctrl 键 则可以关闭桌面搜索框。 快速启动 火柴增加了“快速启动”面板。可以将常用的软件、文件、网址固定在面板中（每排8个，共4排，最多放31个。）可 根据自己的习惯增加，例如像我这个样子。 快速启动拓展 如果面板放满了，还可以搜索软件名进行软件启动。火柴支持 程序名/文件名（如输入“QQ”，打开”QQ”），名称 缩写（如“PS”，打开“photoshop”）,乃至软件俗称（如“吃鸡”）。 文件搜索 使用Windows搜索的都知道，由于索引服务的原因，导致Windows自带搜索出奇的缓慢，经常要等数分钟，才会搜出 结果。众所周知，everything是一款强大的本地搜索软件，基于everything内核的火柴也是如此。而且，火柴搜索显示 上做出优化，不用用户编写复杂的正则表达式(因为不是每个人都是大牛)。 网络搜索 此外，火柴还支持“网络搜索”。集成了若干搜索引擎，默认可以进行百度搜索、淘宝搜索、微信搜索等。如果想要 搜索的内容，在浏览器内有收藏书签，火柴会在搜索结果中提示，并且使用收藏书签所在的浏览器打开，充分照顾用 户使用习惯。此外，网络搜索还支持高级搜索。（玩法太多，此处省略10万字） 局域网传文件 火柴另一个功能就是局域网传文件。局域网文件中，如果是网线连接，速度最高可达110MB/s，wifi连接最高速度也能达 到70MB/s。 小程序 火柴内集成了24个实用得小工具——“火柴小程序”。小程序涵盖了工作、学习、娱乐、生活等诸多方面，可满足大部 分人的需求。调用小程序也很方便，输入“xcx”,就可以查看小程序列表，并启动需要的小程序。 小程序列表 也可以直接输入小程序对应得命令，启动对应得小程序。如输入“fy”，启动“翻译小程序”；输入“time”，启动 “时间戳小程序” 部分小程序，还支持快捷键。例如【alt】+【Q】，启动“火柴截图”；【alt】+【1】启动“综合导航”（全屏面板） 皮肤 此外，火柴还支持支换肤。如果不喜欢素颜的默认皮肤，可以到皮肤中心选择下载自己喜欢的皮肤，或者 干脆自己动手制作。（ps: 我更喜欢自己动手制作）","permalink":"https://codermino.github.io/2020/06/24/%E7%81%AB%E6%9F%B4%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/","photos":[]},{"tags":[{"name":"this.$nextTick","slug":"this-nextTick","permalink":"https://codermino.github.io/tags/this-nextTick/"}],"title":"this.$nextTick","date":"2020/03/31","text":"原理 1.vue依靠数据驱动来完成视图和dom的渲染 2.vue的响应式不是数据发生变化之后立即变化，更新的过程是异步的 3.如果想要在created钩子函数中进行dom操作，created钩子函数中是在页面创建的时候进行调用， 可能还未对页面中的dom元素进行渲染完成。所以无法直接进行操作，需要通过this.$nextTick()来完成。 验证 创建对应的html页面 span标签中显示的内容是data中的value的值 点击button按钮之后会触发changeValue事件，修改data中的value的值 主要是验证span标签中value的值的变化过程 &lt;button @click=\"changeValue\"&gt;点击改变value&lt;/button&gt; &lt;span ref=\"container\"&gt;&#123;&#123;this.value&#125;&#125;&lt;/span&gt; 创建对应的数据和钩子函数 created()&#123; console.log('开始执行created函数'); console.log(this.value); console.log(this.$refs.container); this.$nextTick(()=&gt;&#123; console.log('created中的$nextTick函数'); &#125;) &#125;, mounted() &#123; console.log('开始执行mounted函数'); console.log(this.$refs.container.innerHTML); this.$nextTick(()=&gt;&#123; console.log('mounted中的$nextTick函数'); &#125;) &#125;, data()&#123; return&#123; value:'改变之前的内容(old)' &#125; &#125;, methods:&#123; changeValue()&#123; this.value = '改变之后的内容(new)'; console.log(this.$refs.container.innerText); this.$nextTick(()=&gt;&#123; console.log(this.$refs.container.innerText); &#125;) &#125; &#125; 输出 页面中的输出结果 test.vue?b018:13 开始执行created函数 test.vue?b018:14 改变之前的内容(old) test.vue?b018:15 undefined test.vue?b018:21 开始执行mounted函数 test.vue?b018:22 改变之前的内容(old) test.vue?b018:17 created中的$nextTick函数 test.vue?b018:24 mounted中的$nextTick函数 test.vue?b018:35 改变之前的内容(old) test.vue?b018:37 改变之后的内容(new) 输出结果分析 结果分析 页面打开后调用created钩子函数 输出相应的打印结果，可以看到在第15行结果为undefined(输出的是span标签) 可以看出在created钩子函数调用的时候，页面的dom元素还没有渲染完成 在第17行可以看到，在页面的dom元素渲染完成之后，会按照生命周期顺序执行created和mouted钩子函数中的this.$nextTick()函数 并且输出对应的内容 在点击了按钮之后，改变了data中的value的值，页面中也进行了dom的刷新，但是... 通过35行的打印可以知道，此时span标签中的内容还是修改之前的内容 通过37行的打印可以知道，在dom元素彻底渲染完成之后，span标签中的内容也完成了更新。(此时打印的内容是更新完的value的内容) 总结 this.$nextTick() veu的响应式的更新的过程是异步的。 是保证在dom元素渲染完成之后再进行某个操作。 所以如果希望某个函数或者数据的赋值等操作是在dom元素渲染完成之后再进行，那么可以用this.$nextTick()","permalink":"https://codermino.github.io/2020/03/31/this-nextTick/","photos":[]},{"tags":[{"name":"stream处理大文件","slug":"stream处理大文件","permalink":"https://codermino.github.io/tags/stream%E5%A4%84%E7%90%86%E5%A4%A7%E6%96%87%E4%BB%B6/"}],"title":"nodejs的stream","date":"2020/02/25","text":"读取 const fs = require('fs'); const fileReadStream = fs.createReadStream(\"input.json\"); fileReadStream.once('data',(chunk)=&gt;&#123; console.log(chunk.toString()); &#125;); fileReadStream.on(\"end\",()=&gt;&#123; console.log('end'); &#125;); fileReadStream.on('error',(err)=&gt;&#123; console.log(err); &#125;); 读取并写入 const fs = require('fs'); const fileReadStream = fs.createReadStream(\"input.json\"); const fileWriteStream = fs.createWriteStream('output.json'); let count = 0; fileReadStream.on('data',(chunk)=&gt;&#123; console.log(`$&#123;++count&#125; 接收到: $&#123;chunk.length&#125;`); fileWriteStream.write(chunk); &#125;); fileReadStream.on(\"end\",()=&gt;&#123; console.log('end'); &#125;); fileReadStream.on('error',(err)=&gt;&#123; console.log(err); &#125;); 管道流写入 const fs = require('fs'); const fileReadStream = fs.createReadStream(\"input.json\"); const fileWriteStream = fs.createWriteStream('output.json'); //通过管道流的方式进行写入 fileReadStream.pipe(fileWriteStream); 管道流产生一个gz压缩文件 const fs = require('fs'); const zlib = require('zlib'); const fileReadStream = fs.createReadStream(\"input.json\"); const fileWriteStream = fs.createWriteStream('output.gz'); fileWriteStream.on('pipe',(source)=&gt;&#123; console.log(source); &#125;); fileReadStream .pipe(zlib.createGzip()) .pipe(fileWriteStream);","permalink":"https://codermino.github.io/2020/02/25/nodejs%E7%9A%84stream/","photos":[]},{"tags":[{"name":"gm","slug":"gm","permalink":"https://codermino.github.io/tags/gm/"}],"title":"通过控制台使用gm裁剪图片","date":"2020/02/15","text":"转换图片格式 gm convert input output 改变图片大小 gm convert -quality 80 -resize 100×100 input.jpg output.jpg 添加水印文字 -font 字体 -fill 填充颜色 -pointsize 字体大小 -draw 内容 gm convert -font Arial -fill blue -pointsize 18 -draw \"text 100,100 'www.abc.com'\" input output","permalink":"https://codermino.github.io/2020/02/15/%E9%80%9A%E8%BF%87%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%BD%BF%E7%94%A8gm%E8%A3%81%E5%89%AA%E5%9B%BE%E7%89%87/","photos":[]},{"tags":[{"name":"gm裁切图片(1)","slug":"gm裁切图片-1","permalink":"https://codermino.github.io/tags/gm%E8%A3%81%E5%88%87%E5%9B%BE%E7%89%87-1/"}],"title":"gm裁切图片(1)","date":"2020/02/05","text":"引入相关包 const fs = require('fs'),gm = require('gm'); 缩放 gm('input.jpg') .resize(50, 50,\"!\") .write('output.jpg', function (err) &#123; if (err) &#123; console.log(err); &#125; &#125;); 裁剪指定位置 gm('./demo.jpg') .crop(364, 480, 82, 3) .write('./cut.jpg', function (err) &#123; if (!err) console.log('crazytown has arrived'); &#125;);","permalink":"https://codermino.github.io/2020/02/05/gm%E8%A3%81%E5%88%87%E5%9B%BE%E7%89%87-1/","photos":[]},{"tags":[{"name":"md5加密注册表单","slug":"md5加密注册表单","permalink":"https://codermino.github.io/tags/md5%E5%8A%A0%E5%AF%86%E6%B3%A8%E5%86%8C%E8%A1%A8%E5%8D%95/"}],"title":"md5加密注册表单","date":"2020/02/05","text":"文件夹的创建 创建public文件夹用来存放jquery文件 创建views文件夹用来存放前端页面 创建models文件夹用来存放md5.js文件 register前端页面 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;注册&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;form action=\"\" method=\"post\"&gt; &lt;label for=\"username\"&gt;&lt;/label&gt; &lt;p&gt;用户名：&lt;input name=\"userName\" type=\"text\" id=\"username\"/&gt;&lt;/p&gt; &lt;label for=\"password\"&gt;&lt;/label&gt; &lt;p&gt;密 码：&lt;input name=\"password\" type=\"password\" id=\"password\"/&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"button\" value=\"注册\" id=\"zhuce\"&gt;&lt;/p&gt; &lt;/form&gt; &lt;/div&gt; &lt;script type=\"text/javascript\" src=\"/jquery-1.11.3.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; //用ajax提交表单 $(\"#zhuce\").click(function()&#123; $.post(\"/doregist\",&#123; \"username\" : $(\"#username\").val(), \"password\" : $(\"#password\").val() &#125;,function(result)&#123; if(result === \"1\")&#123; alert(\"注册成功\"); window.location.href=\"/login\"; &#125;else&#123; alert(\"注册失败\"); &#125; &#125;) &#125;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; login前端页面 &lt;!doctype html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;登录&lt;/h1&gt; &lt;div&gt; &lt;form action=\"\" method=\"post\"&gt; &lt;label for=\"dengluming\"&gt;&lt;/label&gt; &lt;p&gt; 登录名： &lt;input type=\"text\" id=\"dengluming\"/&gt; &lt;/p&gt; &lt;label for=\"mima\"&gt;&lt;/label&gt; &lt;p&gt; 密码： &lt;input type=\"password\" id=\"mima\"/&gt; &lt;/p&gt; &lt;p&gt; &lt;input id=\"denglu\" type=\"button\" value=\"登陆\"/&gt; &lt;/p&gt; &lt;/form&gt; &lt;/div&gt; &lt;script type=\"text/javascript\" src=\"/jquery-1.11.3.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; //用ajax提交表单 $(\"#denglu\").click(function()&#123; $.post(\"/dologin\",&#123; \"dengluming\" : $(\"#dengluming\").val(), \"mima\" : $(\"#mima\").val() &#125;,function(result)&#123; if(result === \"1\")&#123; alert(\"登陆成功\"); window.location.href=\"/index\"; &#125;else if(result === \"-2\")&#123; alert(\"没有这个注册用户\"); &#125;else if(result === \"-1\")&#123; alert(\"密码不正确\"); &#125; &#125;) &#125;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; md5.js const crypto = require(\"crypto\"); module.exports = function(password)&#123; let md5 = crypto.createHash('md5'); return md5.update(password).digest('base64'); &#125;; 引入相关的包 const express = require('express'); const path = require('path'); const ejs = require('ejs'); const MongoClient = require('mongodb').MongoClient; const md5 = require(\"./model/md5.js\"); const formidable = require('formidable'); const session = require('express-session'); express中间件 使用express中间件,并且在3000端口监听 const app = express(); app.listen(3000,function () &#123; console.log('server is running...'); &#125;); 使用html模板引擎 将ejs模板引擎转为html模板引擎 app.set('views', path.join(__dirname, 'views')); app.engine('html', ejs.__express); app.set('view engine', 'html'); 使用express-session中间件 使用express-session中间件,并且如果用户主动刷新页面那么session自动重新计时，并且session的有效时间为60s app.use(session(&#123; secret: 'keyboard cat', name : 'login', resave: true,//是否允许session重新设置 saveUninitialized: false, cookie: &#123;maxAge: 60 * 1000&#125;, rolling: true //add 刷新页面 session 过期时间重置 &#125;)); 开放静态资源服务 将Public文件夹开放出来 app.use(express.static('./public')); 渲染前端页面 设置重定向,一开始的时候自动重定向到register路由,并且渲染register.html文件 app.get('/',function (req,res) &#123; res.redirect('/register'); &#125;); app.get('/register',function (req,res) &#123; res.render('register'); &#125;); app.get('/login',function (req,res) &#123; res.render('login'); &#125;); 注册接口 app.post('/dologin',function (req,res) &#123; let form = new formidable.IncomingForm(); form.parse(req, function(err, fields, files)&#123; const array = []; const username = fields.dengluming; let password = fields.mima; password = (你的md5加密方式) 例如:md5(password); const url = \"mongodb://localhost:27017/\"; //连接数据库 MongoClient.connect(url, &#123;useUnifiedTopology:true&#125;, (err, client)=&gt; &#123; //回调函数表示链接成功做的事情，db参数就是连接上的数据库实体 if(err) &#123; console.log(\"数据库连接失败\"); return ; &#125; //插入数据，集合如果不存在，也没有关系，程序会帮你创建 const db = client.db('learnnode'); const result = db.collection('Student').find(&#123;username:username&#125;); result.each(function (err, doc) &#123; if(err) &#123; return; &#125; if(doc != null) &#123; array.push(doc); //放入结果数组 &#125;else &#123; let checkNum = 0; const resultNum = array.length; if(resultNum === 0)&#123; res.send('-2'); &#125;else &#123; //遍历结束，没有更多的文档 array.forEach(function (data) &#123; if(data.password === password)&#123; req.session.login = true; req.session.username = username; req.session.password = password; res.send('1'); &#125;else &#123; checkNum++; &#125; &#125;); if(checkNum === resultNum)&#123; res.send('-1'); &#125; &#125; &#125; &#125;); &#125;); &#125;); &#125;); 注册接口 app.post('/doregist',function (req,res) &#123; let form = new formidable.IncomingForm(); form.parse(req, function(err, fields, files)&#123; const username = fields.username; let password = fields.password; const url = \"mongodb://localhost:27017/\"; MongoClient.connect(url, &#123;useUnifiedTopology:true&#125;, (err, client)=&gt; &#123; //回调函数表示链接成功做的事情，db参数就是连接上的数据库实体 if(err) &#123; console.log(\"数据库连接失败\"); return ; &#125; //插入数据，集合如果不存在，也没有关系，程序会帮你创建 const db = client.db('learnnode'); password = md5(md5(password).substr(4,7) + md5(password)); const myObj = &#123;username: username, password: password&#125;; db.collection('Student').insertOne(myObj,function (err,result) &#123; if(err)&#123; console.log(err); res.send('-1'); &#125;else &#123; console.log('插入数据成功'); res.send('1'); &#125; client.close(); &#125;); &#125;); &#125;); &#125;);","permalink":"https://codermino.github.io/2020/02/05/md5%E5%8A%A0%E5%AF%86%E6%B3%A8%E5%86%8C%E8%A1%A8%E5%8D%95/","photos":[]},{"tags":[{"name":"session的使用","slug":"session的使用","permalink":"https://codermino.github.io/tags/session%E7%9A%84%E4%BD%BF%E7%94%A8/"}],"title":"session的使用","date":"2020/02/01","text":"基本使用 const express = require('express'); //引入express-session中间件 const session = require('express-session'); const app = express(); app.set('trust proxy', 1) ;// trust first proxy //使用session并且配置相关参数 app.use(session(&#123; secret: 'keyboard cat', resave: false, saveUninitialized: true // cookie: &#123; secure: true &#125; &#125;)); app.get('/',function (req,res) &#123; if(req.session.login)&#123; res.send('欢迎您：'+req.session.username); &#125;else &#123; res.send('没有登录'); &#125; &#125;); app.get('/login',function (req,res) &#123; req.session.login = true; req.session.username = '张三'; res.send('登录成功'); &#125;); app.listen(3000,function () &#123; console.log('server is running...'); &#125;);","permalink":"https://codermino.github.io/2020/02/01/session%E7%9A%84%E4%BD%BF%E7%94%A8/","photos":[]},{"tags":[{"name":"cookie的使用","slug":"cookie的使用","permalink":"https://codermino.github.io/tags/cookie%E7%9A%84%E4%BD%BF%E7%94%A8/"}],"title":"cookie的使用","date":"2020/02/01","text":"基本使用 const express = require('express'); //使用cookie-parser中间件 const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.get('/',function (req,res) &#123; res.send(req.cookies.xihao); &#125;); // http://localhost:3000/gonglue?dest=北京 app.get('/gonglue',function (req,res) &#123; const destination = req.query.dest; //先取出cookie,然后再设置cookie const likes = req.cookies.xihao || []; likes.push(destination); //maxAge设置最大存活时间，在nodejs中是以毫秒为单位(900000ms),但是在浏览器的cookie中会是以秒为单位(900s) res.cookie('xihao',likes,&#123; maxAge: 900000, httpOnly: true &#125;); res.send(destination+'旅游攻略'); &#125;); app.listen(3000,function () &#123; console.log('server is running...'); &#125;);","permalink":"https://codermino.github.io/2020/02/01/cookie%E7%9A%84%E4%BD%BF%E7%94%A8/","photos":[]},{"tags":[{"name":"app.use中间件","slug":"app-use中间件","permalink":"https://codermino.github.io/tags/app-use%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"title":"app.use中间件","date":"2020/01/30","text":"使用 const express = require('express'); const app = express(); //在使用app.use中间件的时候如果不指定路由，那么默认是/ //会匹配到/、/abc、/abc/123等路由 如果在浏览器中输入的路由是http://localhost:3000/user/456/abc app.use(function(req, res, next)&#123; //GET /user/456/abc console.log('%s %s', req.method, req.url); next(); &#125;); 那么和get、post不同的是use会向下接着匹配 app.use('/user',function(req, res, next)&#123; const basePath = req.baseUrl; const path = req.path; /user console.log(basePath); /456/abc console.log(path); res.send('Hello World'); &#125;); app.listen(3000); 开放静态资源文件夹 //开放同级目录下的public文件夹，并且在路由的时候使用/static代替 app.use('/static',express.static(__dirname + '/public')); 原生开放静态资源原理 const express = require('express'); const fs = require('fs'); const app = express(); app.use(openStatic); app.listen(3000,function () &#123; console.log('server is running...'); &#125;); function openStatic(req,res,next) &#123; const filePath = req.path; fs.readFile(__dirname+filePath,function (err,data) &#123; if(err)&#123; next() &#125;else &#123; res.send(data.toString()); &#125; &#125;) &#125; 优先级 会按照从上到下的优先级顺序执行 app.use(express.static(__dirname + '/public')); app.use(express.static(__dirname + '/files')); app.use(express.static(__dirname + '/uploads'));","permalink":"https://codermino.github.io/2020/01/30/app-use%E4%B8%AD%E9%97%B4%E4%BB%B6/","photos":[]},{"tags":[{"name":"将ejs模板引擎修改为html模板引擎","slug":"将ejs模板引擎修改为html模板引擎","permalink":"https://codermino.github.io/tags/%E5%B0%86ejs%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E4%BF%AE%E6%94%B9%E4%B8%BAhtml%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"}],"title":"将ejs模板引擎修改为html模板引擎","date":"2020/01/29","text":"引入 const ejs = require('ejs'); const path = require('path'); 使用html模板引擎 app.set('views', path.join(__dirname, 'views')); app.engine('html', ejs.__express); app.set('view engine', 'html'); 渲染html页面 app.get('/',function (req,res) &#123; res.redirect('/user'); &#125;); app.get('/user',function (req,res) &#123; res.render('form'); &#125;); 渲染原理 在渲染的时候app.set('views', path.join(__dirname, 'views')); 渲染的页面会在views文件夹下寻找指定名的文件(上述例子寻找views/form.html) 将渲染ejs文件修改为渲染html文件 app.engine('html', ejs.__express); //如果不想使用views这个文件夹，可以使用下面的语句进行修改 app.set('views','文件夹的名字'); app.set('view engine', 'html');","permalink":"https://codermino.github.io/2020/01/29/%E4%BD%BF%E7%94%A8html%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/","photos":[]},{"tags":[{"name":"body-parser","slug":"body-parser","permalink":"https://codermino.github.io/tags/body-parser/"}],"title":"body-parser的使用","date":"2020/01/29","text":"安装 npm install body-parser 使用 var bodyParser = require('body-parser'); app.use(bodyParser.urlencoded(&#123; extended: false &#125;)); // parse application/json app.use(bodyParser.json()); 表单 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Demo&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form method=\"post\" action=\"#\"&gt; &lt;label for=\"username\"&gt;&lt;/label&gt; &lt;input id=\"username\" type=\"text\" placeholder=\"请输入姓名\" name=\"username\"/&gt; &lt;input type=\"submit\" value=\"提交\"/&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 获取表单数据 app.post('/user',function (req,res) &#123; res.setHeader('Content-Type', 'text/plain'); res.write('you posted:\\n'); res.end(JSON.stringify(req.body, null, 2)); &#125;);","permalink":"https://codermino.github.io/2020/01/29/body-parser%E7%9A%84%E4%BD%BF%E7%94%A8/","photos":[]},{"tags":[{"name":"express","slug":"express","permalink":"https://codermino.github.io/tags/express/"}],"title":"express模板的使用","date":"2020/01/28","text":"安装 npm install express --save Demo const express = require('express') const app = express() app.get('/', function (req, res) &#123; res.send('Hello World') &#125;) app.listen(3000,function()&#123; console,log('正在运行......'); &#125; ) 其他参数 app.get('/abc',function()&#123; res.send('这是二级路由') &#125;) 正则 //匹配路由为/student/后面加上10位数字的路由 app.get(/^\\/student\\/([\\d]&#123;10&#125;)$/,function (req,res) &#123; res.send('学号'+req.params[0]); &#125;); //也可以获取到参数之后，然后再用正则进行验证 app.get('/book/:id',function (req,res) &#123; let id = req.params['id']; let reg = /^[\\d]&#123;6&#125;$/; if (reg.test(id))&#123; res.send(id) &#125;else &#123; res.send('error'); &#125; &#125;); express的参数显示 app.get('/teacher/:id',function (req,res) &#123; res.send('工号'+req.params.id); &#125;); express的参数显示的格式限制 //限制编号后面是3-8为数字的路由 app.get('/master/:iid([\\\\d]&#123;3,8&#125;)',function (req,res) &#123; res.send('编号'+req.params.iid); &#125;); tips res.send()还可以send一个json对象 res.send(&#123; 'data':'这是二级路由' &#125;)","permalink":"https://codermino.github.io/2020/01/28/express%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%BD%BF%E7%94%A8/","photos":[]},{"tags":[{"name":"ejs模板的基本使用","slug":"ejs模板的基本使用","permalink":"https://codermino.github.io/tags/ejs%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"}],"title":"ejs模板的使用","date":"2020/01/28","text":"安装 npm install ejs 基本使用1 //引入ejs const ejs = require('ejs'); //定义字符串 let str = '今天是星期&lt;%= a%&gt;'; //定义data data = &#123; a:'天' &#125;; //ejs渲染str和data let html = ejs.render(str, data); //控制台输出 console.log(html); 基本使用2 1.首先创建一个ejs文件:index.ejs &lt;!doctype html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;今天是星期&lt;%=a%&gt;&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 2.使用ejs模板传数据和进行渲染 //引入fs和ejs const fs = require('fs'); const ejs = require('ejs'); //读取文件(读取当前路径下的index.ejs文件) fs.readFile('./index.ejs',function (err, data) &#123; if(err)&#123; console.log(err); &#125;else&#123; //需要将模板转为字符串,因为在传输过程中是byte流 const template = data.toString(); const dictionary = &#123; a:'天' &#125;; //使用ejs进行渲染，传入的数据有data,和ejs界面需要使用的数据 const html = ejs.render(template, dictionary); //控制台输出渲染之后的结果 console.log(html); &#125; &#125;); 基本使用3 //引入fs、ejs和http const fs = require('fs'); const ejs = require('ejs'); const http = require('http'); //使用http开启一个服务器 let server = http.createServer(function (req, res) &#123; fs.readFile('./index.ejs',function (err, data) &#123; if(err)&#123; console.log(err); &#125;else&#123; const template = data.toString(); const dictionary = &#123; a:'天' &#125;; const html = ejs.render(template, dictionary); //显示 res.writeHead(200,&#123;\"Content-Type\":\"text/html;charset=UTF8\"&#125;); res.end(html) &#125; &#125;); &#125;); //在3000端口监听 server.listen(3000, function () &#123; console.log('服务器启动成功'); &#125;); 基本使用4 //也可以在传递数据的时候传入一个数组 const dictionary = &#123; a:'天', news:['星期一','星期二','星期三'] &#125;; //在前端页面中可以使用for循环遍历 &lt;ul&gt; &lt;% for(let i=0; i&lt;news.length; i++)&#123; %&gt; &lt;li&gt;&lt;%=news[i]%&gt;&lt;/li&gt; &lt;%&#125;%&gt; &lt;/ul&gt; 基本使用5 //也可以传入一个数组对象 people:[ &#123;name:'张三',age:29&#125;, &#123;name:'李四',age:31&#125;, &#123;name:'王五',age:38&#125;, &#123;name:'孙六',age:30&#125; ] &lt;ul&gt; &lt;% for(let i = 0;i&lt;people.length;i++)&#123; if(people[i].age&gt;30)&#123; %&gt; &lt;li&gt;&lt;%= people[i].name%&gt;&lt;/li&gt; &lt;%&#125;%&gt; &lt;%&#125;%&gt; &lt;/ul&gt;","permalink":"https://codermino.github.io/2020/01/28/ejs%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%BD%BF%E7%94%A8/","photos":[]},{"tags":[{"name":"formidable文件改名","slug":"formidable文件改名","permalink":"https://codermino.github.io/tags/formidable%E6%96%87%E4%BB%B6%E6%94%B9%E5%90%8D/"}],"title":"formidable上传文件改名","date":"2020/01/25","text":"引用模块 主要使用的是nodejs的fs模块和path模块 var fs = require('fs'); var sd = require('silly-datetime'); var path = require('path') 具体使用 time = sd.format(new Date(),'YYYYMMDDHHMMSS'); 产生一个过位数的随机数 random = parseInt(Math.random()* 89999 + 10000); extname = path.extname(files.前端表单上传的图片的file的名字).name; oldpath = __dirname + '/' + files.名字.path; 这里使用的新的名字由三部分组成：时间戳、随机数、拓展名 newpath = __dirname + '/uploads/' + time + random + extname; 执行 fs.rename(oldpath, newpath, function(err)&#123; if(err)&#123; throw Error('改名失败'); &#125; res.writeHead(200, &#123;'content-type' : 'text/plain'&#125;); res.end('成功'); &#125;);","permalink":"https://codermino.github.io/2020/01/25/formidable%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E6%94%B9%E5%90%8D/","photos":[]},{"tags":[{"name":"formidable文件上传","slug":"formidable文件上传","permalink":"https://codermino.github.io/tags/formidable%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}],"title":"nodejs的formidable","date":"2020/01/25","text":"安装 npm i -S formidable 引用 var formidable = require('formidable'), http = require('http'), util = require('util'); 创建相关路由 http.createServer(function(req, res) &#123; if (req.url == '/upload' &amp;&amp; req.method.toLowerCase() == 'post') &#123; // parse a file upload var form = new formidable.IncomingForm(); form.parse(req, function(err, fields, files) &#123; //在fields中存储的是上传的输入框或者单选框等信息 //在files中存储的是上传的图片或者视频等信息 res.writeHead(200, &#123;'content-type': 'text/plain'&#125;); res.write('received upload:\\n\\n'); res.end(util.inspect(&#123;fields: fields, files: files&#125;)); &#125;); return; &#125; tip: 在前端中的上传的表单中一定要加上:enctype=\"multipart/form-data\" eq: &lt;form action=\"/upload\" enctype=\"multipart/form-data\" method=\"post\"&gt; 相关API参数 -Creates a new incoming form. var form = new formidable.IncomingForm() -Sets encoding for incoming form fields. form.encoding = 'utf-8'; -Sets the directory for placing file uploads in. You can move them later on using fs.rename(). The default is os.tmpdir(). form.uploadDir = \"/my/dir\"; -If you want the files written to form.uploadDir to include the extensions of the original files, set this property to true. form.keepExtensions = false; -Either 'multipart' or 'urlencoded' depending on the incoming request. form.type -Limits the amount of memory all fields together (except files) can allocate in bytes. If this value is exceeded, an 'error' event is emitted. The default size is 20MB. form.maxFieldsSize = 20 * 1024 * 1024; -Limits the size of uploaded file. If this value is exceeded, an 'error' event is emitted. The default size is 200MB. form.maxFileSize = 200 * 1024 * 1024; -Limits the number of fields that the querystring parser will decode. Defaults to 1000 (0 for unlimited). form.maxFields = 1000; -If you want checksums calculated for incoming files, set this to either 'sha1' or 'md5'. form.hash = false; -If this option is enabled, when you call form.parse, the files argument will contain arrays of files for inputs which submit multiple files using the HTML5 multiple attribute. form.multiples = false; Event 'progress' Emitted after each incoming chunk of data that has been parsed. Can be used to roll your own progress bar. form.on('progress', function(bytesReceived, bytesExpected) &#123; &#125;); 'field' Emitted whenever a field / value pair has been received. form.on('field', function(name, value) &#123; &#125;); 'fileBegin' Emitted whenever a new file is detected in the upload stream. Use this event if you want to stream the file to somewhere else while buffering the upload on the file system. form.on('fileBegin', function(name, file) &#123; &#125;); 'file' Emitted whenever a field / file pair has been received. file is an instance of File. form.on('file', function(name, file) &#123; &#125;); 'error' Emitted when there is an error processing the incoming form. A request that experiences an error is automatically paused, you will have to manually call request.resume() if you want the request to continue firing 'data' events. form.on('error', function(err) &#123; &#125;); 'aborted' Emitted when the request was aborted by the user. Right now this can be due to a 'timeout' or 'close' event on the socket. After this event is emitted, an error event will follow. In the future there will be a separate 'timeout' event (needs a change in the node core). form.on('aborted', function() &#123; &#125;); 'end' form.on('end', function() &#123; &#125;); Emitted when the entire request has been received, and all contained files have finished flushing to disk. This is a great place for you to send your response.","permalink":"https://codermino.github.io/2020/01/25/nodejs%E7%9A%84formidable/","photos":[]},{"tags":[{"name":"mongodb","slug":"mongodb","permalink":"https://codermino.github.io/tags/mongodb/"}],"title":"mongodb操作","date":"2020/01/12","text":"查询 find(): db.集合名称.find(&#123;条件文档&#125;) findOne(): db.集合名称.findOne(&#123;条件文档&#125;) pretty():将结果格式化 db.集合名称.find(&#123;条件文档&#125;).pretty() 查询条件 等于:默认是等于判断，没有运算符 小于: $lt (less than) 小于等于:$lte (less than equal) 大于: $gt (greater than) 大于等于:$gte (greater than equal) 不等于: $ne (not equal) eq: db.集合名称.find(&#123;条件文档:&#123;查询条件&#125;&#125;) 使用\"$in\",\"$nin\"判断是否在某个范围内 eq: 查询年龄为18、28的学生 db.stu.find(&#123;age:&#123;$in:[18,28]&#125;&#125;) and: 在json中写多个条件即可 查询年龄大于或等于18，并且性别为true的学术 db.stu.find(age:&#123;$gte:18&#125;,gender:true) or: 使用$or,值为数组，数组中每个元素为json 查询年龄大于18，或性别为false的学生 db.stu.find(&#123;$or:[&#123;age:&#123;$gt:18&#125;&#125;,&#123;gender:false&#125;]&#125;) 查询年龄大于18或者性别为男生，并且姓名是Mark db.stu.find(&#123;$or:[&#123;age:&#123;$gt:18&#125;&#125;,&#123;gender:false&#125;],name:'Mark'&#125;) 正则 使用//或$regex编写正则表达式 查询姓李的学生 db.stu.find(&#123;last_name:/^李/&#125;) db.stu.find(&#123;last_name:&#123;$regex:'^李'&#125;&#125;) limit和skip limit():用于等去指定数量的文档 db.集合名称.find().limit(NUMBER) 查询2条学生信息 db.stu.find().limit(2) skip():用于跳过指定数量的文档 db.集合名称.find().skip(NUMBER) db.stu.find().skip(2) 同时使用 db.stu.find().limit(3).skip(2) 或 db.stu.find().skip(3).limit(2) ★ 自定义查询 在mongodb中支持js语法 使用$where后面写一个函数，返回满足条件的数据 查询年龄大于20的学生 db.stu.find(&#123; $where:function()&#123; return this.age&gt;20; &#125; &#125;) 投影 在查询到的返回结果中，只选择必要的字段 db.集合名称.find(&#123;&#125;,&#123;字段名称:1,.....&#125;) 参数为字段与值，值为1表示显示，值为0不显示 特殊：对于_id列默认是显示的，如果不显示需要明确设置为0 eq: db.stu.find(&#123;&#125;,&#123;_id:0,name:1,age:1,gender:1&#125;) 排序 方法sort(),用于对集合进行排序 db.集合名称.find().sort(&#123;字段1,...&#125;) 参数1位升序排列 参数-1为降序排列 根据性别降序，再根据年龄升序 eq: db.stu.find().sort(&#123;gender:-1,age:1&#125;) 统计个数 方法count()用于统计结果集中文档条数 db.集合名称.find(&#123;条件&#125;).count() db.集合名称.count(&#123;条件&#125;) db.stu.find(&#123;gender:true&#125;).count() db.stu.count(&#123;age:&#123;$gt:20&#125;&#125;,gender:true) 消除重复 方法distinct()对数据进行去重 db.集合名称.distinct('去重字段',&#123;条件&#125;) db.stu.distinct('address',&#123;age:&#123;$gt:20&#125;&#125;) 数据备份和恢复 备份的语法： mongoddump -h host -d dbname -o dbdirectory -h：服务器地址，也可以指定端口号 -d：需要备份的数据库名称 -o：备份的数据存放的位置，此目录中存放着备份出来的数据 eq: mongodump -h 地址 -d test -o 路径 如何备份的是本地的服务器，那么-h可以省略不写 恢复语法： mongorestore -g dbhost -d dbname --dir dbdirectory -h：服务器地址 -d：需要恢复的数据库实例 --dir：备份数据所在的位置 eq: mongoretore -h 地址 -d test2 --dir 地址/test 聚合 聚合(aggregate)是基于数据处理的聚合管道，每个文档通过一个由多个阶段(stage) 组成的管道，可以对每个极端的管道进行分组、过滤等功能，然后经过一系列的处理， 输出相应的结果。 db.集合名称.aggregate(&#123;管道:&#123;表达式&#125;&#125;) 常用管道 在mongodb中，文档处理完毕后，通过管道进行下一次处理 常用管道如下： $group：将集合中的文档分组，可用于统计结果 $match：过滤数据，只输出符合条件的文档 $project：修改输入文档的结构，如重命名、增加、删除字段、创建计算结果 $sort：将输入文档排序后输出 $limit：限制聚合管道返回的文档树 $skip：跳过指定数量的文档，并返回余下的文档 $unwind：将数组类型的字段进行拆分 常用管道表达式 $sum：计算总和，$sum:1表示以一倍计数 $avg：计算平均值 $min：获取最小值 $max：获取最大值 $psuh：在结果文档中插入值到一个数组中 $first：根据资源文档的排序获取第一个文档数据 $last：根据资源文档的排序获取最后一个文档数据 分组 将集合中的文档分组，可用于统计结果 _id表示分组的依据，使用某个字段的格式为'$字段' eq:统计男生、女生的总人数 db.stu.aggregate(&#123; $group: &#123; _id:'$gender', counter:&#123;$sum:1&#125; &#125; &#125;) Group by null 将集合中所有文档分为一组 eq:求学生总人数、平均年靓 db.stu.aggregate(&#123; $group: &#123; _id:null, counter:&#123;$sum:1&#125;, avgAge:&#123;$avg:'$age'&#125; &#125; &#125;) 处理$project 修改输入文档的结构，如重命名、增加、删除字段、创建计算结果 eq1:查询学生的姓名、年龄 db.stu.aggregate( &#123;$project:&#123;_id:0,name:1,age:1&#125;&#125; ) eq2:查询男生、女生人数，输出个数 db.stu.aggregate( &#123;$group:&#123;_id:'$gender',counter:&#123;$sum:1&#125;&#125;&#125;, &#123;$project:&#123;_id:0,counter:1&#125;&#125; ) 综合实例 选择年龄大于20的学生，观察男性和女性有多少人 db.stu.aggregate( &#123;$match:&#123;age:&#123;$gt:20&#125;&#125;&#125;, &#123;$group:&#123;_id:\"$gender\",count:&#123;$sum:1&#125;&#125;&#125;, &#123;$project:&#123;_id:0,gender:\"$_id\",count:1&#125;&#125; ) 排序 $sort -将输入文档排序后输出 eq1: -查询学生信息，按照年龄升序排序 b.stu.aggregate(&#123;$sort:&#123;age:1&#125;&#125;) eq2: -查询男生、女生人数。按人数降序排序 db.stu.aggregate( &#123;$group:&#123;_id:'$gender',counter:&#123;$sum:1&#125;&#125;&#125;, &#123;$sort:&#123;counter:-1&#125;&#125; ) limit和skip $limit -限制聚合管道返回的文数 -eq -查询2条学生信息 db.stu.aggregate(&#123;$limit:2&#125;) $skip -跳过指定数量的文档，并返回余下的文档 -eq -查询从第3条开始的学生信息 db.stu.aggregate(&#123;$skip:2&#125;) -eq 统计男生、女生人数，按人数升序,取第二条数据 db.stu.aggregate( &#123;$group:&#123;_id:'$gender',counter:&#123;$sum:1&#125;&#125;&#125; &#123;$sort:&#123;counter:1&#125;&#125;, &#123;$skip:1&#125;, &#123;$limit:1&#125; ) tip: -注意顺序：先写skip，再写limit（这样做效率更高） -如果想要_id不显示出来，那么在$group中加上_id:null unwind $unwind -属性值为false表示丢弃属性值为空的文档 -属性preserveNullAndEmptyArrays值为true表示保留属性值为空的文档 用法： db.invertory.aggregate(&#123; $unwind:&#123; path:'$字段名称', preserveNullAndEmptyArrays:&lt;boolean&gt;#防止数据丢失 &#125; &#125;) 索引 索引：以提升查询速度 测试：插入10万条数据到数据库中 for(i=0;i&lt;100000;i++)&#123; db.t255.insert(&#123;name:'test'+i,age:i&#125;) &#125; db.t1.find(&#123;name:'test10000'&#125;) db.t1.find(&#123;name:'test10000'&#125;).explain('executionStats') 建立索引之后的对比： 语法：db.集合.ensureIndex(&#123;属性：1&#125;)，1表示升序，-1表示降序 具体操作：db.t255.ensureIndex(&#123;name:1&#125;) db.t1.find(&#123;name:'test10000'&#125;).explain('executionStats') 在默认情况下索引字段的值可以相同 创建唯一索引（索引的值是唯一的）： -db.t1.ensureIndex(&#123;'name':1&#125;,&#123;'unique':true&#125;) 建立联合索引（什么时候需要联合索引）： -db.t1.ensureIndex(&#123;name:1,age:1&#125;) 查看当前集合的所有索引: -db.t1.getIndexes() 删除索引： -db.t1.dropIndex(&#123;'索引名称':1&#125;) mongodb mysql redis的区别和使用场景 -mysql是关系型数据库，支持事务 -MongoDB，redis非关系型数据库，不支持事务 -mysql，mongodb,redis的使用根据如何方便进行选择 -希望速度快的时候，选择mongodb或者是redis -数据量过大的时候，选择频繁使用的数据存入redis，其他的存入mongodb -mongodb不用提前建表建数据库，使用方便，字段数量不确定的时候使用mongodb -后续需要用到数据之间的关系，此时考虑mysql 爬虫数据去重 使用数据库建立关键字段（一个或者多个）建立索引进行去重 根据url地址进行去重 -使用场景： url地址对应的数据不会变的情况，url地址能够唯一判别一条数据的情况 -思路 url存在redis中 拿到url地址，判断url在redis的url的集合中是否存在 存在： 说明url已经被请求过，不再请求 不存在： url地址没有被请求过，请求，把该url存入redis的集合中 -布隆过滤器 使用多个加密算法加密url地址，得到多个值 往对应值的位置把结果设置为1 新来一个url地址，一样通过加密算法生成多个值 如果对应的位置的值全为1，说明这个url地址已经抓取过 否则没有抓过，就把对应位置的值设置为1 根据数据本身进行去重 选择特定的字段，使用加密算法（md5,sha1）将字段进行加密，生成字符串，存入redis的集合中 后续新来一条数据，同样的方法进行加密，如果得到的字符串在redis中存在，说明数据存在，对数据进行更新，否则说明数据不存在，直接插入","permalink":"https://codermino.github.io/2020/01/12/mongodb%E6%93%8D%E4%BD%9C/","photos":[]},{"tags":[{"name":"git","slug":"git","permalink":"https://codermino.github.io/tags/git/"}],"title":"Git基本操作","date":"2019/12/05","text":"master:默认开发分支 Head :默认开发分支 origin:默认远程版本库 Head^ :Head 的父提交 创建版本库 git clone &lt;url&gt; 克隆远程版本库 git init 初始化本地版本库 修改和提交 git status 查看状态 git diff 查看变更内容 git add . 跟踪所有改动过的文件#跟踪指定的文件 git add &lt;file&gt; 跟踪指定的文件 git mv &lt;old&gt; &lt;new&gt; 文件改名 git rm &lt;file&gt; 删除文件 git rm --cached &lt;file&gt; 停止跟踪文件但不删除 git commit -m 'message' 提交所有更新过的文件 git commit --amend 修改最后一次提交 查看提交历史 git log 查看提交历史 git log -p &lt;file&gt; 查看指定文件的提交历史 git blame &lt;file&gt; 以列表方式查看指定文件的提交历史 撤销 git reset --hard HEAD 撤消工作目录中所有未提交文件的修改内容 git checkout HEAD &lt;file&gt; 撤消指定的未提交文件的修改内容 git revert &lt;commit&gt; 撤消指定的提交 分支与标签 git branch 显示所有本地分支 git checkout &lt;branch/tag&gt; 切换到指定分支或标签 git branch &lt;new- branch&gt; 创建新分支 git branch -d &lt;branch&gt; 删除本地分支 git tag 列出所有本地标签 git tag &lt;tagname&gt; 基于最新提交创建标签 git tag -d &lt;tagname&gt; 删除标签 合并与衍合 git merge &lt;branch&gt; 合并指定分支到当前分支 git rebase &lt;branch&gt; 行合指定分支到当前分支 远程操作 git remote -V 查看远程版本库信息 git remote show &lt;remote&gt; 查看指定远程版本库信息 git remote add &lt;remote&gt; &lt;url&gt; 添加远程版本库 git fetch &lt;remote&gt; 从远程库获取代码 git pull &lt;remote&gt; &lt;branch&gt; 下载代码及快速合并 git push &lt;remote&gt; &lt;branch&gt; 上传代码及快速合并 git push &lt;remote&gt; : &lt;branch/ tag一name&gt; 删除远程分支或标签 git push --tags 上传所有标签 例子 git 新建分支并提交本地代码到远程分支 step1：在本地新建分支 git branch newbranch step2：把本地分支push到远程 git push origin newbranch step3：切换到该分支 git checkout newbranch step4：查看本地修改 git status step5：添加本地修改 git add . step6：commit修改 git commit -m 'XXXX' step7：push代码 git push OVER 在github远程端删除一个分支 git push origin :newbranch (分支名前的冒号代表删除)","permalink":"https://codermino.github.io/2019/12/05/Git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","photos":[]}]}